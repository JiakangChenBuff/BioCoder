{"golden":{"0":"public void cleanJob(File jobDir) throws IOException {\n    if (this.verbose) {\n        System.out.print(\"Cleaning RAMPART job directory: \" + jobDir.getAbsolutePath() + \" ...\");\n    }\n    FileUtils.deleteDirectory(new File(jobDir, \"rampart_out\"));\n    FileUtils.deleteDirectory(new File(jobDir, \"wait_logs\"));\n    if (this.verbose) {\n        System.out.println(\" done.\");\n    }\n}","1":"public T create(String name) {\n    for (T service : loader) {\n        if (this.acceptsIdentifier(name, service)) {\n            return service;\n        }\n    }\n    return null;\n}","2":"public T create(String name, ConanExecutorService ces) {\n    for (T service : loader) {\n        if (this.acceptsIdentifier(name, service)) {\n            ((AbstractConanProcess) service).setConanProcessService(ces.getConanProcessService());\n            return service;\n        }\n    }\n    return null;\n}","3":"public List<String> listServices() {\n    List<T> services = getServices();\n    List<String> typeStrings = new ArrayList<>();\n    for (T service : services) {\n        typeStrings.add(service.getName());\n    }\n    return typeStrings;\n}","4":"public List<T> getServices() {\n    Iterator<T> it = loader.iterator();\n    List<T> serviceList = new ArrayList<>();\n    while (it.hasNext()) {\n        serviceList.add(it.next());\n    }\n    return serviceList;\n}","5":"public void removeChange(int idx) {\n    startEditing();\n    if (idx >= nTypeChanges)\n        throw new IllegalArgumentException(\"Index to removeChange() out of range.\");\n    changeTimes.remove(idx);\n    changeTypes.remove(idx);\n    nTypeChanges -= 1;\n}","6":"public void setTypeTrait(TraitSet traitSet) {\n    if (hasTypeTrait()) {\n        m_traitList.get().remove(typeTraitSet);\n    }\n    if (traitSet != null) {\n        typeTraitInput.setValue(traitSet, this);\n    }\n    typeTraitSet = traitSet;\n}","7":"@Override\npublic MultiTypeTree copy() {\n    MultiTypeTree tree = new MultiTypeTree();\n    tree.ID = ID;\n    tree.index = index;\n    tree.root = root.copy();\n    tree.nodeCount = nodeCount;\n    tree.internalNodeCount = internalNodeCount;\n    tree.leafNodeCount = leafNodeCount;\n    tree.typeLabel = typeLabel;\n    return tree;\n}","8":"public int getTotalNumberOfChanges() {\n    int count = 0;\n    for (Node node : m_nodes) {\n        if (node.isRoot())\n            continue;\n        count += ((MultiTypeNode) node).getChangeCount();\n    }\n    return count;\n}","9":"@Override\npublic double getBackwardRate(int i, int j) {\n    if (i == j)\n        return 0;\n    if (useForwardMigrationRateMatrix) {\n        return getForwardRate(j, i) * getPopSize(j) \/ getPopSize(i);\n    } else {\n        int offset = getArrayOffset(i, j);\n        if (rateMatrixFlagsInput.get() != null && !rateMatrixFlagsInput.get().getValue(offset))\n            return 0.0;\n        else\n            return getRateScaleFactor() * rateMatrix.getArrayValue(offset);\n    }\n}","10":"@Override\npublic int RpowSteadyN(boolean symmetric) {\n    if (symmetric) {\n        if (RsymPowSteady)\n            return RsymPowN.size();\n        else\n            return -1;\n    } else {\n        if (RpowSteady)\n            return RpowN.size();\n        else\n            return -1;\n    }\n}","11":"public static void main(String[] args) {\n    int n = 10;\n    DoubleMatrix Q = new DoubleMatrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            Q.put(i, j, i * n + j);\n        }\n    }\n    MatrixFunctions.expm(Q.mul(0.001)).print();\n    Q.print();\n}","12":"private int selectLegalChangeType() {\n    int n = Randomizer.nextInt(migModel.getNTypes() - illegalTypes.size());\n    int changeType;\n    for (changeType = 0; changeType < migModel.getNTypes(); changeType++) {\n        if (illegalTypes.contains(changeType))\n            continue;\n        if (n == 0)\n            break;\n        n -= 1;\n    }\n    return changeType;\n}","13":"private boolean invalidDestNode(Node srcNode, Node destNode) {\n    if (destNode == srcNode || destNode == srcNode.getParent() || destNode.getParent() == srcNode.getParent())\n        return true;\n    Node destNodeP = destNode.getParent();\n    if (destNodeP != null && (destNodeP.getHeight() <= srcNode.getHeight()))\n        return true;\n    return false;\n}","14":"private boolean invalidDestNode(Node srcNode, Node destNode) {\n    if (destNode == srcNode || destNode == srcNode.getParent() || destNode.getParent() == srcNode.getParent())\n        return true;\n    Node destNodeP = destNode.getParent();\n    if (destNodeP != null && (destNodeP.getHeight() <= srcNode.getHeight()))\n        return true;\n    return false;\n}","15":"protected double getBranchTypeProb(Node srcNode) {\n    double mu = muInput.get();\n    double T = srcNode.getParent().getHeight() - srcNode.getHeight();\n    int n = ((MultiTypeNode) srcNode).getChangeCount();\n    int N = migModel.getNTypes();\n    if (N == 0)\n        return 0.0;\n    else\n        return -mu * T + n * Math.log(mu \/ (N - 1));\n}","16":"private boolean invalidDestNode(Node srcNode, Node destNode) {\n    if (destNode == srcNode || destNode == srcNode.getParent() || destNode.getParent() == srcNode.getParent())\n        return true;\n    Node destNodeP = destNode.getParent();\n    if (destNodeP != null && (destNodeP.getHeight() <= srcNode.getHeight()))\n        return true;\n    return false;\n}","17":"protected double getRootBranchTypeProb(Node srcNode) {\n    double logProb = 0.0;\n    Node srcNodeP = srcNode.getParent();\n    Node srcNodeS = getOtherChild(srcNodeP, srcNode);\n    logProb += Math.log(1.0 \/ migModel.getNTypes());\n    logProb += getBranchTypeProb(srcNode);\n    logProb += getBranchTypeProb(srcNodeS);\n    return logProb;\n}","18":"private int countVariantOnAmplicons(Variant vref, Map<Integer, List<Variant>> goodVariantsOnAmp) {\n    int gvscnt = 0;\n    for (Map.Entry<Integer, List<Variant>> entry : goodVariantsOnAmp.entrySet()) {\n        List<Variant> variants = entry.getValue();\n        for (Variant variant : variants) {\n            if (variant.refallele.equals(vref.refallele) && variant.varallele.equals(vref.varallele)) {\n                gvscnt++;\n            }\n        }\n    }\n    return gvscnt;\n}","19":"\/**\n * In not parallel mode each region will be processed in sequence.\n *\/\n@Override\npublic void notParallel() {\n    VariantPrinter variantPrinter = VariantPrinter.createPrinter(instance().printerTypeOut);\n    for (List<Region> list : segments) {\n        for (Region region : list) {\n            processRegion(region, variantPrinter);\n        }\n    }\n}","20":"\/**\n * In not parallel mode each region will be processed in sequence.\n *\/\n@Override\npublic void notParallel() {\n    VariantPrinter variantPrinter = VariantPrinter.createPrinter(instance().printerTypeOut);\n    for (List<Region> list : segments) {\n        for (Region region : list) {\n            processBamInPipeline(region, variantPrinter);\n        }\n    }\n}","21":"\/**\n * In not parallel mode each region will be processed in sequence.\n *\/\n@Override\npublic void notParallel() {\n    VariantPrinter variantPrinter = VariantPrinter.createPrinter(instance().printerTypeOut);\n    for (List<Region> list : segments) {\n        for (Region region : list) {\n            final Set<String> splice = new ConcurrentHashSet<>();\n            Reference ref = tryToGetReference(region);\n            processBothBamsInPipeline(variantPrinter, region, splice, ref);\n        }\n    }\n}","22":"public static Map<String, Integer> readChr(String bam) throws IOException {\n    try (SamReader reader = SamReaderFactory.makeDefault().open(new File(bam))) {\n        SAMFileHeader header = reader.getFileHeader();\n        Map<String, Integer> chrs = new HashMap<>();\n        for (SAMSequenceRecord record : header.getSequenceDictionary().getSequences()) {\n            record.getSequenceLength();\n            String sn = record.getSequenceName();\n            int ln = record.getSequenceLength();\n            chrs.put(sn, ln);\n        }\n        return chrs;\n    }\n}","23":"\/**\n * Read record from SAM\/BAM file. Skip the record that are filtered with -F filter option.\n * @return SAMRecord created from each string in SAM\/BAM file.\n *\/\npublic SAMRecord read() {\n    while (iterator.hasNext()) {\n        SAMRecord record = iterator.next();\n        if (filter != 0 && (record.getFlags() & filter) != 0) {\n            continue;\n        }\n        return record;\n    }\n    return null;\n}","24":"public static int strandBias(int forwardCount, int reverseCount) {\n    if (forwardCount + reverseCount <= 12) {\n        return forwardCount * reverseCount > 0 ? 2 : 0;\n    }\n    return (forwardCount \/ (double) (forwardCount + reverseCount) >= instance().conf.bias && reverseCount \/ (double) (forwardCount + reverseCount) >= instance().conf.bias && forwardCount >= instance().conf.minBiasReads && reverseCount >= instance().conf.minBiasReads) ? 2 : 1;\n}","25":"public static String joinRef(Map<Integer, Character> baseToPosition, int from, int to) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = from; i <= to; i++) {\n        Character ch = baseToPosition.get(i);\n        if (ch != null) {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}","26":"public static String joinRef(Map<Integer, Character> baseToPosition, int from, double to) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = from; i < to; i++) {\n        Character ch = baseToPosition.get(i);\n        if (ch != null) {\n            sb.append(ch);\n        }\n    }\n    return sb.toString();\n}","27":"public static String joinRefFor5Lgins(Map<Integer, Character> baseToPosition, int from, int to, String seq, String EXTRA) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = from; i <= to; i++) {\n        if (to - i < seq.length() - EXTRA.length()) {\n            sb.append(charAt(seq, to - i + EXTRA.length()));\n        } else {\n            Character ch = baseToPosition.get(i);\n            if (ch != null) {\n                sb.append(ch);\n            }\n        }\n    }\n    return sb.toString();\n}","28":"public static Variation getVariationMaybe(Map<Integer, VariationMap<String, Variation>> hash, int start, Character refBase) {\n    if (refBase == null)\n        return null;\n    Map<String, Variation> map = hash.get(start);\n    if (map == null) {\n        return null;\n    }\n    return map.get(refBase.toString());\n}","29":"\/**\n * Method creates string from elements of specified collection (by appending them with space delimiter)\n * @param collection any collection\n * @param <E> generic type of collection elements\n * @return generated string\n *\/\npublic static <E> String toString(Collection<E> collection) {\n    Iterator<E> it = collection.iterator();\n    if (!it.hasNext())\n        return \"\";\n    StringBuilder sb = new StringBuilder();\n    for (; ; ) {\n        E e = it.next();\n        sb.append(e == collection ? \"(this Collection)\" : e);\n        if (!it.hasNext())\n            return sb.toString();\n        sb.append(' ');\n    }\n}","30":"public static String join(String delim, Object... args) {\n    if (args.length == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < args.length; i++) {\n        sb.append(args[i]);\n        if (i + 1 != args.length) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}","31":"public static String substr(String string, int begin, int len) {\n    if (begin < 0) {\n        begin = string.length() + begin;\n    }\n    if (len > 0) {\n        return string.substring(begin, Math.min(begin + len, string.length()));\n    } else if (len == 0) {\n        return \"\";\n    } else {\n        int end = string.length() + len;\n        if (end < begin) {\n            return \"\";\n        }\n        return string.substring(begin, end);\n    }\n}","32":"public static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region) {\n    String firstPart = \"There was Exception while processing \" + place + \" on \" + placeDef;\n    String secondPart = \". The processing will be continued from the next \" + place + \".\";\n    if (region != null) {\n        System.err.println(firstPart + \" on region \" + region.printRegion() + secondPart);\n        exception.printStackTrace();\n    } else {\n        System.err.println(firstPart + \" but region is undefined\" + secondPart);\n        exception.printStackTrace();\n    }\n    int currentCount = instance().conf.exceptionCounter.incrementAndGet();\n    if (currentCount > Configuration.MAX_EXCEPTION_COUNT) {\n        System.err.println(\"VarDictJava fails (there were \" + instance().conf.exceptionCounter.get() + \" continued exceptions during the run).\");\n        throw new RuntimeException(exception);\n    }\n}","33":"private SAMRecord nextOnCurrentReader() {\n    SAMRecord record;\n    do {\n        if ((record = currentReader.read()) == null) {\n            return null;\n        }\n    } while (!preprocessRecord(record));\n    return record;\n}","34":"public static double nodeLength(Node node) {\n    double length = 0;\n    if (node.isTerminal()) {\n        length = node.getBranchLength();\n    } else {\n        length = node.getBranchLength();\n        double left = nodeLength(node.getLeftChild());\n        double right = nodeLength(node.getRightChild());\n        double longer = left > right ? left : right;\n        length += longer;\n    }\n    return length;\n}","35":"public Node getSister() {\n    Node sister;\n    if (this.isRoot()) {\n        sister = null;\n    } else {\n        Node left = this.getParent().getLeftChild();\n        Node right = this.getParent().getRightChild();\n        sister = this.equals(left) ? right : left;\n    }\n    return sister;\n}","36":"public int[] positions() {\n    int[] pos = new int[this.cardinality()];\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (this.bits[i] == 1) {\n            pos[count] = i;\n            count++;\n        }\n    }\n    return pos;\n}","37":"public void set(int i, int j, double matrix) {\n    if (matrix < 0) {\n        matrix = 0;\n    }\n    if (inRange(i) && inRange(j) && i != j) {\n        this.matrix[i][j] = matrix;\n        this.matrix[j][i] = matrix;\n    }\n}","38":"public int getQueryCoverage() {\n    int queryCoverage = 0;\n    Segment[] querySegment = new Segment[subHit.length];\n    for (int i = 0; i < subHit.length; i++) {\n        querySegment[i] = new Segment(subHit[i].getQuerySequenceStart(), subHit[i].getQuerySequenceEnd());\n    }\n    queryCoverage = Segment.segmentCoverage(querySegment);\n    return queryCoverage;\n}","39":"public int getSubjectCoverage() {\n    int subjectCoverage = 0;\n    Segment[] subjectSegment = new Segment[subHit.length];\n    for (int i = 0; i < subHit.length; i++) {\n        subjectSegment[i] = new Segment(subHit[i].getSubjectSequenceStart(), subHit[i].getSubjectSequenceEnd());\n    }\n    subjectCoverage = Segment.segmentCoverage(subjectSegment);\n    return subjectCoverage;\n}","40":"\/**\n * create the plugins, and load the plugins for TRANSFORMING mode\n *\/\n@Override\nprotected void loadPlugins() {\n    this.pickingPlugin = myPickingPlugin;\n    this.animatedPickingPlugin = new AnimatedPickingGraphMousePlugin<V, E>();\n    this.translatingPlugin = new TranslatingGraphMousePlugin(InputEvent.BUTTON1_MASK);\n    this.scalingPlugin = new ScalingGraphMousePlugin(new CrossoverScalingControl(), 0, in, out);\n    this.rotatingPlugin = new RotatingGraphMousePlugin();\n    this.shearingPlugin = new ShearingGraphMousePlugin();\n    add(scalingPlugin);\n    setMode(Mode.TRANSFORMING);\n}","41":"@Override\npublic JComboBox getModeComboBox() {\n    if (modeBox == null) {\n        modeBox = new JComboBox(new Mode[] { Mode.TRANSFORMING, Mode.PICKING, Mode.ANNOTATING });\n        modeBox.addItemListener(getModeListener());\n    }\n    modeBox.setSelectedItem(mode);\n    return modeBox;\n}","42":"public static void saveImage(File imageFile, String format, VisualizationViewer<HitVertex, ValueEdge> vv) throws IOException {\n    vv.setDoubleBuffered(false);\n    int width = vv.getWidth();\n    int height = vv.getHeight();\n    BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    Graphics2D graphics = bi.createGraphics();\n    vv.paint(graphics);\n    graphics.dispose();\n    ImageIO.write(bi, format, imageFile);\n    vv.setDoubleBuffered(true);\n}","43":"public Sequence getSequence(ChrString chr_name) {\n    if (data.containsKey(chr_name)) {\n        if (data.get(chr_name) == null) {\n            ReferenceSequence sequence = dataSources.get(chr_name).getSequence(chr_name.toString());\n            data.put(chr_name, new Sequence(chr_name.toString(), sequence.getBases(), sequence.length()));\n        }\n    } else {\n        return null;\n    }\n    return data.get(chr_name);\n}","44":"public byte byteAt(ChrString chr_name, int loc) {\n    if (loc < 1) {\n        return 0;\n    }\n    if (data.containsKey(chr_name)) {\n        if (data.get(chr_name) == null) {\n            return dataSources.get(chr_name).getSubsequenceAt(chr_name.toString(), loc, loc).getBases()[0];\n        } else {\n            return data.get(chr_name).byteAt(loc);\n        }\n    } else {\n        return 0;\n    }\n}","45":"\/**\n * Increments the bin that val belongs in\n *\n * @param val value to be added\n *\/\npublic void add(int val) {\n    total_count++;\n    if (val >= Constant.SVLEN)\n        sv_total_count++;\n    for (int i = 0; i < bin_breaks.length; i++) {\n        if (val <= bin_breaks[i]) {\n            bin_counts[i]++;\n            return;\n        }\n    }\n    bin_counts[num_bins - 1]++;\n}","46":"public int getNumNonNBases() {\n    int count = 0;\n    if (numNonNBases == null) {\n        for (byte b : _seq) {\n            if (!isN(b))\n                count++;\n        }\n        numNonNBases = count;\n    }\n    return numNonNBases;\n}","47":"public int maxLen() {\n    if (compositions == null) {\n        return Math.max(maxLen(getAllele(0)), maxLen(getAllele(1)));\n    } else {\n        if (compositions.isEmpty())\n            return 0;\n        int maxLen = compositions.get(0).maxLen();\n        for (Variant c : compositions) {\n            maxLen = Math.max(maxLen, c.maxLen());\n        }\n        return maxLen;\n    }\n}","48":"public void randomizeGenotype(GenderType gender) {\n    if (rand == null) {\n        log.error(\"Cannot randomize genotype\");\n        log.error(toString());\n        System.exit(1);\n    }\n    Genotypes g = new Genotypes(chr, gender, alts.length, rand);\n    paternal = g.geno[0];\n    maternal = g.geno[1];\n    isPhased = true;\n}","49":"public boolean isAltACTGN() {\n    for (Alt a : alts) {\n        if (a.isSeq()) {\n            if (!a.getSeq().toString().matches(\"[ACTGN]*\")) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","50":"public boolean isHom() {\n    if (chr.isMT() && maternal < 0) {\n        return false;\n    }\n    if (chr.isY() && paternal < 0) {\n        return false;\n    }\n    if (maternal < 0 || paternal < 0) {\n        return false;\n    }\n    return (paternal == maternal);\n}","51":"private List<String> rmDupInfo(List<String> fields) {\n    Set<String> seen = new HashSet<>();\n    List<String> uniqueNonEmptyFields = new ArrayList<>();\n    for (String i : fields) {\n        if (i.isEmpty() || i.equals(\".\")) {\n            continue;\n        } else {\n            String fieldName = i.split(\"=\")[0];\n            if (!seen.contains(fieldName)) {\n                uniqueNonEmptyFields.add(i);\n                seen.add(fieldName);\n            }\n        }\n    }\n    return uniqueNonEmptyFields;\n}","52":"public byte sampleGenotype(byte geno, SampleParams seenAdded, int numSample, int numTotal, boolean outputAll) {\n    if (!outputAll) {\n        if (seenAdded.addedNum < numSample) {\n            double randNum = rand.nextDouble();\n            if ((numTotal - seenAdded.seenNum) * randNum >= (numSample - seenAdded.addedNum)) {\n                seenAdded.seenNum++;\n                return 0;\n            } else {\n                seenAdded.seenNum++;\n                seenAdded.addedNum++;\n                return geno;\n            }\n        }\n    } else {\n        return geno;\n    }\n    return 0;\n}","53":"private List<Variant> canonicalizeVariant(Variant var) {\n    List<Variant> variantList = canonicalizeVariant(new Variant(var), false);\n    List<Variant> variantListEnd = canonicalizeVariant(new Variant(var), true);\n    if (variantListEnd.size() < variantList.size()) {\n        variantList = variantListEnd;\n    }\n    return variantList;\n}","54":"private static boolean isContainedInBed(BedFile intersector, Collection<GenomeLocation> trueLoci, SAMRecord rec) {\n    if (intersector == null) {\n        return true;\n    }\n    boolean isContainedInBed = false;\n    for (GenomeLocation loc : trueLoci) {\n        if (intersector.contains(loc.chromosome, loc.location, loc.location + rec.getReadLength() - 1)) {\n            isContainedInBed = true;\n        }\n    }\n    return isContainedInBed;\n}","55":"public int checkKey(final Interval1D k) {\n    if (overlapCenter(k)) {\n        return 0;\n    }\n    if (k.getRight() < centerCut) {\n        return -1;\n    } else {\n        return 1;\n    }\n}","56":"public int compareTo(final Interval1D that) {\n    if (this.getLeft() < that.getLeft())\n        return -1;\n    else if (this.getLeft() > that.getLeft())\n        return +1;\n    else if (this.getRight() < that.getRight())\n        return -1;\n    else if (this.getRight() > that.getRight())\n        return +1;\n    else\n        return 0;\n}","57":"public Conversion getCopy() {\n    Conversion copy = new Conversion();\n    copy.locus = locus;\n    copy.acg = acg;\n    copy.startSite = startSite;\n    copy.endSite = endSite;\n    copy.node1 = node1;\n    copy.node2 = node2;\n    copy.height1 = height1;\n    copy.height2 = height2;\n    return copy;\n}","58":"private List<Conversion> getCompatibleConversions() {\n    List<Conversion> compatible = new ArrayList<>();\n    for (Locus locus : acg.getConvertibleLoci()) {\n        for (Conversion conv : acg.getConversions(locus)) {\n            if (conv.getNode1() != conv.getNode2())\n                compatible.add(conv);\n        }\n    }\n    return compatible;\n}","59":"private Locus chooseLocus() {\n    int z = Randomizer.nextInt(acg.getTotalConvertibleSequenceLength());\n    for (Locus locus : acg.getConvertibleLoci()) {\n        if (z < locus.getSiteCount())\n            return locus;\n        else\n            z -= locus.getSiteCount();\n    }\n    throw new IllegalStateException(\"Programmer error: loop fell through\" + \" in chooseAlignment().\");\n}","60":"protected Conversion chooseConversion() {\n    int idx = Randomizer.nextInt(acg.getTotalConvCount());\n    for (Locus locus : acg.getConvertibleLoci()) {\n        if (idx < acg.getConvCount(locus))\n            return acg.getConversions(locus).get(idx);\n        else\n            idx -= acg.getConvCount(locus);\n    }\n    throw new IllegalStateException(\"Programmer error: loop fell through\" + \" in chooseConversion().\");\n}","61":"public static int countSampledTrueClades(Clade[] trueClades, Clade[] clades, double ageTol, Map<Clade, Integer> cladeHist) {\n    int foundClades = 0;\n    for (Clade trueClade : trueClades) {\n        for (Clade clade : clades) {\n            if (!clade.equals(trueClade))\n                continue;\n            foundClades += 1;\n            cladeHist.put(clade, cladeHist.get(clade) + 1);\n            break;\n        }\n    }\n    return foundClades;\n}","62":"\/**\n * Assemble list of bitSets for this ACG.\n *\/\npublic BitSet[] getBitSets(ConversionGraph acg) {\n    if (bitSets == null)\n        bitSets = new BitSet[acg.getNodeCount()];\n    applyToClades(acg.getRoot(), (cladeNode, bits) -> {\n        bitSets[cladeNode.getNr()] = bits;\n        return null;\n    });\n    return bitSets;\n}","63":"public BitSet applyToClades(Node node, BiFunction<Node, BitSet, Void> function) {\n    BitSet bits = new BitSet();\n    if (node.isLeaf()) {\n        bits.set(2 * getTaxonIndex(node));\n    } else {\n        for (Node child : node.getChildren()) bits.or(applyToClades(child, function));\n    }\n    function.apply(node, bits);\n    return bits;\n}","64":"public static boolean rangesEqual(List<Integer> as1, List<Integer> as2) {\n    if (as1.size() != as2.size())\n        return false;\n    for (int i = 0; i < as1.size(); i++) {\n        if (!as1.get(i).equals(as2.get(i)))\n            return false;\n    }\n    return true;\n}","65":"public static double getMeanTractLength(ConversionGraph acg, Locus locus) {\n    if (acg.getConvCount(locus) < 1)\n        return Double.NaN;\n    double mean = 0;\n    for (Conversion conv : acg.getConversions(locus)) mean += conv.getEndSite() - conv.getStartSite() + 1;\n    mean \/= acg.getConvCount(locus);\n    return mean;\n}","66":"public static double getMeanRegionLength(ConversionGraph acg, Locus locus) {\n    double sum = 0.0;\n    int count = 0;\n    for (Region region : acg.getRegions(locus)) if (!region.isClonalFrame()) {\n        sum += region.getRegionLength();\n        count += 1;\n    }\n    if (count == 0)\n        return Double.NaN;\n    else\n        return sum \/ count;\n}","67":"public static double getMeanEdgeLength(ConversionGraph acg) {\n    if (acg.getTotalConvCount() < 1)\n        return Double.NaN;\n    double mean = 0.0;\n    for (Locus locus : acg.getConvertibleLoci()) {\n        for (Conversion conv : acg.getConversions(locus)) mean += conv.getHeight2() - conv.getHeight1();\n    }\n    mean \/= acg.getTotalConvCount();\n    return mean;\n}","68":"public static double getMeanDepartureHeight(ConversionGraph acg) {\n    if (acg.getTotalConvCount() < 1)\n        return Double.NaN;\n    double mean = 0.0;\n    for (Locus locus : acg.getConvertibleLoci()) {\n        for (Conversion conv : acg.getConversions(locus)) {\n            mean += conv.getHeight1();\n        }\n    }\n    mean \/= acg.getTotalConvCount();\n    return mean;\n}","69":"\/**\n * Assembles complete site list for association with a leaf node.\n *\n * @return list of sites\n *\/\nprotected Map<Locus, List<Integer>> getLeafAncestralSites() {\n    Map<Locus, List<Integer>> res = new HashMap<>();\n    for (Locus locus : acg.getConvertibleLoci()) {\n        List<Integer> siteRange = new ArrayList<>();\n        siteRange.add(0);\n        siteRange.add(locus.getSiteCount() - 1);\n        res.put(locus, siteRange);\n    }\n    return res;\n}","70":"public Alignment createMarginalAlignment(Alignment alignment, ConversionGraph acg, Region region) {\n    List<Sequence> sequences = new ArrayList<>();\n    for (int leafIdx = 0; leafIdx < alignment.getTaxonCount(); leafIdx++) {\n        List<Integer> stateSequence;\n        stateSequence = alignment.getCounts().get(leafIdx).subList(region.leftBoundary, region.rightBoundary);\n        String taxonName = alignment.getTaxaNames().get(leafIdx);\n        String charSequence = alignment.getDataType().encodingToString(stateSequence);\n        sequences.add(new Sequence(taxonName, charSequence));\n    }\n    return new Alignment(sequences, alignment.getDataType().getTypeDescription());\n}","71":"public static int terminalAlignedPosition(SAMRecord sr, Strandedness strandedness, boolean end5p) {\n    if (strandedness == Strandedness.forward) {\n        int terminus = sr.getReadNegativeStrandFlag() ^ end5p ? sr.getAlignmentStart() : sr.getAlignmentEnd();\n        return terminus;\n    } else if (strandedness == Strandedness.reverse) {\n        int terminus = sr.getReadNegativeStrandFlag() ^ end5p ? sr.getAlignmentEnd() : sr.getAlignmentStart();\n        return terminus;\n    } else {\n        throw new RuntimeException(\"Unimplemented\");\n    }\n}","72":"public IntervalNode<S> getNotSmaller(int start) {\n    IntervalNode<S> candidate = null;\n    for (IntervalNode<S> node = top; node != null; ) {\n        if (node.start < start) {\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        } else {\n            candidate = node;\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        }\n    }\n    return null;\n}","73":"public IntervalNode<S> getNotLarger(int start) {\n    IntervalNode<S> candidate = null;\n    for (IntervalNode<S> node = top; node != null; ) {\n        if (node.start > start) {\n            if (node.left == null) {\n                return candidate;\n            }\n            node = node.left;\n        } else {\n            candidate = node;\n            if (node.right == null) {\n                return candidate;\n            }\n            node = node.right;\n        }\n    }\n    return null;\n}","74":"public static double hyperGeomPvalueSum(int N, int n, int m, int k, int mode) throws ArithmeticException {\n    double sum = 0.0;\n    int kMax;\n    switch(mode) {\n        case 0:\n            kMax = Math.min(n, m);\n            for (int k_prime = k; k_prime <= kMax; k_prime++) {\n                sum += hyperGeomPvalue(N, n, m, k_prime);\n            }\n            break;\n        case 1:\n            kMax = Math.min(n, m);\n            for (int k_prime = k + 1; k_prime <= kMax; k_prime++) {\n                sum += hyperGeomPvalue(N, n, m, k_prime);\n            }\n            break;\n        case 2:\n            for (int k_prime = k; k_prime >= 0; k_prime--) {\n                sum += hyperGeomPvalue(N, n, m, k_prime);\n            }\n            break;\n        case 3:\n            for (int k_prime = k - 1; k_prime >= 0; k_prime--) {\n                sum += hyperGeomPvalue(N, n, m, k_prime);\n            }\n            break;\n    }\n    return sum;\n}","75":"public LinearNumberInterpolator withDomainCutoff(final double lowerValue, final double upperValue) {\n    return new LinearNumberInterpolator(lowerDomain, upperDomain, lowerRange, upperRange) {\n\n        @Override\n        public double getRangeValue(double domainValue) {\n            if (domainValue < lowerDomain)\n                return lowerValue;\n            if (domainValue > upperDomain)\n                return upperValue;\n            return super.getRangeValue(domainValue);\n        }\n    };\n}","76":"public static String getGeneName(CyNetwork network, CyNode node) {\n    if (network != null && node != null) {\n        AssociatedApp app = getAssociatedApp(network);\n        if (app != null) {\n            var geneNameCol = app.getGeneNameColumn();\n            if (geneNameCol != null) {\n                return geneNameCol.get(network.getRow(node));\n            }\n        }\n    }\n    return null;\n}","77":"\/**\n * Row normalize the current gene expression set. Row normalization involved\n * subtracting the mena of the row from each expression value in the row and\n * subsequently dividing it by the standard deviation of the expression row.\n *\n * @return an array of the row normalized values of the gene expression set.\n *\/\npublic float[] rowNormalize() {\n    float[] normalize = new float[expression.length];\n    float mean = mean();\n    float std = std(mean);\n    if (std == 0.0) {\n        for (int i = 0; i < expression.length; i++) normalize[i] = 0.0f;\n    } else {\n        for (int i = 0; i < expression.length; i++) normalize[i] = (expression[i] - mean) \/ std;\n    }\n    return normalize;\n}","78":"@Deprecated\npublic void filterGenesets() {\n    for (EMDataSet ds : dataSets.values()) {\n        Set<Integer> expressionGenes = ds.getExpressionGenes();\n        if (expressionGenes != null && !expressionGenes.isEmpty()) {\n            ds.getSetOfGeneSets().filterGeneSets(expressionGenes);\n        }\n    }\n}","79":"public Set<Integer> getAllEnrichmentGenes() {\n    Set<Integer> genes = new HashSet<>();\n    for (EMDataSet ds : getDataSetList()) {\n        Map<String, GeneSet> geneSets = ds.getGeneSetsOfInterest().getGeneSets();\n        for (GeneSet geneSet : geneSets.values()) {\n            genes.addAll(geneSet.getGenes());\n        }\n    }\n    return genes;\n}","80":"public static boolean checkFile(String filename) {\n    if (filename != null && !filename.trim().isEmpty()) {\n        File file = new File(filename.trim());\n        if (file.exists() && file.canRead())\n            return true;\n    }\n    return false;\n}","81":"public void registerEnrichmentMap(EnrichmentMap map) {\n    if (enrichmentMaps.containsKey(map.getNetworkID()))\n        return;\n    enrichmentMaps.put(map.getNetworkID(), map);\n    for (Long id : map.getAssociatedNetworkIDs()) associatedEnrichmentMaps.put(id, map);\n    eventHelper.fireEvent(new EnrichmentMapAddedEvent(this, map));\n}","82":"public synchronized double[] getScores() {\n    if (scores == null) {\n        Map<Integer, Double> gene2score = getGene2Score();\n        scores = new double[gene2score.size()];\n        int i = 0;\n        for (Double score : gene2score.values()) {\n            scores[i++] = score;\n        }\n    }\n    return scores;\n}","83":"public void restoreProps(String ds, Map<String, String> props) {\n    String simpleName = this.getClass().getSimpleName();\n    String val = props.get(ds + \"%\" + simpleName + \"%expressionUniverse\");\n    if (val != null) {\n        try {\n            expressionUniverse = Integer.parseInt(val);\n        } catch (NumberFormatException e) {\n        }\n    }\n}","84":"public static Component getWindowInstance(JPanel panel) {\n    Component parent = panel.getParent();\n    Component current = panel;\n    while (parent != null) {\n        if (parent instanceof JFrame || parent instanceof JDialog)\n            return parent;\n        current = parent;\n        parent = current.getParent();\n    }\n    return current;\n}","85":"public boolean setCurrentDirectory(File dir) {\n    if (dir == null || !dir.exists() || !dir.isDirectory())\n        return false;\n    final Properties props = (Properties) serviceRegistrar.getService(CyProperty.class, \"(cyPropertyName=cytoscape3.props)\").getProperties();\n    props.setProperty(FileUtil.LAST_DIRECTORY, dir.getAbsolutePath());\n    return true;\n}","86":"private int getMidpoint() {\n    int range = this.to - this.from + 1;\n    if (range % 2 == 1) {\n        range--;\n    }\n    int midpoint = range \/ 2 + this.from;\n    return midpoint;\n}","87":"public String toStringVerbose(int windowSize) throws InvalidGenomicCoordsException, IOException {\n    List<Double> mapping = seqFromToLenOut(this.getUserWindowSize());\n    String str = \"Genome coords: \" + from + \"-\" + to + \"; screen width: \" + mapping.size() + \"; scale: \" + this.getBpPerScreenColumn() + \" bp\/column\" + \"; Mapping: \" + mapping;\n    str += \"\\n\";\n    str += this.toString();\n    return str;\n}","88":"public static void updateCommandHelpMdFile(File destFile) throws InvalidCommandLineException, IOException, InvalidColourException {\n    BufferedWriter wr = new BufferedWriter(new FileWriter(destFile));\n    String doc = reStructuredTextHelp();\n    doc = doc.replaceAll(\"\\n*0: [\\\\s|\\\\S]+grey93\\033\\\\[38;5;0;48;5;231m\", \"`here <http:\/\/jonasjacek.github.io\/colors\/>`_ \");\n    wr.write(doc + \"\\n\");\n    wr.close();\n    System.err.println(\"Command help file written to \" + destFile.getAbsolutePath());\n}","89":"public static OutputStream uncloseableOutputStream(final OutputStream os) {\n    return new FilterOutputStream(os) {\n\n        @Override\n        public void close() throws IOException {\n            this.flush();\n            os.flush();\n        }\n    };\n}","90":"public List<FeatureChar> getIdeogram(boolean makeIt, boolean withName) throws InvalidColourException {\n    if (makeIt) {\n        this.makeIdeogram(false);\n    }\n    if (withName) {\n        this.addNameToIdeogram();\n    }\n    return this.ideogram;\n}","91":"private String positionToGffLine(GenomicCoords gc, String nameForBookmark) {\n    nameForBookmark = nameForBookmark.replaceAll(\"\\\"\", \"_\");\n    return gc.getChrom() + \"\\tASCIIGenome\\tbookmark\\t\" + gc.getFrom() + \"\\t\" + gc.getTo() + \"\\t.\\t.\\t.\\tID=\\\"\" + nameForBookmark + \"\\\"\";\n}","92":"private void setTextStart() throws InvalidGenomicCoordsException, IOException {\n    int alnStart;\n    if (this.showSoftClip) {\n        alnStart = this.getSoftUnclippedAlignmentStart(samRecord);\n    } else {\n        alnStart = samRecord.getAlignmentStart();\n    }\n    if (alnStart <= gc.getFrom()) {\n        this.textStart = 1;\n        return;\n    }\n    this.textStart = Utils.getIndexOfclosestValue(alnStart, gc.getMapping()) + 1;\n    return;\n}","93":"protected void addFormatGFF(char txt, char strand) {\n    this.setText(txt);\n    this.setFgColor(Config.get(ConfigKey.foreground));\n    if (strand == '+') {\n        this.setBgColor(Config.get(ConfigKey.feature_background_positive_strand));\n    } else if (strand == '-') {\n        this.setBgColor(Config.get(ConfigKey.feature_background_negative_strand));\n    } else {\n        this.setBgColor(Config.get(ConfigKey.feature_background_no_strand));\n    }\n}","94":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getReadNegativeStrandFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getReadNegativeStrandFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","95":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getFirstOfPairFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getFirstOfPairFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","96":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getReadPairedFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getReadPairedFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","97":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getMateUnmappedFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getMateUnmappedFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","98":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getProperPairFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getProperPairFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","99":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getReadFailsVendorQualityCheckFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getReadFailsVendorQualityCheckFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","100":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getDuplicateReadFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getDuplicateReadFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","101":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getSecondOfPairFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getSecondOfPairFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","102":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getSupplementaryAlignmentFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getSupplementaryAlignmentFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","103":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.isSecondaryAlignment()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.isSecondaryAlignment()) {\n            return false;\n        }\n    }\n    return true;\n}","104":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\npublic boolean filterOut(final SAMRecord record) {\n    if (include) {\n        if (record.getMateNegativeStrandFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude\n        if (!record.getMateNegativeStrandFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","105":"\/**\n * @param calls Genotypes for all pedigree members at all sites of the 'unit' being investigated (e.g., a gene, or a regulon).\n * @return Genotypes for all variants that are compatible with autosomal recessive compound heterozygous inheritance.\n *\/\n@Override\npublic ImmutableList<GenotypeCalls> filterCompatibleRecords(Collection<GenotypeCalls> calls) throws IncompatiblePedigreeException {\n    List<GenotypeCalls> autosomalCalls = calls.stream().filter(call -> call.getChromType() == ChromosomeType.AUTOSOMAL).collect(Collectors.toList());\n    if (pedigree.getNMembers() == 1)\n        return filterCompatibleRecordsSingleSample(autosomalCalls);\n    else\n        return filterCompatibleRecordsMultiSample(autosomalCalls);\n}","106":"ImmutableList<GenotypeCalls> filterCompatibleRecordsSingleSample(Collection<GenotypeCalls> calls) {\n    ImmutableList.Builder<GenotypeCalls> builder = new ImmutableList.Builder<>();\n    for (GenotypeCalls gc : calls) {\n        if (gc.getGenotypeBySampleNo(0).isHet())\n            builder.add(gc);\n    }\n    ImmutableList<GenotypeCalls> result = builder.build();\n    if (result.size() > 1)\n        return result;\n    else\n        return ImmutableList.of();\n}","107":"private boolean isCompatibleSingleton(GenotypeCalls calls) {\n    if (calls.getNSamples() == 0)\n        return false;\n    final Genotype gt = calls.getGenotypeBySampleNo(0);\n    if (pedigree.getMembers().get(0).getSex() == Sex.FEMALE) {\n        return calls.getGenotypeBySampleNo(0).isHet();\n    } else {\n        return (gt.isHet() || gt.isHomAlt());\n    }\n}","108":"private boolean isCompatibleSingleton(GenotypeCalls calls) {\n    if (calls.getNSamples() == 0)\n        return false;\n    if (calls.getGenotypeBySampleNo(0).isHomAlt())\n        return true;\n    else if (pedigree.getMembers().get(0).getSex() != Sex.FEMALE && calls.getGenotypeBySampleNo(0).isHet())\n        return true;\n    else\n        return false;\n}","109":"private boolean parentsAreCompatible(GenotypeCalls calls) {\n    final ImmutableSet<String> femaleParentNames = queryDecorator.getAffectedFemaleParentNames();\n    for (Person p : pedigree.getMembers()) {\n        final Genotype gt = calls.getGenotypeForSample(p.getName());\n        if (femaleParentNames.contains(p.getName())) {\n            if (p.getSex() == Sex.MALE && p.getDisease() == Disease.UNAFFECTED) {\n                return false;\n            }\n            if (p.getSex() == Sex.FEMALE && (gt.isHomAlt() || gt.isHomRef())) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","110":"private boolean calculateIsHomRef(boolean hasNoObservedCalls, int[] alleleNumbers) {\n    if (hasNoObservedCalls) {\n        return false;\n    }\n    for (int x : alleleNumbers) {\n        if (x != REF_CALL && x != NO_CALL) {\n            return false;\n        }\n    }\n    return true;\n}","111":"public ImmutableMap<SubModeOfInheritance, ImmutableList<GenotypeCalls>> checkMendelianInheritanceSub(Collection<GenotypeCalls> calls, Collection<GenotypeCalls> compHetRecessiveCalls) throws IncompatiblePedigreeException {\n    ImmutableMap.Builder<SubModeOfInheritance, ImmutableList<GenotypeCalls>> builder = new ImmutableMap.Builder<>();\n    for (SubModeOfInheritance mode : SubModeOfInheritance.values()) {\n        if (mode == SubModeOfInheritance.ANY) {\n            builder.put(mode, ImmutableList.copyOf(calls));\n        } else {\n            if (mode == SubModeOfInheritance.AUTOSOMAL_RECESSIVE_COMP_HET || mode == SubModeOfInheritance.X_RECESSIVE_COMP_HET) {\n                builder.put(mode, filterCompatibleRecordsSub(compHetRecessiveCalls, mode));\n            } else {\n                builder.put(mode, filterCompatibleRecordsSub(calls, mode));\n            }\n        }\n    }\n    return builder.build();\n}","112":"public boolean liesInIntron(GenomePosition pos) {\n    for (int i = 0; i + 1 < transcript.getExonRegions().size(); ++i) {\n        GenomeInterval intronRegion = transcript.intronRegion(i);\n        if (intronRegion.contains(pos))\n            return true;\n    }\n    return false;\n}","113":"public boolean liesInIntron(GenomeInterval interval) {\n    TranscriptProjectionDecorator projector = new TranscriptProjectionDecorator(transcript);\n    final int intronNo = projector.locateIntron(interval.getGenomeBeginPos());\n    if (intronNo == TranscriptProjectionDecorator.INVALID_INTRON_ID)\n        return false;\n    return !transcript.getExonRegions().get(intronNo + 1).contains(interval.getGenomeEndPos().shifted(-1));\n}","114":"public boolean liesInExon(GenomeInterval interval) {\n    TranscriptProjectionDecorator projector = new TranscriptProjectionDecorator(transcript);\n    final int exonNo = projector.locateExon(interval.getGenomeBeginPos());\n    if (exonNo == TranscriptProjectionDecorator.INVALID_EXON_ID)\n        return false;\n    return transcript.getExonRegions().get(exonNo).contains(interval);\n}","115":"public boolean liesInExon(GenomePosition pos) {\n    TranscriptProjectionDecorator projector = new TranscriptProjectionDecorator(transcript);\n    final int exonNo = projector.locateExon(pos);\n    if (exonNo == TranscriptProjectionDecorator.INVALID_EXON_ID)\n        return false;\n    return transcript.getExonRegions().get(exonNo).contains(pos);\n}","116":"\/**\n * @param ref       reference string for insertion\n * @param insertion the string to be inserted at <code>pos<\/code>\n * @param pos       the 0-based position in <code>ref<\/code> that <code>insertion<\/code> is to be inserted\n * @return <code>true<\/code> if the described insertion is a duplication\n *\/\npublic static boolean isDuplication(String ref, String insertion, int pos) {\n    if (pos + insertion.length() <= ref.length()) {\n        \/\/ can be duplication with string after pos\n        if (ref.substring(pos, pos + insertion.length()).equals(insertion))\n            return true;\n    }\n    if (pos >= insertion.length()) {\n        \/\/ can be duplication with string before pos\n        if (ref.substring(pos - insertion.length(), pos).equals(insertion))\n            return true;\n    }\n    return false;\n}","117":"\/**\n * @param pos {@link GenomePosition} with to translate into {@link NucleotidePointLocation}\n * @return {@link NucleotidePointLocation}, given the transcript in {@link #transcript}.\n *\/\npublic NucleotidePointLocation getNucleotidePointLocation(GenomePosition pos) {\n    \/\/ Guard against cases upstream\/downstream of transcription region.\n    if (\/\/ upstream of transcription region\n    transcript.getTXRegion().isRightOf(pos))\n        return getCDNANucleotidePointLocationForUpstreamPos(pos);\n    else if (\/\/ downstream of transcription region\n    transcript.getTXRegion().isLeftOf(pos))\n        return getCDNANucleotidePointLocationForDownstreamPos(pos);\n    \/\/ The main difference now is between intronic and exonic regions.\n    if (soDecorator.liesInExon(new GenomeInterval(pos, 0)))\n        return getCDNANucleotidePointLocationForExonPos(pos);\n    else\n        return getCDNANucleotidePointLocationForIntronPos(pos);\n}","118":"public static AminoAcidChange shiftSynonymousChange(AminoAcidChange change, String wtAASeq, String varAASeq) {\n    AminoAcidChange aminoAcidChange = truncateBothSides(change);\n    int position = aminoAcidChange.getPos();\n    int originalPosition = position;\n    int maxPosition = Math.min(wtAASeq.length() - aminoAcidChange.getRef().length(), varAASeq.length() - aminoAcidChange.getAlt().length());\n    while (position < maxPosition && wtAASeq.charAt(position) != '*' && wtAASeq.charAt(position) == varAASeq.charAt(position)) {\n        position++;\n    }\n    if (position == originalPosition) {\n        return aminoAcidChange;\n    }\n    return new AminoAcidChange(position, wtAASeq.substring(position, position + aminoAcidChange.getRef().length()), varAASeq.substring(position, position + aminoAcidChange.getAlt().length()));\n}","119":"public GenomeVariantType getType() {\n    if (ref.length() > 0 && alt.length() == 0)\n        return GenomeVariantType.DELETION;\n    else if (ref.length() == 0 && alt.length() > 0)\n        return GenomeVariantType.INSERTION;\n    else if (ref.length() == 1 && alt.length() == 1)\n        return GenomeVariantType.SNV;\n    else\n        return GenomeVariantType.BLOCK_SUBSTITUTION;\n}","120":"public GenomeInterval getGenomeInterval() {\n    if (genomePos.getChr() != genomePos2.getChr()) {\n        throw new IllegalArgumentException(\"Cannot compute genome interval if start chrom is not end chrom\");\n    } else if (genomePos.isLeq(genomePos2)) {\n        return new GenomeInterval(genomePos, genomePos2.differenceTo(genomePos));\n    } else {\n        return new GenomeInterval(genomePos2, genomePos.differenceTo(genomePos2));\n    }\n}","121":"public static GenomeVariant normalizeDeletion(TranscriptModel transcript, GenomeVariant change, TranscriptPosition txPos) {\n    assert (change.getRef().length() != 0 && change.getAlt().length() == 0);\n    if (change.getGenomePos().getStrand() != transcript.getStrand())\n        change = change.withStrand(transcript.getStrand());\n    int pos = txPos.getPos();\n    final int LEN = change.getRef().length();\n    final String seq = transcript.getTrimmedSequence();\n    int shift = 0;\n    while ((pos + LEN < seq.length()) && (seq.charAt(pos) == seq.charAt(pos + LEN))) {\n        ++shift;\n        ++pos;\n    }\n    if (shift == 0)\n        return change;\n    else\n        return new GenomeVariant(change.getGenomePos().shifted(shift), seq.substring(pos, pos + LEN), \"\");\n}","122":"\/**\n * Return modified transcript after applying a {@link GenomeVariant}.\n *\n * @param change {@link GenomeVariant} to apply to the transcript\n * @return transcript string with applied {@link GenomeVariant}\n *\/\npublic String getTranscriptWithChange(GenomeVariant change) {\n    change = change.withStrand(transcript.getStrand());\n    switch(change.getType()) {\n        case SNV:\n        case INSERTION:\n            return getTranscriptWithPointInRefAffected(change);\n        case DELETION:\n        case BLOCK_SUBSTITUTION:\n            return getTranscriptWithRangeInRefAffected(change);\n        default:\n            throw new Error(\"Unhandled change type \" + change.getType());\n    }\n}","123":"private TranscriptPosition translateGenomeToTranscriptPosition(GenomePosition pos) throws ProjectionException {\n    TranscriptProjectionDecorator projector = new TranscriptProjectionDecorator(transcript);\n    TranscriptSequenceOntologyDecorator soDecorator = new TranscriptSequenceOntologyDecorator(transcript);\n    if (transcript.getTXRegion().isRightOf(pos)) {\n        return new TranscriptPosition(transcript, 0, PositionType.ZERO_BASED);\n    } else if (transcript.getTXRegion().isLeftOf(pos)) {\n        return new TranscriptPosition(transcript, transcript.transcriptLength(), PositionType.ZERO_BASED);\n    } else if (soDecorator.liesInExon(pos)) {\n        return projector.genomeToTranscriptPos(pos);\n    } else {\n        int intronNum = projector.locateIntron(pos);\n        return projector.genomeToTranscriptPos(transcript.getExonRegions().get(intronNum).getGenomeBeginPos());\n    }\n}","124":"public GenomeInterval withStrand(Strand strand) {\n    if (this.strand == strand) {\n        return this;\n    }\n    Integer contigLength = refDict.getContigIDToLength().get(chr);\n    int bp = contigLength - beginPos;\n    int ep = contigLength - endPos;\n    return new GenomeInterval(refDict, strand, chr, ep, bp);\n}","125":"public GenomeInterval intersection(GenomeInterval other) {\n    if (chr != other.chr)\n        return new GenomeInterval(refDict, strand, chr, beginPos, beginPos, PositionType.ZERO_BASED);\n    other = other.withStrand(strand);\n    int beginPos = Math.max(this.beginPos, other.beginPos);\n    int endPos = Math.min(this.endPos, other.endPos);\n    if (endPos < beginPos)\n        beginPos = endPos;\n    return new GenomeInterval(refDict, strand, chr, beginPos, endPos, PositionType.ZERO_BASED);\n}","126":"public GenomeInterval union(GenomeInterval other) {\n    if (chr != other.chr)\n        return new GenomeInterval(refDict, strand, chr, beginPos, beginPos, PositionType.ZERO_BASED);\n    other = other.withStrand(strand);\n    int beginPos = Math.min(this.beginPos, other.beginPos);\n    int endPos = Math.max(this.endPos, other.endPos);\n    if (endPos < beginPos)\n        beginPos = endPos;\n    return new GenomeInterval(refDict, strand, chr, beginPos, endPos, PositionType.ZERO_BASED);\n}","127":"public String getCDSTranscript() {\n    try {\n        TranscriptPosition tBeginPos = genomeToTranscriptPos(transcript.getCDSRegion().getGenomeBeginPos());\n        TranscriptPosition tEndPos = genomeToTranscriptPos(transcript.getCDSRegion().getGenomeEndPos());\n        return transcript.getTrimmedSequence().substring(tBeginPos.getPos(), tEndPos.getPos());\n    } catch (ProjectionException e) {\n        throw new Error(\"Bug: CDS begin\/end must be translatable into transcript positions\");\n    }\n}","128":"public QueryResult findOverlappingWithPoint(int point) {\n    QueryResultBuilder resultBuilder = new QueryResultBuilder();\n    findOverlappingWithPoint(0, intervals.size(), intervals.size() \/ 2, point, resultBuilder);\n    QueryResult result = resultBuilder.build();\n    if (result.entries.size() > 0)\n        return result;\n    resultBuilder.left = findLeftNeighbor(point);\n    resultBuilder.right = findRightNeighbor(point);\n    return resultBuilder.build();\n}","129":"public final String getFileName(String key) throws InvalidDataSourceException {\n    String urlString = iniSection.fetch(key);\n    if (urlString == null || urlString.equals(\"\"))\n        throw new InvalidDataSourceException(\"Cannot retrieve URL for key \" + key);\n    URL url;\n    try {\n        url = new URL(urlString);\n    } catch (MalformedURLException e) {\n        throw new InvalidDataSourceException(\"Invalid download URL.\", e);\n    }\n    return new File(url.getPath()).getName();\n}","130":"private FileDownloader.Options buildOptions(boolean printProgressBars) {\n    FileDownloader.Options result = new FileDownloader.Options();\n    result.printProgressBar = printProgressBars;\n    updateProxyOptions(result.http, options.getHTTPProxy());\n    updateProxyOptions(result.https, options.getHTTPSProxy());\n    updateProxyOptions(result.ftp, options.getFTPProxy());\n    return result;\n}","131":"\/**\n * @return version string\n *\/\npublic static String getVersion() {\n    final Properties properties = new Properties();\n    try {\n        properties.load(JannovarDataSerializer.class.getResourceAsStream(\"\/project.properties\"));\n    } catch (IOException e) {\n        throw new UncheckedJannovarException(\"Could not load project.properties for obtaining version\", e);\n    }\n    return properties.getProperty(\"version\");\n}","132":"private static ImmutableMultimap<String, TranscriptModel> makeTMByGeneSymbol(ImmutableList<TranscriptModel> transcriptModels) {\n    ImmutableMultimap.Builder<String, TranscriptModel> builder = new ImmutableMultimap.Builder<String, TranscriptModel>();\n    for (TranscriptModel tm : transcriptModels) {\n        if (tm.getGeneSymbol() != null) {\n            builder.put(tm.getGeneSymbol(), tm);\n        }\n    }\n    return builder.build();\n}","133":"public void print(PrintStream out) {\n    out.println(\"contig ID mapping\");\n    for (Entry<String, Integer> entry : contigID.entrySet()) out.println(\"\\t\" + entry.getKey() + \" -> \" + entry.getValue());\n    out.println(\"contigs lengths\");\n    for (Entry<Integer, Integer> entry : contigLength.entrySet()) out.println(\"\\t\" + entry.getKey() + \" -> \" + entry.getValue());\n    out.println(\"contig name mapping\");\n    for (Entry<Integer, String> entry : contigName.entrySet()) out.println(\"\\t\" + entry.getKey() + \" -> \" + entry.getValue());\n}","134":"public String buildEffectText() {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(Joiner.on(\"+\").join(anno.getEffects()));\n    }\n    return builder.toString();\n}","135":"public String buildHGVSText(AminoAcidCode code) {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(anno.getSymbolAndAnnotation(code));\n    }\n    return builder.toString();\n}","136":"public PutativeImpact getPutativeImpact() {\n    if (effects.isEmpty())\n        return null;\n    VariantEffect worst = effects.iterator().next();\n    for (VariantEffect vt : effects) if (worst.getImpact().compareTo(vt.getImpact()) > 0)\n        worst = vt;\n    return worst.getImpact();\n}","137":"public String toVCFSVAnnoString(boolean escape) {\n    VCFSVAnnotationData data = new VCFSVAnnotationData();\n    data.effects = effects;\n    data.impact = getPutativeImpact();\n    data.setTranscriptAndVariant(transcript, variant);\n    data.isCoding = (transcript == null) ? false : transcript.isCoding();\n    data.messages = messages;\n    if (escape)\n        return data.toString();\n    else\n        return data.toUnescapedString();\n}","138":"public PutativeImpact getPutativeImpact() {\n    if (effects.isEmpty()) {\n        return PutativeImpact.MODIFIER;\n    } else {\n        VariantEffect worst = effects.iterator().next();\n        for (VariantEffect vt : effects) if (worst.getImpact().compareTo(vt.getImpact()) > 0)\n            worst = vt;\n        return worst.getImpact();\n    }\n}","139":"public String toVCFAnnoString(String alt, boolean escape, AminoAcidCode code) {\n    VCFAnnotationData data = new VCFAnnotationData();\n    data.effects = effects;\n    data.impact = getPutativeImpact();\n    data.setTranscriptAndChange(transcript, change);\n    data.setAnnoLoc(annoLoc);\n    data.isCoding = (transcript == null) ? false : transcript.isCoding();\n    data.cdsNTChange = cdsNTChange;\n    data.proteinChange = proteinChange;\n    data.messages = messages;\n    if (escape)\n        return data.toString(alt, code);\n    else\n        return data.toUnescapedString(alt, code);\n}","140":"public VariantEffect getHighestImpactEffect() {\n    final ImmutableMap<String, SVAnnotation> anno = getHighestImpactAnnotation();\n    if (anno == null || anno.isEmpty() || anno.entrySet().iterator().next().getValue().getEffects().isEmpty()) {\n        return VariantEffect.SEQUENCE_VARIANT;\n    } else {\n        VariantEffect result = null;\n        for (SVAnnotation svAnno : anno.values()) {\n            final VariantEffect candidate = svAnno.getMostPathogenicVariantEffect();\n            if (candidate.compareTo(result) < 0) {\n                result = candidate;\n            }\n        }\n        return result;\n    }\n}","141":"private NucleotideRange buildNTChangeRange(TranscriptModel transcript, GenomeVariant change) {\n    NucleotidePointLocationBuilder posBuilder = new NucleotidePointLocationBuilder(transcript);\n    GenomePosition firstChangePos = change.getGenomeInterval().getGenomeBeginPos();\n    GenomePosition lastChangePos = change.getGenomeInterval().getGenomeEndPos().shifted(-1);\n    if (change.getGenomeInterval().length() == 0)\n        return new NucleotideRange(posBuilder.getNucleotidePointLocation(lastChangePos), posBuilder.getNucleotidePointLocation(firstChangePos));\n    else\n        return new NucleotideRange(posBuilder.getNucleotidePointLocation(firstChangePos), posBuilder.getNucleotidePointLocation(lastChangePos));\n}","142":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    return Sets.immutableEnumSet(tmpEffects);\n}","143":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    return Sets.immutableEnumSet(tmpEffects);\n}","144":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    return Sets.immutableEnumSet(tmpEffects);\n}","145":"private SVAnnotation buildExonOverlapAnnotation(GenomeInterval changeInterval) {\n    if (so.overlapsWithCDS(changeInterval)) {\n        return buildAnnotation(VariantEffect.CODING_SEQUENCE_VARIANT);\n    } else if (so.overlapsWithFivePrimeUTR(changeInterval)) {\n        return buildAnnotation(VariantEffect.FIVE_PRIME_UTR_EXON_VARIANT);\n    } else {\n        return buildAnnotation(VariantEffect.THREE_PRIME_UTR_EXON_VARIANT);\n    }\n}","146":"private SVAnnotation buildIntronAnnotation(GenomeInterval changeInterval) {\n    final EnumSet<VariantEffect> effects = EnumSet.noneOf(VariantEffect.class);\n    if (so.overlapsWithCDS(changeInterval)) {\n        return buildAnnotation(VariantEffect.INTRON_VARIANT);\n    } else if (so.overlapsWithFivePrimeUTR(changeInterval)) {\n        return buildAnnotation(VariantEffect.FIVE_PRIME_UTR_INTRON_VARIANT);\n    } else {\n        return buildAnnotation(VariantEffect.THREE_PRIME_UTR_INTRON_VARIANT);\n    }\n}","147":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    tmpEffects.add(VariantEffect.TRANSLOCATION);\n    tmpEffects.add(VariantEffect.STRUCTURAL_VARIANT);\n    return Sets.immutableEnumSet(tmpEffects);\n}","148":"private EnumSet<VariantEffect> computeVariantTypes(String wtAA, String varAA) {\n    EnumSet<VariantEffect> result = EnumSet.noneOf(VariantEffect.class);\n    if (wtAA.equals(varAA))\n        result.add(VariantEffect.SYNONYMOUS_VARIANT);\n    else if (wtAA.equals(\"*\"))\n        result.add(VariantEffect.STOP_LOST);\n    else if (varAA.equals(\"*\"))\n        result.add(VariantEffect.STOP_GAINED);\n    else\n        result.add(VariantEffect.MISSENSE_VARIANT);\n    return result;\n}","149":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    return Sets.immutableEnumSet(tmpEffects);\n}","150":"private SVAnnotation buildExonOverlapAnnotation(GenomeInterval changeInterval) {\n    if (so.overlapsWithCDS(changeInterval)) {\n        return buildAnnotation(VariantEffect.CODING_SEQUENCE_VARIANT);\n    } else if (so.overlapsWithFivePrimeUTR(changeInterval)) {\n        return buildAnnotation(VariantEffect.FIVE_PRIME_UTR_EXON_VARIANT);\n    } else {\n        return buildAnnotation(VariantEffect.THREE_PRIME_UTR_EXON_VARIANT);\n    }\n}","151":"private SVAnnotation buildIntronAnnotation(GenomeInterval changeInterval) {\n    final EnumSet<VariantEffect> effects = EnumSet.noneOf(VariantEffect.class);\n    if (so.overlapsWithCDS(changeInterval)) {\n        return buildAnnotation(VariantEffect.INTRON_VARIANT);\n    } else if (so.overlapsWithFivePrimeUTR(changeInterval)) {\n        return buildAnnotation(VariantEffect.FIVE_PRIME_UTR_INTRON_VARIANT);\n    } else {\n        return buildAnnotation(VariantEffect.THREE_PRIME_UTR_INTRON_VARIANT);\n    }\n}","152":"private ImmutableSet<VariantEffect> buildEffectSet(Collection<VariantEffect> effects) {\n    final EnumSet<VariantEffect> tmpEffects;\n    if (transcript.isCoding()) {\n        tmpEffects = EnumSet.of(VariantEffect.CODING_TRANSCRIPT_VARIANT);\n    } else {\n        tmpEffects = EnumSet.of(VariantEffect.NON_CODING_TRANSCRIPT_VARIANT);\n    }\n    tmpEffects.addAll(effects);\n    return Sets.immutableEnumSet(tmpEffects);\n}","153":"public ImmutableSet<String> getParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.getFather() != null)\n            parentNames.add(member.getFather().getName());\n        if (member.getMother() != null)\n            parentNames.add(member.getMother().getName());\n    }\n    return parentNames.build();\n}","154":"public ImmutableSet<String> getAffectedFemaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isFemale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","155":"public ImmutableSet<String> getAffectedMaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isMale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","156":"public ImmutableList<Person> getParents() {\n    ImmutableSet<String> parentNames = getParentNames();\n    ImmutableList.Builder<Person> builder = new ImmutableList.Builder<Person>();\n    for (Person member : pedigree.getMembers()) if (parentNames.contains(member.getName()))\n        builder.add(member);\n    return builder.build();\n}","157":"public int getNumberOfParents() {\n    HashSet<String> parentNames = new HashSet<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.getFather() != null)\n            parentNames.add(member.getFather().getName());\n        if (member.getMother() != null)\n            parentNames.add(member.getMother().getName());\n    }\n    return parentNames.size();\n}","158":"public Pedigree subsetOfMembers(Collection<String> names) {\n    HashSet<String> nameSet = new HashSet<String>();\n    nameSet.addAll(names);\n    ArrayList<Person> tmpMembers = new ArrayList<Person>();\n    for (String name : names) if (hasPerson(name)) {\n        Person p = nameToMember.get(name).getPerson();\n        Person father = nameSet.contains(p.getFather().getName()) ? p.getFather() : null;\n        Person mother = nameSet.contains(p.getMother().getName()) ? p.getMother() : null;\n        tmpMembers.add(new Person(p.getName(), father, mother, p.getSex(), p.getDisease(), p.getExtraFields()));\n    }\n    return new Pedigree(name, tmpMembers);\n}","159":"private static ImmutableList<String> parseHeader(String line) {\n    ImmutableList.Builder<String> extraHeaderBuilder = new ImmutableList.Builder<String>();\n    Iterator<String> it = Splitter.on('\\t').split(line.trim().substring(1)).iterator();\n    for (int i = 0; it.hasNext(); ++i) if (i < 6)\n        it.next();\n    else\n        extraHeaderBuilder.add(it.next());\n    return extraHeaderBuilder.build();\n}","160":"public static void write(PedFileContents contents, OutputStream stream) throws IOException {\n    PrintWriter out = new PrintWriter(stream);\n    out.append(\"#PEDIGREE\\tNAME\\tFATHER\\tMOTHER\\tSEX\\tDISEASE\");\n    for (String header : contents.getExtraColumnHeaders()) {\n        out.append('\\t');\n        out.append(header);\n    }\n    out.append('\\n');\n    for (PedPerson individual : contents.getIndividuals()) writeIndividual(individual, out);\n    out.close();\n}","161":"static private String formatAsHHMMSS(long secs) {\n    final long hours = secs \/ 3600, remainder = secs % 3600, minutes = remainder \/ 60, seconds = remainder % 60;\n    return ((hours < 10 ? \"0\" : \"\") + hours + \":\" + (minutes < 10 ? \"0\" : \"\") + minutes + \":\" + (seconds < 10 ? \"0\" : \"\") + seconds);\n}","162":"@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + confidence;\n    result = prime * result + ((entity == null) ? 0 : entity.hashCode());\n    result = prime * result + geneID;\n    result = prime * result + ((location == null) ? 0 : location.hashCode());\n    result = prime * result + pmid;\n    result = prime * result + species;\n    return result;\n}","163":"public static void init(DatabaseConnection connection, String geneTable, String gene2Pubmed) throws SQLException {\n    if (geneTable != null && !geneTable.equals(\"\")) {\n        Gene.geneQuery = connection.getConn().prepareStatement(\"SELECT * \" + \"FROM \" + geneTable + \" WHERE pmid = ? AND species = 9606\");\n    } else\n        Gene.geneQuery = null;\n    if (gene2Pubmed != null && !gene2Pubmed.equals(\"\"))\n        Gene.gene2pubmedQuery = connection.getConn().prepareStatement(\"SELECT geneId, pmid FROM \" + gene2Pubmed + \" WHERE pmid = ? AND taxId = 9606\");\n    else\n        Gene.gene2pubmedQuery = null;\n    if (Gene.geneQuery == null && Gene.gene2pubmedQuery == null)\n        throw new IllegalStateException(\"At least one gene Source has to be specified\");\n}","164":"\/**\n * Initializes prepared statements to retrieve UniProt features,\n * like signaling peptide information\n * @param mysql    mySQL database\n * @param uniProt_Table Table name\n * @throws SQLException SQL-Exception accessing the database\n *\/\npublic static void init(DatabaseConnection mysql, String uniProt_Table) throws SQLException {\n    if (UniprotFeature.conn != null)\n        throw new IllegalStateException(\"ALREADY INITIALIZED\");\n    UniprotFeature.conn = mysql;\n    UniprotFeature.uniprotQuery = UniprotFeature.conn.getConn().prepareStatement(\"SELECT entrez, modification, location\" + \" FROM  \" + uniProt_Table + \" WHERE entrez = ? \");\n}","165":"@Override\npublic String toString() {\n    return \"dbSNPNormalized [\" + \"rsID=\" + rsID + \" ,GeneID \" + geneID + \", residues=\" + residues + \", wildtype=\" + wildtype + \" ,aaPosition=\" + aaPosition + \" ,matchType=\" + matchType + \" ,feature=\" + feature + \"]\";\n}","166":"\/**\n * (non-Javadoc)\n * @see java.lang.Object#hashCode()\n *\/\n@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((location == null) ? 0 : location.hashCode());\n    result = prime * result + ((mutation == null) ? 0 : mutation.hashCode());\n    result = prime * result + type;\n    result = prime * result + ((wildtype == null) ? 0 : wildtype.hashCode());\n    return result;\n}","167":"@Override\npublic String toString() {\n    if (type == 'c' || type == 'g') {\n        if (insdeldup)\n            return type + \".\" + location + wildtype + mutation;\n        else\n            return type + \".\" + location + wildtype + \">\" + mutation;\n    } else\n        return type + \".\" + wildtype + location + mutation;\n}","168":"public void closeQuery() {\n    try {\n        rs.close();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    try {\n        stmt.close();\n    } catch (SQLException e) {\n        throw new IllegalStateException(e);\n    }\n}","169":"@Override\npublic int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + aaPosition;\n    result = prime * result + geneID;\n    result = prime * result + ((hgvs == null) ? 0 : hgvs.hashCode());\n    result = prime * result + ((residues == null) ? 0 : residues.hashCode());\n    result = prime * result + rsID;\n    return result;\n}","170":"\/**\n * Takes as input a string of length one and returns the three letter code for it\n * @param residue  String of length 1, representing a one letter amino-acid code\n * @return three letter representation or NULL if invalid\n *\/\npublic static String getThreeLetter(String residue) {\n    assert (residue.length() == 1);\n    assert (oneToThreeLookupMap != null);\n    if (oneToThreeLookupMap.containsKey(residue)) {\n        return toCorrectCase(oneToThreeLookupMap.get(residue));\n    } else\n        return null;\n}","171":"private static List<dbSNPNormalized> cleanResults(List<dbSNPNormalized> snpList) {\n    Collections.sort(snpList);\n    int value = snpList.size() > 0 ? snpList.get(0).getConfidence() : Integer.MIN_VALUE;\n    List<dbSNPNormalized> topResult = new ArrayList<dbSNPNormalized>();\n    Set<Integer> seen = new HashSet<Integer>();\n    for (dbSNPNormalized snp : snpList) {\n        if (value == snp.getConfidence() && !seen.contains(snp.getRsID())) {\n            topResult.add(snp);\n            seen.add(snp.getRsID());\n        }\n    }\n    return topResult;\n}","172":"private UniprotFeature normalizePSMVariableOffset(dbSNP candidate, List<UniprotFeature> features) {\n    for (UniprotFeature feature : features) {\n        if (feature.getGeneId() != candidate.getGeneID())\n            continue;\n        if (Integer.toString(candidate.getAaPosition() - feature.getEndLoc() + feature.getStartLoc() - 1).equals(position))\n            return feature;\n    }\n    return null;\n}","173":"private boolean normalizePSMSimpleHGVS(dbSNP candidate) {\n    for (HGVS hgvs : candidate.getHgvs()) {\n        if (hgvs.getMutation() == null || hgvs.getWildtype() == null || hgvs.getLocation() == null)\n            continue;\n        if (hgvs.getType() != 'p')\n            continue;\n        if (hgvs.getLocation().equals(position) == false)\n            continue;\n        if (wtResidue.equals(hgvs.getWildtype()) == true && mutResidue.equals(hgvs.getMutation()))\n            return true;\n    }\n    return false;\n}","174":"private boolean normalizePSMSimpleHGVSSwap(dbSNP candidate) {\n    for (HGVS hgvs : candidate.getHgvs()) {\n        if (hgvs.getMutation() == null || hgvs.getWildtype() == null || hgvs.getLocation() == null)\n            continue;\n        if (hgvs.getType() != 'p')\n            continue;\n        if (hgvs.getLocation().equals(position) == false)\n            continue;\n        if (wtResidue.equals(hgvs.getMutation()) == true && mutResidue.equals(hgvs.getWildtype()))\n            return true;\n    }\n    return false;\n}","175":"\/**\n * Checks if the PSM object is valid.\n * It has to contain a entrez-gene Id, location, and a wildtype, and a mutation\n * Not given for SPNs like rs9341281\n * @return  true if SNP is valid\n *\/\npublic boolean isValid() {\n    if (entrez < 0)\n        return false;\n    if (aaLoc < 0)\n        return false;\n    if (wildtype == null)\n        return false;\n    if (mutations == null || mutations.size() == 0)\n        return false;\n    return true;\n}","176":"@Override\npublic boolean equals(Object obj) {\n    if (obj instanceof PointMutation) {\n        PointMutation pm = (PointMutation) obj;\n        return (this.getPosition().equals(pm.getPosition()) && this.getWtResidue() == pm.getWtResidue() && this.getMutResidue() == pm.getMutResidue());\n    } else {\n        error(\"Invalid comparision. Trying to compare a PointMutation with: \" + obj.getClass().getName());\n        return false;\n    }\n}","177":"private MutationMention convert(seth.ner.Mutation mutation) {\n    return new MutationMention(mutation.start(), mutation.end(), mutation.text(), mutation.ref(), mutation.loc(), mutation.wild(), mutation.mutated(), mutation.typ(), MutationMention.Tool.SETH);\n}","178":"@Override\npublic double cumulativeProbability(double x) throws MathException {\n    try {\n        return 0.5 * (1.0 + Erf.erf((x - mean) \/ (standardDeviation * Math.sqrt(2.0))));\n    } catch (MaxIterationsExceededException ex) {\n        if (x < (mean - 20 * standardDeviation)) {\n            return 0.0d;\n        } else if (x > (mean + 20 * standardDeviation)) {\n            return 1.0d;\n        } else {\n            throw ex;\n        }\n    }\n}","179":"@Override\nprotected double getInitialDomain(double p) {\n    double ret;\n    if (p < .5) {\n        ret = mean - standardDeviation;\n    } else if (p > .5) {\n        ret = mean + standardDeviation;\n    } else {\n        ret = mean;\n    }\n    return ret;\n}","180":"\/**\n * Compute the error of Stirling's series at the given value.\n * <p>\n * References:\n * <ol>\n * <li>Eric W. Weisstein. \"Stirling's Series.\" From MathWorld--A Wolfram Web\n * Resource. <a target=\"_blank\"\n * href=\"http:\/\/mathworld.wolfram.com\/StirlingsSeries.html\">\n * http:\/\/mathworld.wolfram.com\/StirlingsSeries.html<\/a><\/li>\n * <\/ol>\n * <\/p>\n *\n * @param z the value.\n * @return the Striling's series error.\n *\/\nstatic double getStirlingError(double z) {\n    double ret;\n    if (z < 15.0) {\n        double z2 = 2.0 * z;\n        if (Math.floor(z2) == z2) {\n            ret = EXACT_STIRLING_ERRORS[(int) z2];\n        } else {\n            ret = Gamma.logGamma(z + 1.0) - (z + 0.5) * Math.log(z) + z - HALF_LOG_2_PI;\n        }\n    } else {\n        double z2 = z * z;\n        ret = (0.083333333333333333333 - (0.00277777777777777777778 - (0.00079365079365079365079365 - (0.000595238095238095238095238 - 0.0008417508417508417508417508 \/ z2) \/ z2) \/ z2) \/ z2) \/ z;\n    }\n    return ret;\n}","181":"static double getDeviancePart(double x, double mu) {\n    double ret;\n    if (Math.abs(x - mu) < 0.1 * (x + mu)) {\n        double d = x - mu;\n        double v = d \/ (x + mu);\n        double s1 = v * d;\n        double s = Double.NaN;\n        double ej = 2.0 * x * v;\n        v = v * v;\n        int j = 1;\n        while (s1 != s) {\n            s = s1;\n            ej *= v;\n            s1 = s + ej \/ ((j * 2) + 1);\n            ++j;\n        }\n        ret = s1;\n    } else {\n        ret = x * Math.log(x \/ mu) + mu - x;\n    }\n    return ret;\n}","182":"@Override\nprotected double getInitialDomain(double p) {\n    if (p < .5) {\n        return mean * .5;\n    } else {\n        return mean;\n    }\n}","183":"@Override\npublic double probability(int x) {\n    double ret;\n    if (x < 0) {\n        ret = 0.0;\n    } else {\n        ret = MathUtils.binomialCoefficientDouble(x + numberOfSuccesses - 1, numberOfSuccesses - 1) * Math.pow(probabilityOfSuccess, numberOfSuccesses) * Math.pow(1.0 - probabilityOfSuccess, x);\n    }\n    return ret;\n}","184":"@Override\npublic double probability(int x) {\n    double ret;\n    if (x < 0 || x == Integer.MAX_VALUE) {\n        ret = 0.0;\n    } else if (x == 0) {\n        ret = Math.exp(-mean);\n    } else {\n        ret = Math.exp(-SaddlePointExpansion.getStirlingError(x) - SaddlePointExpansion.getDeviancePart(x, mean)) \/ Math.sqrt(MathUtils.TWO_PI * x);\n    }\n    return ret;\n}","185":"public double upperCumulativeProbability(int x) {\n    double ret;\n    final int[] domain = getDomain(populationSize, numberOfSuccesses, sampleSize);\n    if (x < domain[0]) {\n        ret = 1.0;\n    } else if (x > domain[1]) {\n        ret = 0.0;\n    } else {\n        ret = innerCumulativeProbability(domain[1], x, -1, populationSize, numberOfSuccesses, sampleSize);\n    }\n    return ret;\n}","186":"@Override\npublic double probability(int x) {\n    double ret;\n    if (x < 0 || x > numberOfTrials) {\n        ret = 0.0;\n    } else {\n        ret = Math.exp(SaddlePointExpansion.logBinomialProbability(x, numberOfTrials, probabilityOfSuccess, 1.0 - probabilityOfSuccess));\n    }\n    return ret;\n}","187":"@Override\nprotected double getInitialDomain(double p) {\n    double ret;\n    if (p < .5) {\n        ret = median - scale;\n    } else if (p > .5) {\n        ret = median + scale;\n    } else {\n        ret = median;\n    }\n    return ret;\n}","188":"@Override\nprotected double getDomainUpperBound(double p) {\n    double ret;\n    if (p < .5) {\n        ret = getDegreesOfFreedom();\n    } else {\n        ret = Double.MAX_VALUE;\n    }\n    return ret;\n}","189":"@Override\nprotected double getInitialDomain(double p) {\n    double ret;\n    if (p < .5) {\n        ret = getDegreesOfFreedom() * .5;\n    } else {\n        ret = getDegreesOfFreedom();\n    }\n    return ret;\n}","190":"@Override\nprotected double getDomainUpperBound(double p) {\n    double ret;\n    if (p < .5) {\n        ret = alpha * beta;\n    } else {\n        ret = Double.MAX_VALUE;\n    }\n    return ret;\n}","191":"@Override\nprotected double getInitialDomain(double p) {\n    double ret;\n    if (p < .5) {\n        ret = alpha * beta * .5;\n    } else {\n        ret = alpha * beta;\n    }\n    return ret;\n}","192":"@Override\npublic double inverseCumulativeProbability(double p) throws MathException {\n    if (p == 0) {\n        return 0;\n    } else if (p == 1) {\n        return 1;\n    } else {\n        return super.inverseCumulativeProbability(p);\n    }\n}","193":"@Override\npublic double cumulativeProbability(double x) throws MathException {\n    if (x <= 0) {\n        return 0;\n    } else if (x >= 1) {\n        return 1;\n    } else {\n        return Beta.regularizedBeta(x, alpha, beta);\n    }\n}","194":"private static void checkBinomial(final int n, final int k) throws IllegalArgumentException {\n    if (n < k) {\n        throw MathRuntimeException.createIllegalArgumentException(\"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\", n, k);\n    }\n    if (n < 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\"must have n >= 0 for binomial coefficient (n,k), got n = {0}\", n);\n    }\n}","195":"public static double scalb(final double d, final int scaleFactor) {\n    if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n        return d;\n    }\n    final long bits = Double.doubleToLongBits(d);\n    final long exponent = bits & 0x7ff0000000000000L;\n    final long rest = bits & 0x800fffffffffffffL;\n    final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n    return Double.longBitsToDouble(newBits);\n}","196":"@Override\nprotected void verifyIterationCount() throws IllegalArgumentException {\n    super.verifyIterationCount();\n    if (maximalIterationCount > 64) {\n        throw MathRuntimeException.createIllegalArgumentException(\"invalid iteration limits: min={0}, max={1}\", 0, 64);\n    }\n}","197":"@Override\nprotected void verifyIterationCount() throws IllegalArgumentException {\n    super.verifyIterationCount();\n    if (maximalIterationCount > 32) {\n        throw MathRuntimeException.createIllegalArgumentException(\"invalid iteration limits: min={0}, max={1}\", 0, 32);\n    }\n}","198":"@Override\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (f.value(min) == 0.0) {\n        return min;\n    }\n    if (f.value(max) == 0.0) {\n        return max;\n    }\n    if (f.value(initial) == 0.0) {\n        return initial;\n    }\n    verifyBracketing(min, max, f);\n    verifySequence(min, initial, max);\n    if (isBracketing(min, initial, f)) {\n        return solve(f, min, initial);\n    } else {\n        return solve(f, initial, max);\n    }\n}","199":"@Override\npublic double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException {\n    if (f.value(min) == 0.0) {\n        return min;\n    }\n    if (f.value(max) == 0.0) {\n        return max;\n    }\n    if (f.value(initial) == 0.0) {\n        return initial;\n    }\n    verifyBracketing(min, max, f);\n    verifySequence(min, initial, max);\n    if (isBracketing(min, initial, f)) {\n        return solve(f, min, initial);\n    } else {\n        return solve(f, initial, max);\n    }\n}","200":"public static double trigamma(double x) {\n    if (x > 0 && x <= S_LIMIT) {\n        return 1 \/ (x * x);\n    }\n    if (x >= C_LIMIT) {\n        double inv = 1 \/ (x * x);\n        return 1 \/ x + inv \/ 2 + inv \/ x * (1.0 \/ 6 - inv * (1.0 \/ 30 + inv \/ 42));\n    }\n    return trigamma(x + 1) + 1 \/ (x * x);\n}","201":"private String nextToInternal(String excluded) {\n    int start = pos;\n    for (; pos < in.length(); pos++) {\n        char c = in.charAt(pos);\n        if (c == '\\r' || c == '\\n' || excluded.indexOf(c) != -1) {\n            return in.substring(start, pos);\n        }\n    }\n    return in.substring(start);\n}","202":"JSONStringer close(Scope empty, Scope nonempty, String closeBracket) throws JSONException {\n    Scope context = peek();\n    if (context != nonempty && context != empty) {\n        throw new JSONException(\"Nesting problem\");\n    }\n    stack.remove(stack.size() - 1);\n    if (context == nonempty) {\n        newline();\n    }\n    out.append(closeBracket);\n    return this;\n}","203":"private void beforeKey() throws JSONException {\n    Scope context = peek();\n    if (context == Scope.NONEMPTY_OBJECT) {\n        out.append(',');\n    } else if (context != Scope.EMPTY_OBJECT) {\n        throw new JSONException(\"Nesting problem\");\n    }\n    newline();\n    replaceTop(Scope.DANGLING_KEY);\n}","204":"public JSONObject append(String name, Object value) throws JSONException {\n    Object current = nameValuePairs.get(checkName(name));\n    final JSONArray array;\n    if (current instanceof JSONArray) {\n        array = (JSONArray) current;\n    } else if (current == null) {\n        JSONArray newArray = new JSONArray();\n        nameValuePairs.put(name, newArray);\n        array = newArray;\n    } else {\n        throw new JSONException(\"Key \" + name + \" is not a JSONArray\");\n    }\n    array.checkedPut(value);\n    return this;\n}","205":"public static String quote(String data) {\n    if (data == null) {\n        return \"\\\"\\\"\";\n    }\n    try {\n        JSONStringer stringer = new JSONStringer();\n        stringer.open(JSONStringer.Scope.NULL, \"\");\n        stringer.value(data);\n        stringer.close(JSONStringer.Scope.NULL, JSONStringer.Scope.NULL, \"\");\n        return stringer.toString();\n    } catch (JSONException e) {\n        throw new AssertionError();\n    }\n}","206":"public double[] getFreqs() {\n    synchronized (this) {\n        if (needsUpdate) {\n            update();\n        }\n    }\n    return freqs.clone();\n}","207":"@Override\nprotected boolean requiresRecalculation() {\n    boolean recalculates = false;\n    if (frequenciesInput.get().somethingIsDirty()) {\n        needsUpdate = true;\n        recalculates = true;\n    }\n    return recalculates;\n}","208":"@Override\npublic void store() {\n    storedUpdateMatrix = updateMatrix;\n    if (eigenDecomposition != null) {\n        storedEigenDecomposition = eigenDecomposition.copy();\n    }\n    super.store();\n}","209":"\/**\n * constructor taking a pattern source\n *\n * @param patterns a pattern of a microsatellite locus\n *\/\n@Override\npublic double pairwiseDistance(int taxon1, int taxon2) {\n    int[] pattern = patterns.getPattern(0);\n    int state1 = pattern[taxon1];\n    int state2 = pattern[taxon2];\n    double distance = 0.0;\n    if (!dataType.isAmbiguousCode(state1) && !dataType.isAmbiguousCode(state2))\n        distance = Math.abs(state1 - state2);\n    return distance;\n}","210":"\/**\n * set the pattern source\n *\/\n@Override\npublic void setPatterns(Alignment patterns) {\n    super.setPatterns(patterns);\n    final int stateCount = dataType.getStateCount();\n    const1 = ((double) stateCount - 1) \/ stateCount;\n    const2 = ((double) stateCount) \/ (stateCount - 1);\n}","211":"@Override\npublic void calculateLogLikelihoods(double[] partials, double[] frequencies, double[] outLogLikelihoods) {\n    int v = 0;\n    for (int k = 0; k < nrOfPatterns; k++) {\n        double sum = 0.0;\n        for (int i = 0; i < nrOfStates; i++) {\n            sum += frequencies[i] * partials[v];\n            v++;\n        }\n        outLogLikelihoods[k] = Math.log(sum) + getLogScalingFactor(k);\n    }\n}","212":"public void setCurrentNodePartials(int nodeIndex, double[] partials) {\n    if (partials.length < partialsSize) {\n        int k = 0;\n        for (int i = 0; i < nrOfMatrices; i++) {\n            System.arraycopy(partials, 0, this.partials[currentPartialsIndex[nodeIndex]][nodeIndex], k, partials.length);\n            k += partials.length;\n        }\n    } else {\n        System.arraycopy(partials, 0, this.partials[currentPartialsIndex[nodeIndex]][nodeIndex], 0, partials.length);\n    }\n}","213":"@Override\npublic double getLogScalingFactor(int patternIndex_) {\n    double logScalingFactor = 0.0;\n    if (useScaling) {\n        for (int i = 0; i < nrOfNodes; i++) {\n            logScalingFactor += scalingFactors[currentPartialsIndex[i]][i][patternIndex_];\n        }\n    }\n    return logScalingFactor;\n}","214":"@Override\npublic void restore() {\n    int[] tmp1 = currentMatrixIndex;\n    currentMatrixIndex = storedMatrixIndex;\n    storedMatrixIndex = tmp1;\n    int[] tmp2 = currentPartialsIndex;\n    currentPartialsIndex = storedPartialsIndex;\n    storedPartialsIndex = tmp2;\n}","215":"public void setCurrentNodePartials(int iNodeIndex, double[] fPartials) {\n    if (fPartials.length < m_nPartialsSize) {\n        int k = 0;\n        for (int i = 0; i < m_nMatrices; i++) {\n            System.arraycopy(fPartials, 0, this.m_fPartials[m_iCurrentPartials[iNodeIndex]][iNodeIndex], k, fPartials.length);\n            k += fPartials.length;\n        }\n    } else {\n        System.arraycopy(fPartials, 0, this.m_fPartials[m_iCurrentPartials[iNodeIndex]][iNodeIndex], 0, fPartials.length);\n    }\n}","216":"public double getLogScalingFactor(int iPattern) {\n    double logScalingFactor = 0.0;\n    if (m_bUseScaling) {\n        for (int i = 0; i < m_nNodes; i++) {\n            logScalingFactor += m_fScalingFactors[m_iCurrentPartials[i]][i][iPattern];\n        }\n    }\n    return logScalingFactor;\n}","217":"@Override\npublic void restore() {\n    int[] iTmp1 = m_iCurrentMatrices;\n    m_iCurrentMatrices = m_iStoredMatrices;\n    m_iStoredMatrices = iTmp1;\n    int[] iTmp2 = m_iCurrentPartials;\n    m_iCurrentPartials = m_iStoredPartials;\n    m_iStoredPartials = iTmp2;\n}","218":"default Node[] listNodesPostOrder(Node node, Node[] nodes) {\n    if (node == null) {\n        node = getRoot();\n    }\n    if (nodes == null) {\n        final int n = node == getRoot() ? getNodeCount() : node.getNodeCount();\n        nodes = new Node[n];\n    }\n    getNodesPostOrder(node, nodes, 0);\n    return nodes;\n}","219":"@Override\npublic double calculateLogP() {\n    logP = calculateLogLikelihood(intervals, popSizeInput.get());\n    if (Double.isInfinite(logP)) {\n        logP = Double.NEGATIVE_INFINITY;\n    }\n    return logP;\n}","220":"@Override\npublic double getIntegral(double start, double finish) {\n    double r = getGrowthRate();\n    if (r == 0.0) {\n        return (finish - start) \/ getN0();\n    } else {\n        return (Math.exp(finish * r) - Math.exp(start * r)) \/ getN0() \/ r;\n    }\n}","221":"public void setMetaData(final String pattern, final Object value) {\n    startEditing();\n    if (pattern.equals(TraitSet.DATE_TRAIT) || pattern.equals(TraitSet.AGE_TRAIT) || pattern.equals(TraitSet.DATE_FORWARD_TRAIT) || pattern.equals(TraitSet.DATE_BACKWARD_TRAIT)) {\n        height = (Double) value;\n        isDirty |= Tree.IS_DIRTY;\n    } else {\n        metaData.put(pattern, value);\n    }\n}","222":"public Node getNonDirectAncestorChild() {\n    if (!this.isFake()) {\n        return null;\n    }\n    if ((this.getLeft()).isDirectAncestor()) {\n        return getRight();\n    }\n    if ((this.getRight()).isDirectAncestor()) {\n        return getLeft();\n    }\n    return null;\n}","223":"public static Node getCommonAncestorNode(Tree tree, Set<String> leafNodes) {\n    int cardinality = leafNodes.size();\n    if (cardinality == 0) {\n        throw new IllegalArgumentException(\"No leaf nodes selected\");\n    }\n    Node[] mrca = { null };\n    getCommonAncestorNode(tree, tree.getRoot(), leafNodes, cardinality, mrca);\n    return mrca[0];\n}","224":"public static double getTreeLength(Tree tree, Node node) {\n    int childCount = node.getChildCount();\n    if (childCount == 0)\n        return node.getLength();\n    double length = 0;\n    for (Node child : node.getChildren()) {\n        length += getTreeLength(tree, child);\n    }\n    if (node != tree.getRoot())\n        length += node.getLength();\n    return length;\n}","225":"private static void getDescendantLeaves(Tree tree, Node node, Collection<String> set) {\n    if (node.isLeaf()) {\n        set.add(tree.getTaxonId(node));\n    } else {\n        for (Node child : node.getChildren()) {\n            getDescendantLeaves(tree, child, set);\n        }\n    }\n}","226":"@Override\npublic int getCoalescentEvents(int i) {\n    if (!intervalsKnown) {\n        calculateIntervals();\n    }\n    if (i >= intervalCount)\n        throw new IllegalArgumentException();\n    if (i < intervalCount - 1) {\n        return lineageCounts[i] - lineageCounts[i + 1];\n    } else {\n        return lineageCounts[i] - 1;\n    }\n}","227":"@Override\npublic IntervalType getIntervalType(int i) {\n    if (!intervalsKnown) {\n        calculateIntervals();\n    }\n    if (i >= intervalCount)\n        throw new IllegalArgumentException();\n    int numEvents = getCoalescentEvents(i);\n    if (numEvents > 0)\n        return IntervalType.COALESCENT;\n    else if (numEvents < 0)\n        return IntervalType.SAMPLE;\n    else\n        return IntervalType.NOTHING;\n}","228":"@Override\npublic double getTotalDuration() {\n    if (!intervalsKnown) {\n        calculateIntervals();\n    }\n    double height = 0.0;\n    for (int j = 0; j < intervalCount; j++) {\n        height += intervals[j];\n    }\n    return height;\n}","229":"@Override\npublic boolean isBinaryCoalescent() {\n    if (!intervalsKnown) {\n        calculateIntervals();\n    }\n    for (int i = 0; i < intervalCount; i++) {\n        if (getCoalescentEvents(i) > 0) {\n            if (getCoalescentEvents(i) != 1)\n                return false;\n        }\n    }\n    return true;\n}","230":"@Override\npublic boolean isCoalescentOnly() {\n    if (!intervalsKnown) {\n        calculateIntervals();\n    }\n    for (int i = 0; i < intervalCount; i++) {\n        if (getCoalescentEvents(i) < 1)\n            return false;\n    }\n    return true;\n}","231":"protected String normalize(String str) {\n    if (str.charAt(0) == ' ') {\n        str = str.substring(1);\n    }\n    if (str.endsWith(\" \")) {\n        str = str.substring(0, str.length() - 1);\n    }\n    return str;\n}","232":"@Override\npublic List<Node> getExternalNodes() {\n    final ArrayList<Node> externalNodes = new ArrayList<>();\n    for (int i = 0; i < getNodeCount(); i++) {\n        final Node node = getNode(i);\n        if (node.isLeaf())\n            externalNodes.add(node);\n    }\n    return externalNodes;\n}","233":"@Override\npublic List<Node> getInternalNodes() {\n    final ArrayList<Node> internalNodes = new ArrayList<>();\n    for (int i = 0; i < getNodeCount(); i++) {\n        final Node node = getNode(i);\n        if (!node.isLeaf())\n            internalNodes.add(node);\n    }\n    return internalNodes;\n}","234":"void listNodes(final Node node, final Node[] nodes) {\n    nodes[node.getNr()] = node;\n    node.setTree(this);\n    for (final Node child : node.getChildren()) {\n        listNodes(child, nodes);\n    }\n}","235":"@Override\npublic Tree copy() {\n    Tree tree = new Tree();\n    tree.setID(getID());\n    tree.index = index;\n    tree.root = root.copy();\n    tree.nodeCount = nodeCount;\n    tree.internalNodeCount = internalNodeCount;\n    tree.leafNodeCount = leafNodeCount;\n    return tree;\n}","236":"public void removeNode(final int i) {\n    final Node[] tmp = new Node[nodeCount - 1];\n    System.arraycopy(m_nodes, 0, tmp, 0, i);\n    for (int j = i; j < nodeCount - 1; j++) {\n        tmp[j] = m_nodes[j + 1];\n        tmp[j].setNr(j);\n    }\n    m_nodes = tmp;\n    nodeCount--;\n    if (i < leafNodeCount)\n        leafNodeCount--;\n    else\n        internalNodeCount--;\n}","237":"public void addNode(final Node newNode) {\n    final Node[] tmp = new Node[nodeCount + 1];\n    System.arraycopy(m_nodes, 0, tmp, 0, nodeCount);\n    tmp[nodeCount] = newNode;\n    newNode.setNr(nodeCount);\n    m_nodes = tmp;\n    nodeCount++;\n    if (newNode.getChildCount() > 0)\n        internalNodeCount++;\n    else\n        leafNodeCount++;\n}","238":"public final void permute(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","239":"public final void shuffle(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","240":"public final void shuffle(int[] array, int numberOfShuffles) {\n    int i, j, temp, l = array.length;\n    for (int shuffle = 0; shuffle < numberOfShuffles; shuffle++) {\n        do {\n            i = nextInt(l);\n            j = nextInt(l);\n        } while (i != j);\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","241":"public int[] shuffled(int l) {\n    int[] array = new int[l];\n    for (int i = 0; i < l; i++) {\n        array[i] = i;\n    }\n    shuffle(array);\n    return array;\n}","242":"public int[] permuted(int l) {\n    int[] array = new int[l];\n    for (int i = 0; i < l; i++) {\n        array[i] = i;\n    }\n    permute(array);\n    return array;\n}","243":"\/**\n * compute EPSILON from scratch\n *\/\npublic static double computeEpsilon() {\n    double eps = 1.0;\n    while (eps + 1.0 != 1.0) {\n        eps \/= 2.0;\n    }\n    eps *= 2.0;\n    return eps;\n}","244":"public int getSumFrequency() {\n    if (!sorted) {\n        sortByFrequency();\n    }\n    int sum = 0;\n    for (int i = 0; i < size(); i++) {\n        sum += getFrequency(i);\n    }\n    return sum;\n}","245":"public void add(T object, int frequency) {\n    Integer freq = frequencyMap.get(object);\n    if (freq != null) {\n        freq += frequency;\n        frequencyMap.put(object, freq);\n    } else {\n        frequencyMap.put(object, frequency);\n        sortedList.add(object);\n        sorted = false;\n    }\n}","246":"\/**\n * compute mean\n *\n * @param x list of numbers\n * @return mean\n *\/\npublic static double mean(double[] x) {\n    double m = 0;\n    int count = x.length;\n    for (double aX : x) {\n        if (Double.isNaN(aX)) {\n            count--;\n        } else {\n            m += aX;\n        }\n    }\n    return m \/ count;\n}","247":"public static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev) {\n    if (x.length != y.length)\n        throw new IllegalArgumentException(\"x and y arrays must be same length!\");\n    int count = x.length;\n    double covar = 0.0;\n    for (int i = 0; i < x.length; i++) {\n        if (Double.isNaN(x[i]) || Double.isNaN(y[i])) {\n            count--;\n        } else {\n            covar += (x[i] - xmean) * (y[i] - ymean);\n        }\n    }\n    covar \/= count;\n    covar \/= (xstdev * ystdev);\n    return covar;\n}","248":"public static double[] HPDInterval(double proportion, double[] x, int[] indices) {\n    double minRange = Double.MAX_VALUE;\n    int hpdIndex = 0;\n    final int diff = (int) Math.round(proportion * x.length);\n    for (int i = 0; i <= (x.length - diff); i++) {\n        final double minValue = x[indices[i]];\n        final double maxValue = x[indices[i + diff - 1]];\n        final double range = Math.abs(maxValue - minValue);\n        if (range < minRange) {\n            minRange = range;\n            hpdIndex = i;\n        }\n    }\n    return new double[] { x[indices[hpdIndex]], x[indices[hpdIndex + diff - 1]] };\n}","249":"public static Set<String> getPackagesAndVersions(Object o) {\n    if (classToPackageMap.size() == 0) {\n        for (String jarDirName : PackageManager.getBeastDirectories()) {\n            ClassToPackageMap.initPackageMap(jarDirName);\n        }\n    }\n    Set<String> packagesAndVersions = new LinkedHashSet<String>();\n    getPackagesAndVersions(o, packagesAndVersions);\n    return packagesAndVersions;\n}","250":"void makePlate(Node node, String pattern, String var, String rangeString) {\n    Element plate = doc.createElement(\"plate\");\n    plate.setAttribute(\"var\", var);\n    plate.setAttribute(\"range\", rangeString);\n    String indent = node.getPreviousSibling().getTextContent();\n    replace(node, pattern, var);\n    node.getParentNode().replaceChild(plate, node);\n    plate.appendChild(doc.createTextNode(indent + \"  \"));\n    plate.appendChild(node);\n    plate.appendChild(doc.createTextNode(indent));\n}","251":"default String getDescription() {\n    final Annotation[] classAnnotations = this.getClass().getAnnotations();\n    for (final Annotation annotation : classAnnotations) {\n        if (annotation instanceof Description) {\n            final Description description = (Description) annotation;\n            return description.value();\n        }\n    }\n    return \"Not documented!!!\";\n}","252":"default String getTipText(final String name) throws IllegalArgumentException, IllegalAccessException {\n    try {\n        Input<?> input = getInput(name);\n        if (input != null) {\n            return input.getTipText();\n        }\n    } catch (Exception e) {\n    }\n    return null;\n}","253":"default void validateInputs() {\n    try {\n        for (final Input<?> input : listInputs()) {\n            input.validate();\n        }\n    } catch (IllegalArgumentException ex) {\n        Log.err.println(\"Validation error when initializing object \" + this.getClass().getName() + \" (id \" + getID() + \"):\");\n        throw ex;\n    }\n}","254":"\/\/ c'tor\n\/**\n * check name is not one of the reserved ones *\n *\/\nprivate void checkName() {\n    if (name.toLowerCase().equals(\"id\") || name.toLowerCase().equals(\"idref\") || name.toLowerCase().equals(\"spec\") || name.toLowerCase().equals(\"name\")) {\n        Log.err.println(\"Found an input with invalid name: \" + name);\n        Log.err.println(\"'id', 'idref', 'spec' and 'name' are reserved and cannot be used\");\n        System.exit(1);\n    }\n}","255":"private void validateReject(Operator operator) throws RuntimeException {\n    List<CalculationNode> affectedNodes = new ArrayList<>();\n    affectedNodes.addAll(state.getCurrentCalculationNodes());\n    affectedNodes.addAll(operator.listStateNodes());\n    for (CalculationNode node : affectedNodes) {\n        if (!node.matchesOldChecksum()) {\n            throw new RuntimeException(\"Node \" + node.getID() + \" was incorrectly restored after rejecting \" + \"operator \" + operator.getID() + \" (according to calculatioNode checksum).\");\n        }\n    }\n}","256":"@Override\npublic void optimize(final double logAlpha) {\n    if (autoOptimize) {\n        double _delta = calcDelta(logAlpha);\n        _delta += Math.log(delta);\n        delta = Math.exp(_delta);\n        if (isIntegerOperator) {\n            delta = Math.max(0.5000000001, delta);\n        }\n    }\n}","257":"@Override\npublic void optimize(final double logAlpha) {\n    if (optimiseInput.get()) {\n        double delta = calcDelta(logAlpha);\n        double scaleFactor = getCoercableParameterValue();\n        delta += Math.log(scaleFactor);\n        scaleFactor = Math.exp(delta);\n        setCoercableParameterValue(scaleFactor);\n    }\n}","258":"@Override\npublic double proposal() {\n    IntegerParameter param = (IntegerParameter) InputUtil.get(parameterInput, this);\n    int i = Randomizer.nextInt(param.getDimension());\n    int newValue = Randomizer.nextInt(param.getUpper() - param.getLower() + 1) + param.getLower();\n    param.setValue(i, newValue);\n    return 0.0;\n}","259":"public void close() {\n    for (final Loggable m_logger : loggerList) {\n        m_logger.close(m_out);\n    }\n    if (m_out != System.out) {\n        m_out.close();\n    }\n}","260":"public void storeToFile(final long sample) {\n    try {\n        PrintStream out = new PrintStream(stateFileName + \".new\");\n        out.print(toXML(sample));\n        out.close();\n        File newStateFile = new File(stateFileName + \".new\");\n        File oldStateFile = new File(stateFileName);\n        oldStateFile.delete();\n        Files.move(newStateFile.toPath(), oldStateFile.toPath(), java.nio.file.StandardCopyOption.REPLACE_EXISTING);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}","261":"public void setEverythingDirty(final boolean isDirty) {\n    for (final StateNode node : stateNode) {\n        node.setEverythingDirty(isDirty);\n    }\n    if (isDirty) {\n        for (int i = 0; i < stateNode.length; i++) {\n            changeStateNodes[i] = i;\n        }\n        nrOfChangedStateNodes = stateNode.length;\n    }\n}","262":"public List<StateNode> listStateNodes() {\n    final List<StateNode> list = new ArrayList<>();\n    for (BEASTInterface o : listActiveBEASTObjects()) {\n        if (o instanceof StateNode) {\n            final StateNode stateNode = (StateNode) o;\n            if (stateNode.isEstimatedInput.get()) {\n                list.add(stateNode);\n            }\n        }\n    }\n    return list;\n}","263":"@Override\npublic void log(long sampleNr, PrintStream out) {\n    BooleanParameter var = (BooleanParameter) getCurrent();\n    int valueCount = var.getDimension();\n    for (int i = 0; i < valueCount; i++) {\n        out.print((var.getValue(i) ? '1' : '0') + \"\\t\");\n    }\n}","264":"public void startEditing(final Operator operator) {\n    assert (isCalledFromOperator(4));\n    if (hasStartedEditing) {\n        return;\n    }\n    hasStartedEditing = true;\n    if (state != null)\n        state.getEditableStateNode(this.index, operator);\n    store();\n}","265":"\/**\n * @param xTilde double[]\n * @return double[]\n *\/\nprivate double[] backwardSubstitution(double[] xTilde) {\n    int n = rows.length;\n    double[] answer = new double[n];\n    for (int i = n - 1; i >= 0; i--) {\n        answer[i] = xTilde[i];\n        for (int j = i + 1; j < n; j++) answer[i] -= rows[i][j] * answer[j];\n        answer[i] \/= rows[i][i];\n    }\n    return answer;\n}","266":"private double[] forwardSubstitution(double[] c) {\n    int n = rows.length;\n    double[] answer = new double[n];\n    for (int i = 0; i < n; i++) {\n        answer[i] = c[permutation[i]];\n        for (int j = 0; j <= i - 1; j++) answer[i] -= rows[i][j] * answer[j];\n    }\n    return answer;\n}","267":"private void initialize(double[][] components) {\n    int n = components.length;\n    rows = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) rows[i][j] = components[i][j];\n    }\n    initialize();\n}","268":"private int largestPivot(int k) {\n    double maximum = Math.abs(rows[k][k]);\n    double abs;\n    int index = k;\n    for (int i = k + 1; i < rows.length; i++) {\n        abs = Math.abs(rows[i][k]);\n        if (abs > maximum) {\n            maximum = abs;\n            index = i;\n        }\n    }\n    return index;\n}","269":"private void pivot(int k) {\n    double inversePivot = 1 \/ rows[k][k];\n    int k1 = k + 1;\n    int n = rows.length;\n    for (int i = k1; i < n; i++) {\n        rows[i][k] *= inversePivot;\n        for (int j = k1; j < n; j++) rows[i][j] -= rows[i][k] * rows[k][j];\n    }\n}","270":"public DoubleMatrix2D getS() {\n    double[][] S = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            S[i][j] = 0.0;\n        }\n        S[i][i] = this.s[i];\n    }\n    return DoubleFactory2D.dense.make(S);\n}","271":"public int rank() {\n    double eps = Math.pow(2.0, -52.0);\n    double tol = Math.max(m, n) * s[0] * eps;\n    int r = 0;\n    for (int i = 0; i < s.length; i++) {\n        if (s[i] > tol) {\n            r++;\n        }\n    }\n    return r;\n}","272":"private int largestPivot(int p) {\n    double pivot = Math.abs(rows[p][p]);\n    int answer = p;\n    double x;\n    for (int i = p + 1; i < rows.length; i++) {\n        x = Math.abs(rows[i][p]);\n        if (x > pivot) {\n            answer = i;\n            pivot = x;\n        }\n    }\n    return answer;\n}","273":"private void swapRows(int p, int q) {\n    if (p != q) {\n        double temp;\n        int m = rows[p].length;\n        for (int j = 0; j < m; j++) {\n            temp = rows[p][j];\n            rows[p][j] = rows[q][j];\n            rows[q][j] = temp;\n        }\n    }\n    return;\n}","274":"public boolean equals(Vector v) {\n    int n = this.dimension();\n    if (v.dimension() != n)\n        return false;\n    for (int i = 0; i < n; i++) {\n        if (v.components[i] != components[i])\n            return false;\n    }\n    return true;\n}","275":"public String toString() {\n    StringBuffer sb = new StringBuffer();\n    char[] separator = { '[', ' ' };\n    for (int i = 0; i < components.length; i++) {\n        sb.append(separator);\n        sb.append(components[i]);\n        separator[0] = ',';\n    }\n    sb.append(']');\n    return sb.toString();\n}","276":"private int largestPowerOf2SmallerThan(int n) {\n    int m = 2;\n    int m2;\n    while (true) {\n        m2 = 2 * m;\n        if (m2 >= n)\n            return m;\n        m = m2;\n    }\n}","277":"\/**\n * @param a MatrixAlgebra.Matrix\n * @throws dr.math.matrixAlgebra.IllegalDimension\n *          if the supplied matrix\n *          does not have the same dimensions.\n *\/\npublic void accumulate(Matrix a) throws IllegalDimension {\n    if (a.rows() != rows() || a.columns() != columns())\n        throw new IllegalDimension(\"Operation error: cannot add a\" + a.rows() + \" by \" + a.columns() + \" matrix to a \" + rows() + \" by \" + columns() + \" matrix\");\n    int m = components[0].length;\n    for (int i = 0; i < components.length; i++) {\n        for (int j = 0; j < m; j++) components[i][j] += a.component(i, j);\n    }\n}","278":"protected double[][] productComponents(double a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) newComponents[i][j] = a * components[i][j];\n    }\n    return newComponents;\n}","279":"protected double[][] subtractComponents(Matrix a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) newComponents[i][j] = components[i][j] - a.components[i][j];\n    }\n    return newComponents;\n}","280":"public double[][] toComponents() {\n    int n = rows();\n    int m = columns();\n    double[][] answer = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) answer[i][j] = components[i][j];\n    }\n    return answer;\n}","281":"public Matrix transpose() {\n    int n = rows();\n    int m = columns();\n    double[][] newComponents = new double[m][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) newComponents[j][i] = components[i][j];\n    }\n    return new Matrix(newComponents);\n}","282":"protected double[][] transposedProductComponents(Matrix a) {\n    int p = this.rows();\n    int n = this.columns();\n    int m = a.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            double sum = 0;\n            for (int k = 0; k < p; k++) sum += components[k][i] * a.components[k][j];\n            newComponents[i][j] = sum;\n        }\n    }\n    return newComponents;\n}","283":"private static void message(String string) {\n    System.out.println(string);\n    if (!java.awt.GraphicsEnvironment.isHeadless()) {\n        SwingUtilities.invokeLater(new Runnable() {\n\n            @Override\n            public void run() {\n                JOptionPane.showMessageDialog(null, string);\n            }\n        });\n    }\n}","284":"public static List<String> find(String classname, String[] pkgnames) {\n    List<String> result;\n    Class<?> cls;\n    result = new ArrayList<String>();\n    try {\n        cls = BEASTClassLoader.forName(classname);\n        result = find(cls, pkgnames);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return result;\n}","285":"public static List<String> find(String classname, String pkgname) {\n    List<String> result;\n    Class<?> cls;\n    result = new ArrayList<String>();\n    try {\n        cls = BEASTClassLoader.forName(classname);\n        result = find(cls, pkgname);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return result;\n}","286":"private static double parseVersion(String versionString) {\n    String[] strs = versionString.split(\"\\\\.\");\n    double version = 0;\n    double divider = 1.0;\n    for (int i = 0; i < strs.length; i++) {\n        try {\n            version += Double.parseDouble(strs[i]) \/ divider;\n            divider = divider * 100.0;\n        } catch (NumberFormatException e) {\n        }\n    }\n    return version;\n}","287":"public boolean isValidFormat() {\n    try {\n        getProjectURL().toURI();\n        return true;\n    } catch (Exception e) {\n        return false;\n    }\n}","288":"public static Set<String> loadService(Class<?> service) {\n    Set<String> providers = services.get(service.getName());\n    if (providers == null) {\n        if (services.size() == 0) {\n            initServices();\n        } else {\n            services.put(service.getName(), new HashSet<>());\n        }\n        providers = services.get(service.getName());\n    }\n    return providers;\n}","289":"public static void addService(String service, String className, String packageName) {\n    if (!BEASTClassLoader.services.containsKey(service)) {\n        if (BEASTClassLoader.services.size() == 0) {\n            initServices();\n        }\n        if (!BEASTClassLoader.services.containsKey(service)) {\n            BEASTClassLoader.services.put(service, new HashSet<>());\n        }\n    }\n    BEASTClassLoader.services.get(service).add(className);\n    class2loaderMap.put(className, getClassLoader(packageName));\n}","290":"private Map<String, String> getDotNotationToCamelCase() {\n    if (dotNotationToCamelCase == null) {\n        dotNotationToCamelCase = new HashMap<>();\n        for (Map.Entry<String, Class<?>> entry : getClassAttributesToType().entrySet()) {\n            String fieldNameCamelCase = entry.getKey();\n            QueryParameter queryParameter = annotations.get(fieldNameCamelCase);\n            if (queryParameter != null) {\n                String fieldNameDotNotation = queryParameter.id();\n                dotNotationToCamelCase.put(fieldNameDotNotation, fieldNameCamelCase);\n            }\n        }\n    }\n    return dotNotationToCamelCase;\n}","291":"public SpeciesConfiguration getSpeciesConfig(String id) {\n    if (StringUtils.isEmpty(id)) {\n        return null;\n    }\n    List<SpeciesConfiguration> allSpecies = getAllSpecies();\n    for (SpeciesConfiguration config : allSpecies) {\n        if (config.getId().equals(id)) {\n            return config;\n        }\n    }\n    return null;\n}","292":"public static int getNumIndelBases(SAMRecord read) {\n    int numIndelBases = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndelBases += element.getLength();\n        }\n    }\n    return numIndelBases;\n}","293":"public static int getIntAttribute(SAMRecord read, String attribute) {\n    Integer num = read.getIntegerAttribute(attribute);\n    if (num == null) {\n        return 0;\n    } else {\n        return num;\n    }\n}","294":"public static int getNumIndels(SAMRecord read) {\n    int numIndels = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndels += 1;\n        }\n    }\n    return numIndels;\n}","295":"public static SAMRecord cloneRead(SAMRecord read) {\n    try {\n        return (SAMRecord) read.clone();\n    } catch (CloneNotSupportedException e) {\n        e.printStackTrace();\n        throw new RuntimeException(e);\n    }\n}","296":"\/**\n * Convert from phred33 to phred64\n *\/\npublic String phred33ToPhred64(String phred33) {\n    StringBuffer phred64 = new StringBuffer();\n    for (int i = 0; i < phred33.length(); i++) {\n        phred64.append((char) (phred33.charAt(i) + PHRED33_TO_PHRED64_DIFF));\n    }\n    return phred64.toString();\n}","297":"public String phred64ToPhred33(String phred64) {\n    StringBuffer phred33 = new StringBuffer();\n    for (int i = 0; i < phred64.length(); i++) {\n        phred33.append((char) (phred64.charAt(i) - PHRED33_TO_PHRED64_DIFF));\n    }\n    return phred33.toString();\n}","298":"public int numHighQualityMismatches(SAMRecord read, int minBaseQual) {\n    int mismatches = 0;\n    if (!read.getReadUnmappedFlag()) {\n        mismatches = numDifferences(read, minBaseQual);\n    }\n    return mismatches;\n}","299":"private static DoubleMatrixDataset<String, String> readDoubleMatrixFile(String eigenVectorFile, Set<String> rowsToInclude) {\n    DoubleMatrixDataset<String, String> tmp = new DoubleMatrixDataset<String, String>();\n    try {\n        if (rowsToInclude == null) {\n            tmp = new DoubleMatrixDataset<String, String>(eigenVectorFile);\n        } else {\n            tmp = new DoubleMatrixDataset<String, String>(eigenVectorFile, null, rowsToInclude);\n        }\n    } catch (IOException ex) {\n        org.apache.logging.log4j.LogManager.getLogger(AssociatingPcasWithAnnotation.class).log(org.apache.logging.log4j.Level.FATAL, ex);\n    }\n    return (tmp);\n}","300":"public int getBoudaryCount() {\n    int count = 0;\n    for (TreeMap<Integer, ArrayList<GenomicBoundary<V>>> chrBoundaries : genomicsBoundaries.values()) {\n        count += chrBoundaries.size();\n    }\n    return count;\n}","301":"public int getDistanceFromCorrelation(double correlation) {\n    int distance;\n    if (correlation > 0) {\n        distance = (int) (-(double) Short.MIN_VALUE + ((correlation) * ((double) Short.MAX_VALUE)));\n    } else {\n        distance = (int) (-(double) Short.MIN_VALUE + ((correlation) * (double) Short.MIN_VALUE));\n    }\n    return distance;\n}","302":"public double lookupRforZscore(double z) {\n    final long bin;\n    if (z >= maxZscore) {\n        bin = maxBin;\n    } else if (z < -maxZscore) {\n        bin = 0;\n    } else {\n        bin = Math.round(((z \/ maxZscore) + 1) * binsPerSide - halfStep);\n    }\n    return rLookupTable[(int) bin];\n}","303":"public void inplaceRToZ(DoubleMatrixDataset dataset) {\n    DoubleMatrix2D matrix = dataset.getMatrix();\n    final int rows = matrix.rows();\n    final int cols = matrix.columns();\n    for (int r = 0; r < rows; ++r) {\n        for (int c = 0; c < cols; ++c) {\n            matrix.setQuick(r, c, lookupZscoreForR(matrix.getQuick(r, c)));\n        }\n    }\n}","304":"public static double getWeightedZ(float[] zScores, int[] sampleSizes) {\n    if (zScores.length != sampleSizes.length) {\n        throw new IllegalArgumentException(\"Zscores and sample sizes should have same length!\");\n    }\n    double weightedZ = 0;\n    double sampleSizeSum = 0;\n    for (int j = 0; j < zScores.length; j++) {\n        if (!Float.isNaN(zScores[j])) {\n            weightedZ += Math.sqrt(sampleSizes[j]) * zScores[j];\n            sampleSizeSum += sampleSizes[j];\n        }\n    }\n    weightedZ \/= Math.sqrt(sampleSizeSum);\n    return weightedZ;\n}","305":"public static double getWeightedZ(double[] zScores, int[] sampleSizes) {\n    if (zScores.length != sampleSizes.length) {\n        throw new IllegalArgumentException(\"Zscores and sample sizes should have same length!\");\n    }\n    double weightedZ = 0;\n    double sampleSizeSum = 0;\n    int nrNans = 0;\n    for (int j = 0; j < zScores.length; j++) {\n        if (!Double.isNaN(zScores[j]) && sampleSizes[j] >= 0) {\n            nrNans++;\n            weightedZ += Math.sqrt(sampleSizes[j]) * zScores[j];\n            sampleSizeSum += sampleSizes[j];\n        }\n    }\n    weightedZ \/= Math.sqrt(sampleSizeSum);\n    return weightedZ;\n}","306":"public static double getWeightedZ(float[] zScores, int[] sampleSizes, double[] weights) {\n    if (zScores.length != sampleSizes.length) {\n        throw new IllegalArgumentException(\"Zscores and sample sizes should have same length!\");\n    }\n    double weightedZ = 0;\n    double sampleSizeSum = 0;\n    for (int j = 0; j < zScores.length; j++) {\n        if (!Double.isNaN(zScores[j])) {\n            weightedZ += Math.sqrt(sampleSizes[j]) * weights[j] * zScores[j];\n            sampleSizeSum += (sampleSizes[j] * weights[j]);\n        }\n    }\n    weightedZ \/= Math.sqrt(sampleSizeSum);\n    return weightedZ;\n}","307":"public static double getDatasetSizeWeightedZ(float[] zScores, int[] sampleSizes, double[] weights) {\n    if (zScores.length != sampleSizes.length) {\n        throw new IllegalArgumentException(\"Zscores and sample sizes should have same length!\");\n    }\n    double weightedZ = 0;\n    double sampleSizeSum = 0;\n    for (int j = 0; j < zScores.length; j++) {\n        if (!Double.isNaN(zScores[j])) {\n            weightedZ += Math.sqrt(sampleSizes[j] * weights[j]) * zScores[j];\n            sampleSizeSum += (sampleSizes[j] * weights[j]);\n        }\n    }\n    weightedZ \/= Math.sqrt(sampleSizeSum);\n    return weightedZ;\n}","308":"public static double getWeightedZ(double[] zScores, int[] sampleSizes, double[] weights) {\n    if (zScores.length != sampleSizes.length) {\n        throw new IllegalArgumentException(\"Zscores and sample sizes should have same length!\");\n    }\n    double weightedZ = 0;\n    double sampleSizeSum = 0;\n    for (int j = 0; j < zScores.length; j++) {\n        if (!Double.isNaN(zScores[j])) {\n            weightedZ += Math.sqrt(sampleSizes[j]) * weights[j] * zScores[j];\n            sampleSizeSum += (sampleSizes[j] * weights[j]);\n        }\n    }\n    weightedZ \/= Math.sqrt(sampleSizeSum);\n    return weightedZ;\n}","309":"public static double correlationToP(double correlation, int nrSamples, StudentT tDist) {\n    double t = correlation \/ (Math.sqrt((1 - correlation * correlation) \/ (double) (nrSamples - 2)));\n    double pValue = 0;\n    if (t < 0) {\n        pValue = tDist.cdf(t);\n        if (pValue < 2.0E-323) {\n            pValue = 2.0E-323;\n        }\n    } else {\n        pValue = tDist.cdf(-t);\n        if (pValue < 2.0E-323) {\n            pValue = 2.0E-323;\n        }\n    }\n    return pValue;\n}","310":"private static int compareNaN(double a, double b) {\n    if (a != a) {\n        if (b != b) {\n            return 0;\n        } else {\n            return 1;\n        }\n    }\n    return -1;\n}","311":"public static DoubleMatrixDataset<String, String> combineBasedOnCols(ArrayList<DoubleMatrixDataset<String, String>> datasets) {\n    DoubleMatrixDataset<String, String> newMatrix = datasets.get(0);\n    if (datasets.size() > 1) {\n        for (int i = 1; i < datasets.size(); ++i) {\n            try {\n                newMatrix = mergeMatrixBasedOnColumns(newMatrix, datasets.get(i), false);\n            } catch (Exception ex) {\n                org.apache.logging.log4j.LogManager.getLogger(MergeDoubleMatrices.class).log(org.apache.logging.log4j.Level.FATAL, ex);\n            }\n        }\n    }\n    return (newMatrix);\n}","312":"public void orderOnColumnnames() {\n    LinkedHashMap<C, Integer> newColHash = new LinkedHashMap<C, Integer>((int) Math.ceil(this.matrix.columns() \/ 0.75));\n    ArrayList<C> names = this.getColObjects();\n    Collections.sort(names);\n    int pos = 0;\n    for (C name : names) {\n        newColHash.put(name, pos);\n        pos++;\n    }\n    reorderCols(newColHash);\n}","313":"public void setElement(R rowName, C columnName, double value) {\n    Integer row = hashRows.get(rowName);\n    Integer column = hashCols.get(columnName);\n    if (row != null && column != null) {\n        matrix.setQuick(row, column, value);\n    } else if (row == null) {\n        throw new NoSuchElementException(\"Row not found: \" + rowName.toString());\n    } else {\n        throw new NoSuchElementException(\"Column not found: \" + columnName.toString());\n    }\n}","314":"public double getElement(R rowName, C columnName) {\n    Integer row = hashRows.get(rowName);\n    Integer column = hashCols.get(columnName);\n    if (row != null && column != null) {\n        return matrix.getQuick(row, column);\n    } else if (row == null) {\n        throw new NoSuchElementException(\"Row not found: \" + rowName.toString());\n    } else {\n        throw new NoSuchElementException(\"Column not found: \" + columnName.toString());\n    }\n}","315":"public DoubleMatrix2D viewRowSelectionMatrix(Collection<R> rowsToView) {\n    int[] rowNrs = new int[rowsToView.size()];\n    int i = 0;\n    for (R row : rowsToView) {\n        rowNrs[i++] = hashRows.get(row);\n    }\n    return matrix.viewSelection(rowNrs, null);\n}","316":"public String[] readLineElemsReturnObjects(Pattern p) throws IOException {\n    if (in != null) {\n        String ln = readLine();\n        if (ln != null) {\n            String[] origelems = p.split(ln);\n            String[] returnelems = new String[origelems.length];\n            for (int i = 0; i < origelems.length; i++) {\n                returnelems[i] = new String(origelems[i]);\n            }\n            ln = null;\n            return returnelems;\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}","317":"\/**\n * Close the file, and release any associated system resources.\n *\n * @exception IOException if an I\/O error occurrs.\n *\/\npublic void close() throws IOException {\n    \/\/ If we are writing and the buffer has been modified, flush the contents\n    \/\/ of the buffer.\n    if ((mode | WRITE) > 0 && bufferModified) {\n        file.seek(bufferStart);\n        file.write(buffer, 0, (int) dataSize);\n    }\n    \/\/ Close the underlying file object.\n    file.close();\n}","318":"private static int getNrNs(String string) {\n    char[] characterArray = string.toCharArray();\n    int numberN = 0;\n    for (int i = 0; i < characterArray.length; ++i) {\n        if (characterArray[i] == 'n' || characterArray[i] == 'N') {\n            numberN++;\n        }\n    }\n    return (numberN);\n}","319":"public static DoubleMatrixDataset<String, String> readDoubleMatrixFile(String eigenVectorFile, Set<String> rowsToInclude) {\n    DoubleMatrixDataset<String, String> tmp = new DoubleMatrixDataset<String, String>();\n    try {\n        if (rowsToInclude == null) {\n            tmp = new DoubleMatrixDataset<String, String>(eigenVectorFile);\n        } else {\n            tmp = new DoubleMatrixDataset<String, String>(eigenVectorFile, null, rowsToInclude);\n        }\n    } catch (IOException ex) {\n        LogManager.getLogger(SortInterChrContacts.class).log(Level.FATAL, ex);\n    }\n    return (tmp);\n}","320":"public String getProperty(String name, Object[] args) {\n    if (name == null) {\n        return null;\n    }\n    if (args == null) {\n        return getProperty(name);\n    } else {\n        String value = getProperty(name);\n        if (value == null) {\n            return null;\n        } else {\n            return MessageFormat.format(value, args);\n        }\n    }\n}","321":"\/**\n * doInBackground method catches out of memory exception.\n *\n * @return K    task result\n * @throws Exception    exceptions.\n *\/\n@Override\nprotected K doInBackground() throws Exception {\n    try {\n        return retrieve();\n    } catch (OutOfMemoryError ex) {\n        GUIUtilities.error(Desktop.getInstance().getMainComponent(), appContext.getProperty(\"out.of.memory.message\"), appContext.getProperty(\"out.of.memory.title\"));\n    } catch (InterruptedException e) {\n        logger.warn(\"Task has been cancelled: {}\", this.getClass().getDeclaringClass());\n    }\n    return null;\n}","322":"private Spectrum getSpectrum(Comparable spectrumId) {\n    Spectrum result = null;\n    try {\n        result = controller.getSpectrumById(spectrumId);\n    } catch (DataAccessException dex) {\n        String msg = \"Failed to retrieve data entry from data source\";\n        logger.error(msg, dex);\n        appContext.addThrowableEntry(new ThrowableEntry(MessageType.ERROR, msg, dex));\n    }\n    return result;\n}","323":"private String calculateDecoyRatio(TableModel tableModel, int colIndex, DecoyAccessionFilter filter) {\n    int rowCnt = tableModel.getRowCount();\n    int decoyCnt = 0;\n    for (int i = 0; i < rowCnt; i++) {\n        String acc = getProteinAccession(tableModel, colIndex, i);\n        if (acc != null && !filter.apply(acc)) {\n            decoyCnt++;\n        }\n    }\n    float percentage = (decoyCnt * 1.0f \/ rowCnt) * 100;\n    return String.format(\"%.0f%%\", percentage);\n}","324":"private void addPTMAnnotations(Comparable id, PeptideAnnotation peptide) throws DataAccessException {\n    Collection<Modification> ptms = controller.getPTMs(identId, id);\n    for (Modification ptm : ptms) {\n        PTMAnnotation ptmAnnotation = new PTMAnnotation();\n        ptmAnnotation.setAccession(ptm.getId().toString());\n        ptmAnnotation.setLocation(ptm.getLocation());\n        ptmAnnotation.setModDatabaseVersion(ptm.getModDatabaseVersion());\n        ptmAnnotation.setName(ptm.getName());\n        ptmAnnotation.setAvgMassDeltas(ptm.getAvgMassDelta());\n        ptmAnnotation.setMonoMassDeltas(ptm.getMonoisotopicMassDelta());\n        peptide.addPtmAnnotation(ptmAnnotation);\n    }\n}","325":"private boolean alreadyOpened(File file) {\n    boolean isOpened = false;\n    List<DataAccessController> controllers = context.getControllers();\n    for (DataAccessController controller : controllers) {\n        if (file.equals(controller.getSource())) {\n            isOpened = true;\n        }\n    }\n    return isOpened;\n}","326":"private void addPTMAnnotations(Comparable id, PeptideAnnotation peptide) throws DataAccessException {\n    Collection<Modification> ptms = controller.getPTMs(identId, id);\n    for (Modification ptm : ptms) {\n        PTMAnnotation ptmAnnotation = new PTMAnnotation();\n        ptmAnnotation.setAccession(ptm.getId().toString());\n        ptmAnnotation.setLocation(ptm.getLocation());\n        ptmAnnotation.setModDatabaseVersion(ptm.getModDatabaseVersion());\n        ptmAnnotation.setName(ptm.getName());\n        ptmAnnotation.setAvgMassDeltas(ptm.getAvgMassDelta());\n        ptmAnnotation.setMonoMassDeltas(ptm.getMonoisotopicMassDelta());\n        peptide.addPtmAnnotation(ptmAnnotation);\n    }\n}","327":"@SuppressWarnings(\"unchecked\")\npublic List<Task> getTasks(TaskListener listener) {\n    List<Task> ts = new ArrayList<>();\n    synchronized (tasksLock) {\n        for (Task task : tasks) {\n            if (task.hasTaskListener(listener)) {\n                ts.add(task);\n            }\n        }\n    }\n    return ts;\n}","328":"public List<Task> getTasks(PropertyChangeListener listener) {\n    List<Task> ts = new ArrayList<>();\n    synchronized (tasksLock) {\n        for (Task task : tasks) {\n            if (task.hasPropertyChangeListener(listener)) {\n                ts.add(task);\n            }\n        }\n    }\n    return ts;\n}","329":"public List<Task> getTasks(Class<? extends Task> taskClass) {\n    List<Task> ts = new ArrayList<>();\n    synchronized (tasksLock) {\n        for (Task task : tasks) {\n            if (task.getClass().equals(taskClass)) {\n                ts.add(task);\n            }\n        }\n    }\n    return ts;\n}","330":"\/**\n * Set the default transfer parameters for this transfer.\n * For supported parameters see class #XferParams\n * For additional descriptions see the Aspera documentation\n * of the command line tool. For example at\n * http:\/\/download.asperasoft.com\/download\/docs\/ascp\/2.7\/html\/index.html\n * <p\/>\n *\n * @return the default transfer parameters.\n *\/\npublic static XferParams defaultTransferParams() {\n    XferParams p = new XferParams();\n    p.tcpPort = Integer.parseInt(appContext.getProperty(\"aspera.xfer.tcpPort\"));\n    \/\/ port used for data transfer\n    p.udpPort = Integer.parseInt(appContext.getProperty(\"aspera.xfer.udpPort\"));\n    \/\/ 10000000 Kbps (= 10 Gbps)\n    p.targetRateKbps = Integer.parseInt(appContext.getProperty(\"aspera.xfer.targetRateKbps\"));\n    \/\/    100 Kbps\n    p.minimumRateKbps = Integer.parseInt(appContext.getProperty(\"aspera.xfer.minimumRateKbps\"));\n    p.encryption = Encryption.DEFAULT;\n    p.overwrite = Overwrite.DIFFERENT;\n    p.generateManifest = Manifest.NONE;\n    p.policy = Policy.FAIR;\n    p.cookie = appContext.getProperty(\"aspera.xfer.cookie\");\n    p.token = appContext.getProperty(\"aspera.xfer.token\");\n    p.resumeCheck = Resume.SPARSE_CHECKSUM;\n    p.preCalculateJobSize = Boolean.parseBoolean(appContext.getProperty(\"aspera.xfer.preCalculateJobSize\"));\n    p.createPath = Boolean.parseBoolean(appContext.getProperty(\"aspera.xfer.createPath\"));\n    return p;\n}","331":"public String uploadFiles(Collection<File> filesToUpload, String destinationDirectory) throws FaspManagerException {\n    LocalLocation localFiles = new LocalLocation();\n    for (File file : filesToUpload) {\n        localFiles.addPath(file.getAbsolutePath());\n    }\n    remoteLocation.clearPaths();\n    remoteLocation.addPath(destinationDirectory);\n    TransferOrder order = new TransferOrder(localFiles, remoteLocation, transferParameters);\n    return FaspManager.getSingleton().startTransfer(order);\n}","332":"public static void showUpdateDialog() {\n    int option = JOptionPane.showConfirmDialog(null, \"<html><b>A new version of PRIDE Inspector is available<\/b>.<br><br> \" + \"Would you like to update?<\/html>\", \"Update Info\", JOptionPane.YES_NO_OPTION);\n    if (option == JOptionPane.YES_OPTION) {\n        DesktopContext context = Desktop.getInstance().getDesktopContext();\n        String website = context.getProperty(\"pride.inspector.download.website\");\n        HttpUtilities.openURL(website);\n    }\n}","333":"public synchronized ListModel getSummaryReportModel(DataAccessController controller) {\n    ListModel model = controller == null ? null : summaryReportTracker.get(controller);\n    if (model == null) {\n        model = new ReportListModel(controller);\n    }\n    if (controller != null)\n        summaryReportTracker.put(controller, model);\n    return model;\n}","334":"private void setChartBarColour() {\n    renderer.setSeriesPaint(0, new Color(166, 206, 227));\n    renderer.setSeriesPaint(1, new Color(31, 120, 180));\n    renderer.setSeriesPaint(2, new Color(51, 160, 44));\n    renderer.setSeriesPaint(3, new Color(255, 127, 0));\n    renderer.setSeriesPaint(4, new Color(127, 201, 127));\n    renderer.setSeriesPaint(5, new Color(190, 174, 212));\n    renderer.setSeriesPaint(6, new Color(253, 192, 134));\n    renderer.setSeriesPaint(7, new Color(56, 108, 176));\n    renderer.setSeriesPaint(8, new Color(240, 2, 127));\n    renderer.setSeriesPaint(9, new Color(191, 91, 23));\n}","335":"private void removeData(Comparable id) {\n    java.util.List<Comparable> columns = idMapping.get(id);\n    if (columns != null) {\n        for (Comparable column : columns) {\n            dataset.removeValue(id, column);\n        }\n        idMapping.remove(id);\n    }\n}","336":"private JPanel buildHeaderPane() {\n    JPanel metaDataPanel = buildMetaDataPane();\n    JToolBar buttonPanel = buildButtonPane();\n    JPanel titlePanel = new JPanel(new BorderLayout());\n    titlePanel.setOpaque(false);\n    titlePanel.add(metaDataPanel, BorderLayout.WEST);\n    titlePanel.add(buttonPanel, BorderLayout.EAST);\n    return titlePanel;\n}","337":"private JPanel buildMetaDataPane() {\n    JPanel metaDataPanel = new JPanel();\n    metaDataPanel.setOpaque(false);\n    metaDataPanel.setLayout(new FlowLayout(FlowLayout.LEFT));\n    JLabel tableLabel = new JLabel(\"<html><b>Samples<\/b><\/html>\");\n    metaDataPanel.add(tableLabel);\n    return metaDataPanel;\n}","338":"private void setChartBarColour() {\n    renderer.setSeriesPaint(0, new Color(166, 206, 227));\n    renderer.setSeriesPaint(1, new Color(31, 120, 180));\n    renderer.setSeriesPaint(2, new Color(51, 160, 44));\n    renderer.setSeriesPaint(3, new Color(255, 127, 0));\n    renderer.setSeriesPaint(4, new Color(127, 201, 127));\n    renderer.setSeriesPaint(5, new Color(190, 174, 212));\n    renderer.setSeriesPaint(6, new Color(253, 192, 134));\n    renderer.setSeriesPaint(7, new Color(56, 108, 176));\n    renderer.setSeriesPaint(8, new Color(240, 2, 127));\n    renderer.setSeriesPaint(9, new Color(191, 91, 23));\n}","339":"private void removeData(Comparable id, Comparable idPeptide) {\n    Map<Comparable, List<Comparable>> peptides = idMapping.get(id);\n    if (peptides != null && peptides.get(idPeptide) != null) {\n        List<Comparable> columns = peptides.get(idPeptide);\n        for (Comparable column : columns) {\n            dataset.removeValue(id.toString() + idPeptide.toString(), column);\n        }\n        peptides.remove(idPeptide);\n        if (idMapping.get(id).size() == 0)\n            idMapping.remove(id);\n    }\n}","340":"public List<List<String>> getAllContent() {\n    List<List<String>> results = new ArrayList<>();\n    int startIndexOfContent = getStartIndexOfContent();\n    for (Object content : contents) {\n        List<Object> contentList = (List<Object>) content;\n        List<String> result = new ArrayList<>();\n        for (int i = startIndexOfContent; i < contentList.size(); i++) {\n            result.add(contentList.get(i).toString());\n        }\n        results.add(result);\n    }\n    return results;\n}","341":"public int getColumnIndex(String header) {\n    int index = -1;\n    List<Map.Entry<String, String>> entries = new LinkedList<>(columnNames.entrySet());\n    for (Map.Entry<String, String> entry : entries) {\n        if (entry.getKey().equals(header)) {\n            index = entries.indexOf(entry);\n        }\n    }\n    return index;\n}","342":"protected void addProteinDetails(Object newData) {\n    Map<String, Protein> proteins = (Map<String, Protein>) newData;\n    Collection<PeptideRow> peptideRows = spectrumIdToPeptideRow.values();\n    for (PeptideRow parentPeptideRow : peptideRows) {\n        addProteinDetailsForPeptideRow(proteins, (PeptideRow) getRoot(), parentPeptideRow);\n        for (PeptideRow childPeptideRow : parentPeptideRow.getChildren()) {\n            addProteinDetailsForPeptideRow(proteins, parentPeptideRow, childPeptideRow);\n        }\n    }\n}","343":"protected void addPeptideFitData(Object newDataValue) {\n    Map<Tuple<Comparable, Comparable>, Integer> peptideFits = (Map<Tuple<Comparable, Comparable>, Integer>) newDataValue;\n    Collection<PeptideRow> peptideRows = spectrumIdToPeptideRow.values();\n    for (PeptideRow parentPeptideRow : peptideRows) {\n        addPeptideFitDataToPeptideRow(peptideFits, (PeptideRow) getRoot(), parentPeptideRow);\n        for (PeptideRow childPeptideRow : parentPeptideRow.getChildren()) {\n            addPeptideFitDataToPeptideRow(peptideFits, parentPeptideRow, childPeptideRow);\n        }\n    }\n}","344":"private void addSequenceCoverageData(Object newData) {\n    Map<Comparable, Double> coverageMap = (Map<Comparable, Double>) newData;\n    Collection<SortableProteinNode> proteinTableRows = proteinGroupIdToProteinTableRow.values();\n    for (SortableProteinNode parentProteinTableRow : proteinTableRows) {\n        updateSequenceCoverageData(coverageMap, (SortableProteinNode) getRoot(), parentProteinTableRow);\n        for (SortableProteinNode childProteinTableRow : parentProteinTableRow.getChildProteinTableRows()) {\n            updateSequenceCoverageData(coverageMap, parentProteinTableRow, childProteinTableRow);\n        }\n    }\n}","345":"public SortableTreeTableNode getNextSibling() {\n    SortableTreeTableNode retval;\n    SortableTreeTableNode myParent = (SortableTreeTableNode) getParent();\n    if (myParent == null) {\n        retval = null;\n    } else {\n        retval = (SortableTreeTableNode) myParent.getChildAfter(this);\n    }\n    if (retval != null && !isNodeSibling(retval)) {\n        throw new Error(\"child of parent is not a sibling\");\n    }\n    return retval;\n}","346":"public void subscribeToEventBus(EventService eventBus) {\n    if (eventBus == null) {\n        eventBus = ContainerEventServiceFinder.getEventService(this);\n    }\n    peptideSubscriber = new SelectChromatogramSubscriber();\n    eventBus.subscribe(ChromatogramEvent.class, peptideSubscriber);\n}","347":"private void createChromatogramBrowser() {\n    chromaBrowser = new ChromatogramBrowser();\n    Icon helpIcon = GUIUtilities.loadIcon(context.getProperty(\"help.icon.small\"));\n    String helpTooltip = context.getProperty(\"help.tooltip\");\n    PrideAction helpAction = new OpenHelpAction(null, helpIcon, helpTooltip);\n    helpAction.putValue(Action.SHORT_DESCRIPTION, helpTooltip);\n    AbstractButton button = (AbstractButton) chromaBrowser.getSidePane().addAction(helpAction, false);\n    CSH.setHelpIDString(button, \"help.mzgraph.chroma\");\n    button.addActionListener(new CSH.DisplayHelpFromSource(context.getMainHelpBroker()));\n}","348":"public void addData(String categoryStr, String subCategoryStr, Collection<Parameter> data) {\n    Map<String, Collection<Collection<Parameter>>> subCategories = dataContent.get(categoryStr);\n    if (subCategories == null) {\n        subCategories = new HashMap<>();\n        dataContent.put(categoryStr, subCategories);\n    }\n    Collection<Collection<Parameter>> subCategory = subCategories.get(subCategoryStr);\n    if (subCategory == null) {\n        subCategory = new ArrayList<>();\n        subCategories.put(subCategoryStr, subCategory);\n    }\n    subCategory.add(data);\n}","349":"public Collection<Collection<Parameter>> getDataBySubCategory(String category, String subCategory) {\n    Collection<Collection<Parameter>> result = new ArrayList<>();\n    Map<String, Collection<Collection<Parameter>>> subCategories = dataContent.get(category);\n    if (subCategories != null) {\n        Collection<Collection<Parameter>> dataContent = subCategories.get(subCategory);\n        if (dataContent != null) {\n            for (Collection<Parameter> params : dataContent) {\n                Collection<Parameter> newParams = new ArrayList<>(params);\n                result.add(newParams);\n            }\n        }\n    }\n    return result;\n}","350":"private Icon getIcon(SummaryReportMessage.Type type) {\n    switch(type) {\n        case SUCCESS:\n            return GUIUtilities.loadIcon(context.getProperty(\"report.item.success.icon.small\"));\n        case ERROR:\n            return GUIUtilities.loadIcon(context.getProperty(\"report.item.error.icon.small\"));\n        case WARNING:\n            return GUIUtilities.loadIcon(context.getProperty(\"report.item.warning.icon.small\"));\n        case INFO:\n            return GUIUtilities.loadIcon(context.getProperty(\"report.item.plain.icon.small\"));\n        default:\n            return GUIUtilities.loadIcon(context.getProperty(\"report.item.plain.icon.small\"));\n    }\n}","351":"private Paint getBackgroundPaint(SummaryReportMessage.Type type) {\n    switch(type) {\n        case SUCCESS:\n            return new GradientPaint(0, 0, new Color(40, 175, 99, START_ALPHA), 0, DEFAULT_HEIGHT, new Color(40, 175, 99, STOP_ALPHA), true);\n        case ERROR:\n            return new GradientPaint(0, 0, new Color(215, 39, 41, START_ALPHA), 0, DEFAULT_HEIGHT, new Color(215, 39, 41, STOP_ALPHA), true);\n        case WARNING:\n            return new GradientPaint(0, 0, new Color(251, 182, 1, START_ALPHA), 0, DEFAULT_HEIGHT, new Color(251, 182, 1, STOP_ALPHA), true);\n        case INFO:\n            return new GradientPaint(0, 0, new Color(27, 106, 165, START_ALPHA), 0, DEFAULT_HEIGHT, new Color(27, 106, 165, STOP_ALPHA), true);\n        default:\n            return new GradientPaint(0, 0, new Color(27, 106, 165, START_ALPHA), 0, DEFAULT_HEIGHT, new Color(27, 106, 165, STOP_ALPHA), true);\n    }\n}","352":"private Paint getBorderPaint(SummaryReportMessage.Type type) {\n    switch(type) {\n        case SUCCESS:\n            return new Color(40, 175, 99);\n        case ERROR:\n            return new Color(215, 39, 41);\n        case WARNING:\n            return new Color(251, 182, 1);\n        case INFO:\n            return new Color(27, 106, 165);\n        default:\n            return new Color(27, 106, 165);\n    }\n}","353":"public void setContentPane(final JComponent panel) {\n    Runnable code = new Runnable() {\n\n        public void run() {\n            CentralContentPane.this.removeAll();\n            CentralContentPane.this.add(panel, BorderLayout.CENTER);\n            CentralContentPane.this.revalidate();\n            CentralContentPane.this.repaint();\n        }\n    };\n    EDTUtils.invokeLater(code);\n}","354":"@Override\npublic void propertyChange(PropertyChangeEvent evt) {\n    String evtName = evt.getPropertyName();\n    if (PrideInspectorContext.LEFT_CONTROL_PANE_VISIBILITY.equals(evtName)) {\n        logger.info(\"Data source browser's visibility has changed to: {}\", evt.getNewValue());\n        String dataSourceDesc = context.getProperty(\"data.source.title\");\n        if (!mainDisplayPane.isToggled(dataSourceDesc)) {\n            mainDisplayPane.invokeAction(dataSourceDesc);\n        }\n    }\n}","355":"protected VertexRelation getProteinsRelation(VertexObject proteinVertex, VertexObject relatedVertex) {\n    Map<VertexObject, VertexRelation> relationsMap = proteinRelationMaps.get(proteinVertex);\n    if (relationsMap == null) {\n        relationsMap = createProteinsRelationsMap(proteinVertex);\n        proteinRelationMaps.put(proteinVertex, relationsMap);\n    }\n    if (relationsMap != null) {\n        return relationsMap.get(relatedVertex);\n    } else {\n        return null;\n    }\n}","356":"public void removeMessage(Message message) {\n    Iterator<MessagePanel> iter = messagePanels.iterator();\n    while (iter.hasNext()) {\n        MessagePanel panel = iter.next();\n        if (panel.getMessage().equals(message)) {\n            this.remove(panel);\n            iter.remove();\n        }\n    }\n    validateAndPaint();\n}","357":"\/**\n * This method is responsible for create a formatted and styled protein sequence\n * <p\/>\n * 1. insert white space between a segment of the sequence (PROTEIN_SEGMENT_LENGTH)\n * 2. insert tabs between segments of the sequence (PROTEIN_SEGMENT_GAP)\n * 3. highlight the peptide annotations\n * 4. highlight the ptm annotations\n * 5. highlight the selected peptide\n *\n * @param protein protein to be converted to formatted sequence string\n * @return AttributedString    formatted sequence string\n *\/\npublic static AttributedString build(AnnotatedProtein protein) {\n    AttributedString formattedSequence = null;\n    if (protein != null) {\n        String sequence = protein.getSequenceString();\n        if (sequence != null && !\"\".equals(sequence.trim())) {\n            \/\/ add sequence segment gap\n            String gappedSequence = insertSegmentGapToSequence(sequence);\n            \/\/ create attributed string\n            formattedSequence = new AttributedString(gappedSequence);\n            \/\/ set overall font\n            formattedSequence.addAttribute(TextAttribute.FONT, DEFAULT_FONT);\n            formattedSequence.addAttribute(TextAttribute.FOREGROUND, DEFAULT_FOREGROUND);\n            \/\/ color code peptides\n            addPeptideAnnotations(protein, formattedSequence);\n        }\n    }\n    return formattedSequence;\n}","358":"private static void addPTMAttributes(AttributedString formattedSequence, int[] ptmArr) {\n    for (int i = 0; i < ptmArr.length; i++) {\n        int count = ptmArr[i];\n        int index = mapIndex(i);\n        switch(count) {\n            case PTMFitState.FIT:\n                formattedSequence.addAttribute(TextAttribute.BACKGROUND, Constants.PTM_BACKGROUND_COLOUR, index, index + 1);\n                break;\n            case PTMFitState.SELECTED:\n                formattedSequence.addAttribute(TextAttribute.BACKGROUND, Constants.PTM_HIGHLIGHT_COLOUR, index, index + 1);\n                break;\n        }\n    }\n}","359":"public void removeThrowableEntry(ThrowableEntry entry) {\n    List<ThrowableEntry> oldThrowables, newThrowables;\n    synchronized (throwables) {\n        oldThrowables = new ArrayList<>(throwables);\n        throwables.remove(entry);\n        newThrowables = new ArrayList<>(throwables);\n    }\n    firePropertyChange(REMOVE_THROWABLE_PROP, oldThrowables, newThrowables);\n}","360":"public void removeAllThrowableEntries() {\n    List<ThrowableEntry> oldThrowables, newThrowables;\n    synchronized (throwables) {\n        oldThrowables = new ArrayList<>(throwables);\n        throwables.clear();\n        newThrowables = new ArrayList<>(throwables);\n    }\n    firePropertyChange(REMOVE_THROWABLE_PROP, oldThrowables, newThrowables);\n}","361":"private JLabel createCountLabel(String message, int count) {\n    JLabel label = new JLabel();\n    label.setFont(label.getFont().deriveFont(DEFAULT_TITLE_FONT_SIZE));\n    if (count > 0) {\n        label.setFont(label.getFont().deriveFont(Font.BOLD));\n    }\n    label.setText(message + \": \" + count);\n    return label;\n}","362":"public void addProteinDetails(Collection<Protein> proteins) {\n    if (proteins == null) {\n        String msg = \"Collection of proteins cannot be null\";\n        logger.error(msg);\n        throw new IllegalArgumentException(msg);\n    }\n    for (Protein protein : proteins) {\n        proteinNameCache.put(new Element(protein.getAccession(), protein));\n    }\n}","363":"private String generateChrString(String chr) {\n    if (this.addChr()) {\n        if (!chr.toLowerCase().startsWith(\"chr\")) {\n            return \"chr\" + chr;\n        }\n    } else if (chr.toLowerCase().startsWith(\"chr\")) {\n        return chr.substring(3);\n    }\n    return chr;\n}","364":"private VariantContext buildNewVariantWithChr(String chr, VariantContext var) {\n    VariantContextBuilder vcBuilder = new VariantContextBuilder();\n    vcBuilder.alleles(var.getAlleles());\n    vcBuilder.attributes(var.getAttributes());\n    vcBuilder.chr(chr);\n    vcBuilder.filters(var.getFilters());\n    vcBuilder.genotypes(var.getGenotypes());\n    vcBuilder.id(var.getID());\n    vcBuilder.log10PError(var.getLog10PError());\n    vcBuilder.source(var.getSource());\n    vcBuilder.start(var.getStart());\n    vcBuilder.stop(var.getEnd());\n    return vcBuilder.make();\n}","365":"public static VariantContext buildVariant(VariantContext var, List<Allele> alleles, ArrayList<Genotype> genos) {\n    VariantContextBuilder vcBuilder = new VariantContextBuilder();\n    vcBuilder.chr(var.getChr());\n    vcBuilder.id(var.getID());\n    vcBuilder.start(var.getStart());\n    vcBuilder.stop(var.getEnd());\n    vcBuilder.alleles(alleles);\n    vcBuilder.genotypes(genos);\n    vcBuilder.filters(var.getFilters());\n    vcBuilder.log10PError(var.getLog10PError());\n    vcBuilder.source(var.getSource());\n    vcBuilder.attributes(var.getAttributes());\n    return vcBuilder.make();\n}","366":"public static int getLargestLength(TreeSet<String> alleles) {\n    if (alleles == null || alleles.size() == 0)\n        return -1;\n    int largest = 0;\n    for (String al : alleles) {\n        if (al.length() > largest) {\n            largest = al.length();\n        }\n    }\n    return largest;\n}","367":"public static int getDiffCount(Allele ref, Allele alt) {\n    String refNucs = ref.getBaseString();\n    String altNucs = alt.getBaseString();\n    if (refNucs.length() != altNucs.length()) {\n        System.err.println(\"Error: Running getDiffCount on two alleles of different lengths.\");\n        return -1;\n    }\n    int count = 0;\n    for (int i = 0; i < refNucs.length(); i++) {\n        if (refNucs.charAt(i) != altNucs.charAt(i)) {\n            count++;\n        }\n    }\n    return count;\n}","368":"private boolean anyGenotypeNotHomoRef(GenotypesContext gc) {\n    Iterator<Genotype> genoIT = gc.iterator();\n    Genotype geno;\n    while (genoIT.hasNext()) {\n        geno = genoIT.next();\n        if (!geno.isHomRef()) {\n            return true;\n        }\n    }\n    return false;\n}","369":"private VariantPoolHeavy getSmallestVariantPool(ArrayList<VariantPoolHeavy> variantPools) {\n    VariantPoolHeavy smallest = null;\n    int currSize, currSmallest = -1;\n    for (VariantPoolHeavy vp : variantPools) {\n        currSize = vp.getNumVarRecords();\n        if (currSize < currSmallest || currSmallest == -1) {\n            currSmallest = currSize;\n            smallest = vp;\n        }\n    }\n    return smallest;\n}","370":"private ArrayList<Genotype> generateNoCallGenotypesForSamples(TreeSet<String> var1Samples, TreeSet<String> var2Samples) {\n    ArrayList<Genotype> genotypes = new ArrayList<Genotype>();\n    for (String s : var2Samples) {\n        if (!var1Samples.contains(s)) {\n            genotypes.add(generateGenotypeForSample(s, Allele.NO_CALL, Allele.NO_CALL));\n        }\n    }\n    return genotypes;\n}","371":"private boolean varOverlapsFuzzyMatch(VariantContext var, HashMap<Integer, String> fuzzyMatches) {\n    int indelLength = var.getEnd() - var.getStart();\n    String indelLengthString = Integer.toString(indelLength);\n    int pos = var.getStart();\n    String[] chrAndLengthArray;\n    String chrAndLength;\n    for (int i = pos - indelLength; i <= pos + indelLength; i++) {\n        chrAndLength = fuzzyMatches.get(i);\n        if (chrAndLength != null) {\n            chrAndLengthArray = chrAndLength.split(\":\");\n            if (chrAndLengthArray[0].equals(var.getChr()) && chrAndLengthArray[1].equals(indelLengthString)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}","372":"private ArrayList<String> getMissingSamples(GenotypesContext gc, SamplePool sp) {\n    Iterator<String> sampIT = sp.getSamples().iterator();\n    String samp;\n    ArrayList<String> missingSamps = new ArrayList<String>();\n    while (sampIT.hasNext()) {\n        samp = sampIT.next();\n        if (!gc.containsSample(samp)) {\n            missingSamps.add(samp);\n        }\n    }\n    return missingSamps;\n}","373":"\/**\n * Get a list of taxonomy accessions based on a given metadata\n *\n * @param metaData meta data\n * @return List<String>    a list of taxonomy ids\n *\/\npublic static List<String> getTaxonomy(ExperimentMetaData metaData) {\n    List<String> species = new ArrayList<String>();\n    List<Sample> samples = metaData.getSamples();\n    for (Sample sample : samples) {\n        List<CvParam> cvParams = sample.getCvParams();\n        for (CvParam cvParam : cvParams) {\n            if (cvParam.getCvLookupID().equalsIgnoreCase(\"newt\")) {\n                species.add(cvParam.getAccession());\n            }\n        }\n    }\n    return species;\n}","374":"public static String getProjectName(ExperimentMetaData metaData) {\n    String project = null;\n    List<CvParam> cvParams = metaData.getCvParams();\n    for (CvParam cvParam : cvParams) {\n        if (CvTermReference.PROJECT_NAME.getAccession().equals(cvParam.getAccession())) {\n            project = cvParam.getValue();\n        }\n    }\n    return project;\n}","375":"public static Integer getPrecursorChargeParamGroup(ParamGroup paramGroup) {\n    Integer charge = null;\n    if (paramGroup != null) {\n        Double c = getSelectedIonCvParamValue(paramGroup, CvTermReference.PSI_ION_SELECTION_CHARGE_STATE, CvTermReference.ION_SELECTION_CHARGE_STATE);\n        if (c != null) {\n            charge = c.intValue();\n        }\n    }\n    return charge;\n}","376":"public static int getNumberOfUniquePeptides(Protein ident) {\n    List<PeptideSequence> peptides = ident.getPeptidesSequence();\n    int cnt = 0;\n    List<String> seqs = new ArrayList<String>();\n    for (PeptideSequence peptide : peptides) {\n        String seq = peptide.getSequence();\n        if (!seqs.contains(seq)) {\n            seqs.add(seq);\n            cnt++;\n        }\n    }\n    return cnt;\n}","377":"public static int getNumberOfSubstitutionPTMs(Protein ident) {\n    int cnt = 0;\n    List<Peptide> peptides = ident.getPeptides();\n    for (Peptide peptide : peptides) {\n        PeptideSequence peptideSequence = peptide.getPeptideSequence();\n        if (peptideSequence != null) {\n            List<SubstitutionModification> mods = peptideSequence.getSubstitutionModifications();\n            cnt += mods.size();\n        }\n    }\n    return cnt;\n}","378":"public static List<CvParam> transformToCvParam(List<uk.ac.ebi.pride.utilities.data.lightModel.CvParam> cvParamsLight) {\n    List<CvParam> cvParams = new ArrayList<>();\n    try {\n        if (cvParamsLight != null && cvParamsLight.size() != 0) {\n            for (uk.ac.ebi.pride.utilities.data.lightModel.CvParam cvParamLight : cvParamsLight) {\n                cvParams.add(transformToCvParam(cvParamLight));\n            }\n        }\n    } catch (Exception ex) {\n        log.error(\"Error occurred while converting uk.ac.ebi.pride.utilities.data.lightModel.CvParam \" + \"to uk.ac.ebi.pride.utilities.data.core.CvParam\");\n    }\n    return cvParams;\n}","379":"public static Set<CvParam> transformToCvParam(Set<uk.ac.ebi.pride.utilities.data.lightModel.CvParam> cvParamsLight) {\n    Set<CvParam> cvParams = new HashSet<>();\n    try {\n        if (cvParamsLight != null && cvParamsLight.size() != 0) {\n            for (uk.ac.ebi.pride.utilities.data.lightModel.CvParam cvParamLight : cvParamsLight) {\n                cvParams.add(transformToCvParam(cvParamLight));\n            }\n        }\n    } catch (Exception ex) {\n        log.error(\"Error occurred while converting uk.ac.ebi.pride.utilities.data.lightModel.CvParam \" + \"to uk.ac.ebi.pride.utilities.data.core.CvParam\");\n    }\n    return cvParams;\n}","380":"public static List<Organization> transformToOrganization(List<uk.ac.ebi.pride.utilities.data.lightModel.Organization> lightOrganizations) {\n    List<Organization> organizations = null;\n    if (lightOrganizations != null && lightOrganizations.size() != 0) {\n        organizations = new ArrayList<>();\n        for (uk.ac.ebi.pride.utilities.data.lightModel.Organization lightOrganization : lightOrganizations) {\n            organizations.add(transformToOrganization(lightOrganization));\n        }\n    }\n    return organizations;\n}","381":"public static List<Organization> transformAffiliationToOrganization(List<uk.ac.ebi.pride.utilities.data.lightModel.Affiliation> lightAffiliations) {\n    List<Organization> organizations = null;\n    if (lightAffiliations != null && lightAffiliations.size() != 0) {\n        organizations = new ArrayList<>();\n        for (uk.ac.ebi.pride.utilities.data.lightModel.Affiliation lightAffiliation : lightAffiliations) {\n            uk.ac.ebi.pride.utilities.data.lightModel.Organization lightOrganization = lightAffiliation.getOrganization();\n            organizations.add(transformToOrganization(lightOrganization));\n        }\n    }\n    return organizations;\n}","382":"public static <T extends uk.ac.ebi.pride.tools.mzdata_parser.mzdata.model.Param> ParamGroup transformParamGroup(T oldParam) {\n    ParamGroup newParamGroup = null;\n    if (oldParam != null) {\n        List<CvParam> cvParams = new ArrayList<CvParam>();\n        List<UserParam> userParams = new ArrayList<UserParam>();\n        transformCvParam(cvParams, oldParam.getCvParams());\n        transformUserParam(userParams, oldParam.getUserParams());\n        newParamGroup = new ParamGroup(cvParams, userParams);\n    }\n    return newParamGroup;\n}","383":"public static List<Sample> transformSampleList(uk.ac.ebi.pride.tools.mzdata_parser.mzdata.model.Admin oldSampleDescription) {\n    List<Sample> samples = null;\n    if (oldSampleDescription != null) {\n        samples = new ArrayList<Sample>();\n        String id = oldSampleDescription.getSampleName();\n        String name = oldSampleDescription.getSampleName();\n        ParamGroup paramGroup = transformParamGroup(oldSampleDescription.getSampleDescription());\n        Sample newSample = new Sample(paramGroup, id, name);\n        samples.add(newSample);\n    }\n    return samples;\n}","384":"public static List<Software> transformSoftware(uk.ac.ebi.pride.tools.mzdata_parser.mzdata.model.Software oldSoftware) {\n    List<Software> softwares = null;\n    if (oldSoftware != null) {\n        softwares = new ArrayList<Software>();\n        String id = oldSoftware.getName();\n        String version = oldSoftware.getVersion();\n        String name = oldSoftware.getName();\n        Software newSoftware = new Software(null, id, name, null, null, null, version);\n        softwares.add(newSoftware);\n    }\n    return softwares;\n}","385":"private static CvParam getSpectrumType(String value) {\n    CvParam cvParam = null;\n    CvTermReference cvTerm = null;\n    if (\"discrete\".equals(value)) {\n        cvTerm = CvTermReference.CENTROID_SPECTRUM;\n    } else if (\"continuous\".equals(value)) {\n        cvTerm = CvTermReference.PROFILE_SPECTRUM;\n    }\n    if (cvTerm != null) {\n        cvParam = new CvParam(cvTerm.getAccession(), cvTerm.getName(), cvTerm.getCvLabel(), value, null, null, null);\n    }\n    return cvParam;\n}","386":"private static CvParam getMethodOfCombination(String value) {\n    CvTermReference cvTerm = CvTermReference.NO_COMBINATION;\n    if (value != null && value.toLowerCase().contains(\"sum\")) {\n        cvTerm = CvTermReference.SUM_OF_SPECTRA;\n    } else {\n        value = null;\n    }\n    return new CvParam(cvTerm.getAccession(), cvTerm.getName(), cvTerm.getCvLabel(), value, null, null, null);\n}","387":"public static List<Precursor> transformPrecursorList(uk.ac.ebi.pride.jaxb.model.PrecursorList rawPrecursors) {\n    List<Precursor> precursors = null;\n    if (rawPrecursors != null) {\n        precursors = new ArrayList<Precursor>();\n        for (uk.ac.ebi.pride.jaxb.model.Precursor rawPrecursor : rawPrecursors.getPrecursor()) {\n            precursors.add(transformPrecursor(rawPrecursor));\n        }\n    }\n    return precursors;\n}","388":"public static Precursor transformPrecursor(uk.ac.ebi.pride.jaxb.model.Precursor rawPrecursor) {\n    Spectrum spectrum = transformSpectrum(rawPrecursor.getSpectrum());\n    ParamGroup ionSelection = transformParamGroup(rawPrecursor.getIonSelection());\n    List<ParamGroup> ionSelections = null;\n    if (ionSelection != null) {\n        ionSelections = new ArrayList<ParamGroup>();\n        ionSelections.add(ionSelection);\n    }\n    ParamGroup activation = transformParamGroup(rawPrecursor.getActivation());\n    return new Precursor(spectrum, null, null, null, ionSelections, activation);\n}","389":"public static List<CVLookup> transformCvLookups(List<uk.ac.ebi.pride.jaxb.model.CvLookup> rawCvLookups) {\n    List<CVLookup> cvLookups = null;\n    if (rawCvLookups != null) {\n        cvLookups = new ArrayList<CVLookup>();\n        for (uk.ac.ebi.pride.jaxb.model.CvLookup rawCvLookup : rawCvLookups) {\n            CVLookup cvLookup = new CVLookup(rawCvLookup.getCvLabel(), rawCvLookup.getFullName(), rawCvLookup.getVersion(), rawCvLookup.getAddress());\n            cvLookups.add(cvLookup);\n        }\n    }\n    return cvLookups;\n}","390":"public static List<DataProcessing> transformDataProcessingList(List<uk.ac.ebi.pride.tools.mzxml_parser.mzxml.model.DataProcessing> rawDataProcList) {\n    List<DataProcessing> dataProcessings = null;\n    if (rawDataProcList != null) {\n        dataProcessings = new ArrayList<DataProcessing>();\n        int i = 0;\n        for (uk.ac.ebi.pride.tools.mzxml_parser.mzxml.model.DataProcessing oldDataProcessing : rawDataProcList) {\n            dataProcessings.add(transformDataProcessing(i, oldDataProcessing));\n            i++;\n        }\n    }\n    return dataProcessings;\n}","391":"public List<Organization> getOrganizationContacts() {\n    logger.debug(\"Get organizational contact\");\n    List<Organization> organizationList = new ArrayList<Organization>();\n    try {\n        organizationList.addAll(MzTabTransformer.transformContactToOrganization(reader.getContacts()));\n    } catch (Exception ex) {\n        String msg = \"Error while getting organizational contacts\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return organizationList;\n}","392":"public List<Person> getPersonContacts() {\n    logger.debug(\"Get person contacts\");\n    List<Person> personList = new ArrayList<Person>();\n    try {\n        personList.addAll(MzTabTransformer.transformContactToPersons(reader.getContacts()));\n    } catch (Exception ex) {\n        String msg = \"Error while getting person contacts\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return personList;\n}","393":"public List<Reference> getReferences() {\n    logger.debug(\"Get references\");\n    List<Reference> refs = new ArrayList<Reference>();\n    try {\n        refs.addAll(MzTabTransformer.transformReferences(reader.getReferences()));\n    } catch (Exception ex) {\n        String msg = \"Error while getting references\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return refs;\n}","394":"@Override\npublic int getNumberOfPeptidesByRank(int rank) {\n    int num;\n    try {\n        num = reader.getNumberOfPeptides(rank);\n    } catch (Exception ex) {\n        throw new DataAccessException(\"Failed to retrieve number of peptides\", ex);\n    }\n    return num;\n}","395":"@Override\npublic int getNumberOfPeptides() {\n    int num;\n    try {\n        num = reader.getNumIdentifiedPeptides();\n    } catch (Exception ex) {\n        throw new DataAccessException(\"Failed to retrieve number of peptides\", ex);\n    }\n    return num;\n}","396":"@Override\npublic String getUid() {\n    String uid = super.getUid();\n    if (uid == null) {\n        File file = (File) this.getSource();\n        try {\n            uid = MD5Utils.generateHash(file.getAbsolutePath());\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Failed to generate unique id for mzML file\";\n            logger.error(msg, e);\n        }\n    }\n    return uid;\n}","397":"public List<Software> getSoftwares() {\n    ExperimentMetaData metaData = super.getExperimentMetaData();\n    if (metaData == null) {\n        try {\n            List<uk.ac.ebi.pride.tools.mzxml_parser.mzxml.model.Software> rawSoftware = unmarshaller.getSoftwares();\n            return MzXmlTransformer.transformSoftwares(rawSoftware);\n        } catch (MzXMLParsingException e) {\n            String msg = \"Error while getting a list of software\";\n            logger.error(msg, e);\n            throw new DataAccessException(msg, e);\n        }\n    } else {\n        return metaData.getSoftwares();\n    }\n}","398":"public List<InstrumentConfiguration> getInstrumentConfigurations() {\n    MzGraphMetaData metaData = super.getMzGraphMetaData();\n    if (metaData == null) {\n        try {\n            List<MsInstrument> rawInstrumentList = unmarshaller.getMsInstruments();\n            return MzXmlTransformer.transformMsInstrument(rawInstrumentList);\n        } catch (MzXMLParsingException e) {\n            String msg = \"Error while getting a list of instrument configurations\";\n            logger.error(msg, e);\n            throw new DataAccessException(msg, e);\n        }\n    } else {\n        return metaData.getInstrumentConfigurations();\n    }\n}","399":"@Override\npublic ParamGroup getAdditional() {\n    ParamGroup fileContent = getFileContent();\n    Duration startDate;\n    try {\n        startDate = unmarshaller.getStartDate();\n        CvParam cvParamStartDate = MzXmlTransformer.transformDurationToCvParam(startDate, CvTermReference.MS_SCAN_DATE);\n        if (cvParamStartDate != null && fileContent != null)\n            fileContent.addCvParam(cvParamStartDate);\n    } catch (DatatypeConfigurationException e) {\n        String msg = \"Error while getting the started Time\";\n        logger.error(msg, e);\n        throw new DataAccessException(msg, e);\n    }\n    return fileContent;\n}","400":"@Override\npublic MzGraphMetaData getMzGraphMetaData() {\n    MzGraphMetaData metaData = super.getMzGraphMetaData();\n    if (metaData == null) {\n        List<ScanSetting> scanSettings = null;\n        List<DataProcessing> dataProcessings = getDataProcessings();\n        List<InstrumentConfiguration> instrumentConfigurations = getInstrumentConfigurations();\n        metaData = new MzGraphMetaData(null, null, scanSettings, instrumentConfigurations, dataProcessings);\n    }\n    return metaData;\n}","401":"@Override\npublic String getUid() {\n    String uid = super.getUid();\n    if (uid == null) {\n        File file = (File) this.getSource();\n        try {\n            uid = MD5Utils.generateHash(file.getAbsolutePath());\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Failed to generate unique id for mzML file\";\n            logger.error(msg, e);\n        }\n    }\n    return uid;\n}","402":"@Override\nSpectrum getSpectrumById(Comparable id, boolean useCache) {\n    Spectrum spectrum = super.getSpectrumById(id, useCache);\n    if (spectrum == null) {\n        try {\n            uk.ac.ebi.pride.tools.jmzreader.model.Spectrum rawSpec = unmarshaller.getSpectrumById(id.toString());\n            spectrum = MzDataTransformer.transformSpectrum(rawSpec);\n            if (useCache) {\n                getCache().store(CacheEntry.SPECTRUM, id, spectrum);\n            }\n        } catch (JMzReaderException ex) {\n            logger.error(\"Get spectrum by id\", ex);\n            throw new DataAccessException(\"Exception while trying to read Spectrum using Spectrum ID\", ex);\n        }\n    }\n    return spectrum;\n}","403":"@Override\npublic double getProteinCoverage(Comparable proteinId) {\n    Protein protein = getProteinById(proteinId);\n    Double coverage = null;\n    if (protein != null) {\n        coverage = (double) ((DataAccessUtilities.getProteinCoverage(protein) \/ protein.getDbSequence().getSequence().length()) * 100);\n        protein.setSequenceCoverage(coverage);\n    }\n    return coverage;\n}","404":"@Override\n@SuppressWarnings(\"unchecked\")\npublic int getNumberOfUniquePeptides(Comparable proteinId) {\n    int cnt = 0;\n    List<Comparable> ids = (List<Comparable>) cache.get(CacheEntry.PROTEIN_TO_PEPTIDE, proteinId);\n    if (ids != null && cache.hasCacheEntry(CacheEntry.PEPTIDE_SEQUENCE)) {\n        Collection<String> seqs = (Collection<String>) cache.getInBatch(CacheEntry.PEPTIDE_SEQUENCE, ids);\n        if (seqs == null || seqs.isEmpty()) {\n            return super.getNumberOfUniquePeptides(proteinId);\n        }\n        return (new HashSet<String>(seqs)).size();\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        cnt = super.getNumberOfUniquePeptides(proteinId);\n    }\n    return cnt;\n}","405":"@Override\n@SuppressWarnings(\"unchecked\")\npublic int getNumberOfPTMs(Comparable proteinId, Comparable peptideId) {\n    int cnt = 0;\n    List<Tuple<String, Integer>> locations = (List<Tuple<String, Integer>>) cache.get(CacheEntry.PEPTIDE_TO_MODIFICATION, peptideId);\n    if (locations != null) {\n        cnt = locations.size();\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        cnt = super.getNumberOfPTMs(proteinId, peptideId);\n    }\n    return cnt;\n}","406":"@Override\npublic Score getPeptideScore(Comparable proteinId, Comparable peptideId) {\n    Score score = null;\n    ParamGroup paramGroup = (ParamGroup) cache.get(CacheEntry.PEPTIDE_TO_PARAM, new Tuple<Comparable, Comparable>(proteinId, peptideId));\n    if (paramGroup != null) {\n        score = DataAccessUtilities.getScore(paramGroup);\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        score = super.getPeptideScore(proteinId, peptideId);\n    }\n    return score;\n}","407":"@Override\npublic List<SearchEngineCvTermReference> getSearchEngineCvTermReferences() {\n    Collection<SearchEngineCvTermReference> searchEngineCvTermReferences = (Collection<SearchEngineCvTermReference>) cache.get(CacheEntry.SEARCH_ENGINE_TYPE);\n    if (searchEngineCvTermReferences != null && !searchEngineCvTermReferences.isEmpty()) {\n        return new ArrayList<SearchEngineCvTermReference>(searchEngineCvTermReferences);\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        return super.getSearchEngineCvTermReferences();\n    }\n    return null;\n}","408":"@Override\npublic List<SearchEngineScoreCvTermReference> getAvailableProteinLevelScores() {\n    Collection<SearchEngineScoreCvTermReference> proteinLevelScores = (Collection<SearchEngineScoreCvTermReference>) cache.get(CacheEntry.PROTEIN_LEVEL_SCORES);\n    if (proteinLevelScores != null && !proteinLevelScores.isEmpty()) {\n        return new ArrayList<SearchEngineScoreCvTermReference>(proteinLevelScores);\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        return super.getAvailableProteinLevelScores();\n    }\n    return Collections.emptyList();\n}","409":"@Override\npublic List<SearchEngineScoreCvTermReference> getAvailablePeptideLevelScores() {\n    Collection<SearchEngineScoreCvTermReference> peptideLevelScores = (Collection<SearchEngineScoreCvTermReference>) cache.get(CacheEntry.PEPTIDE_LEVEL_SCORES);\n    if (peptideLevelScores != null && !peptideLevelScores.isEmpty()) {\n        return new ArrayList<SearchEngineScoreCvTermReference>(peptideLevelScores);\n    } else if (!DataAccessMode.CACHE_ONLY.equals(mode)) {\n        return super.getAvailablePeptideLevelScores();\n    }\n    return Collections.emptyList();\n}","410":"@Override\npublic QuantCvTermReference getProteinQuantUnit() {\n    Collection<QuantCvTermReference> units;\n    units = (Collection<QuantCvTermReference>) cache.get(CacheEntry.PROTEIN_QUANT_UNIT);\n    if (units != null && !units.isEmpty()) {\n        return CollectionUtils.getElement(units, 0);\n    } else {\n        QuantCvTermReference unit = super.getProteinQuantUnit();\n        cache.store(CacheEntry.PROTEIN_QUANT_UNIT, unit);\n        return unit;\n    }\n}","411":"@Override\npublic QuantCvTermReference getPeptideQuantUnit() {\n    Collection<QuantCvTermReference> units;\n    units = (Collection<QuantCvTermReference>) cache.get(CacheEntry.PEPTIDE_QUANT_UNIT);\n    if (units != null && !units.isEmpty()) {\n        return CollectionUtils.getElement(units, 0);\n    } else {\n        QuantCvTermReference unit = super.getPeptideQuantUnit();\n        cache.store(CacheEntry.PEPTIDE_QUANT_UNIT, unit);\n        return unit;\n    }\n}","412":"@Override\npublic Collection<Comparable> getProteinAmbiguityGroupIds() {\n    if (proteinsAreInferred()) {\n        return super.getProteinAmbiguityGroupIds();\n    }\n    Collection<Comparable> groupIds = (Collection<Comparable>) cache.get(CacheEntry.PROTEIN_GROUP_ID);\n    if (groupIds == null || groupIds.isEmpty()) {\n        groupIds = Collections.emptyList();\n    }\n    return groupIds;\n}","413":"public List<CVLookup> getCvLookups() {\n    logger.debug(\"Get cv lookups\");\n    List<CVLookup> cvLookups = new ArrayList<CVLookup>();\n    try {\n        cvLookups.addAll(PrideXmlTransformer.transformCvLookups(reader.getCvLookups()));\n    } catch (Exception ex) {\n        String msg = \"Error while getting cv lookups\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return cvLookups;\n}","414":"public List<SourceFile> getSourceFiles() {\n    List<SourceFile> sourceFiles = new ArrayList<SourceFile>();\n    try {\n        SourceFile sourceFile = PrideXmlTransformer.transformSourceFile(reader.getAdmin());\n        if (sourceFile != null) {\n            sourceFiles.add(sourceFile);\n        }\n    } catch (Exception ex) {\n        String msg = \"Error while getting source files\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return sourceFiles;\n}","415":"public List<Reference> getReferences() {\n    logger.debug(\"Get references\");\n    List<Reference> refs = new ArrayList<Reference>();\n    try {\n        refs.addAll(PrideXmlTransformer.transformReferences(reader.getReferences()));\n    } catch (Exception ex) {\n        String msg = \"Error while getting references\";\n        logger.error(msg, ex);\n        throw new DataAccessException(msg, ex);\n    }\n    return refs;\n}","416":"@Override\npublic int getNumberOfPeptides() {\n    int num;\n    try {\n        num = reader.getNumberOfPeptides();\n    } catch (Exception ex) {\n        throw new DataAccessException(\"Failed to retrieve number of peptides\", ex);\n    }\n    return num;\n}","417":"@Override\npublic int getNumberOfPeptidesByRank(int rank) {\n    int num;\n    try {\n        num = reader.getNumberOfPeptides();\n    } catch (Exception ex) {\n        throw new DataAccessException(\"Failed to retrieve number of peptides\", ex);\n    }\n    return num;\n}","418":"@Override\npublic String getUid() {\n    String uid = super.getUid();\n    if (uid == null) {\n        File file = (File) this.getSource();\n        try {\n            uid = MD5Utils.generateHash(file.getAbsolutePath());\n        } catch (NoSuchAlgorithmException e) {\n            String msg = \"Failed to generate unique id for mzML file\";\n            logger.error(msg, e);\n        }\n    }\n    return uid;\n}","419":"public Map<SpectraData, File> getSpectraDataMSFiles() {\n    Map<SpectraData, DataAccessController> spectraDataControllerMAp = getSpectraDataMSControllers();\n    Map<SpectraData, File> spectraDataFileMap = new HashMap<SpectraData, File>();\n    for (SpectraData spectraData : spectraDataControllerMAp.keySet()) {\n        DataAccessController controller = spectraDataControllerMAp.get(spectraData);\n        spectraDataFileMap.put(spectraData, (controller == null) ? null : (File) controller.getSource());\n    }\n    return spectraDataFileMap;\n}","420":"@Override\npublic boolean isIdentifiedSpectrum(Comparable specId) {\n    String[] array = specId.toString().split(\"!\");\n    if (array.length < 2) {\n        if (getCache().get(CacheEntry.PEPTIDE_TO_SPECTRUM, specId) != null)\n            return true;\n    } else {\n        Tuple<String, String> specTuple = new Tuple<String, String>(array[0], array[1]);\n        if (getCache().get(CacheEntry.SPECTRUM_IDENTIFIED, specTuple) != null)\n            return true;\n    }\n    return false;\n}","421":"@Override\npublic int getNumberOfIdentifiedSpectra() {\n    Map<Comparable, List<Comparable>> spectraDataIdMap = (Map<Comparable, List<Comparable>>) getCache().get(CacheEntry.SPECTRADATA_TO_SPECTRUMIDS);\n    int countSpectra = 0;\n    if (spectraDataIdMap != null) {\n        Iterator iterator = spectraDataIdMap.entrySet().iterator();\n        while (iterator.hasNext()) {\n            Map.Entry mapEntry = (Map.Entry) iterator.next();\n            if (mapEntry != null && mapEntry.getValue() != null)\n                countSpectra += ((List<Comparable>) mapEntry.getValue()).size();\n        }\n    }\n    return countSpectra;\n}","422":"\/**\n * For the moment, MzXmlCacheBuilder only caches spectrum ids and chromatogram ids.\n *\/\n@Override\npublic void cache() {\n    \/\/ get a direct reference to unmarshaller\n    MzXmlUnmarshallerAdaptor unmarshaller = ((MzXmlControllerImpl) controller).getUnmarshaller();\n    \/\/ clear and add spectrum ids\n    cache.clear(CacheEntry.SPECTRUM_ID);\n    cache.storeInBatch(CacheEntry.SPECTRUM_ID, new ArrayList<Comparable>(unmarshaller.getSpectrumIds()));\n}","423":"\/**\n * For the moment, MzXmlCacheBuilder only caches spectrum ids and chromatogram ids.\n *\/\n@Override\npublic void cache() {\n    \/\/ get a direct reference to unmarshaller\n    MzDataUnmarshallerAdaptor unmarshaller = ((MzDataControllerImpl) controller).getUnmarshaller();\n    \/\/ clear and add spectrum ids\n    cache.clear(CacheEntry.SPECTRUM_ID);\n    cache.storeInBatch(CacheEntry.SPECTRUM_ID, new ArrayList<Comparable>(unmarshaller.getSpectrumIds()));\n}","424":"@Override\npublic Collection getInBatch(CacheEntry type, Collection keys) {\n    Collection<Object> results = new ArrayList<Object>();\n    for (Object key : keys) {\n        Object val = retrieveContent(type, key);\n        if (val != null) {\n            results.add(val);\n        }\n    }\n    return results;\n}","425":"public static CvParam parseQuantitationReagentCvParam(Param quantificationReagent) {\n    if (quantificationReagent != null) {\n        if (quantificationReagent.getAccession() != null && QuantCvTermReference.getCvRefByAccession(quantificationReagent.getAccession()) != null) {\n            QuantCvTermReference cvTerm = QuantCvTermReference.getCvRefByAccession(quantificationReagent.getAccession());\n            return new CvParam(cvTerm.getAccession(), cvTerm.getName(), cvTerm.getCvLabel(), quantificationReagent.getValue(), null, null, null);\n        } else if (quantificationReagent.getAccession() != null && QuantCvTermReference.getReagentByShortAccessionLabel(quantificationReagent.getAccession()) != null) {\n            QuantCvTermReference cvTerm = QuantCvTermReference.getReagentByShortAccessionLabel(quantificationReagent.getAccession());\n            return new CvParam(cvTerm.getAccession(), cvTerm.getName(), cvTerm.getCvLabel(), quantificationReagent.getValue(), null, null, null);\n        }\n    }\n    return null;\n}","426":"\/**\n * Retrieve the Spectrum File format for an specific fileformat.\n *\n * @param fileFormat file format such mgf ms2, mzid or other file formats\n * @return the SpectrumFile format such as MZXML or PKL\n *\/\npublic static SpecFileFormat getSpecFileFormat(String fileFormat) {\n    if (fileFormat != null && fileFormat.length() > 0) {\n        if (SpecFileFormat.MZXML.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.MZXML;\n        if (SpecFileFormat.DTA.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.DTA;\n        if (SpecFileFormat.MGF.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.MGF;\n        if (SpecFileFormat.APL.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.APL;\n        if (SpecFileFormat.MZDATA.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.MZDATA;\n        if (SpecFileFormat.MZML.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.MZML;\n        if (SpecFileFormat.PKL.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.PKL;\n        if (SpecFileFormat.MS2.toString().equalsIgnoreCase(fileFormat))\n            return SpecFileFormat.MS2;\n    }\n    return SpecFileFormat.NONE;\n}","427":"public static SpecFileFormat getSpecFileFormatFromLocation(String path) {\n    if (path != null && path.length() > 0) {\n        if (path.toUpperCase().contains(MZXML_EXT.toUpperCase()))\n            return SpecFileFormat.MZXML;\n        if (path.toUpperCase().contains(DTA_EXT.toUpperCase()))\n            return SpecFileFormat.DTA;\n        if (path.toUpperCase().contains(MGF_EXT.toUpperCase()))\n            return SpecFileFormat.MGF;\n        if (path.toUpperCase().contains(XML_EXT.toUpperCase()))\n            return SpecFileFormat.MZDATA;\n        if (path.toUpperCase().contains(MZML_EXT.toUpperCase()))\n            return SpecFileFormat.MZML;\n        if (path.toUpperCase().contains(APL_EXT.toUpperCase()))\n            return SpecFileFormat.APL;\n        if (path.toUpperCase().contains(PKL_EXT.toUpperCase()))\n            return SpecFileFormat.PKL;\n        if (path.toUpperCase().contains(MS2_EXT.toUpperCase()))\n            return SpecFileFormat.MS2;\n    }\n    return SpecFileFormat.NONE;\n}","428":"public static Constants.SpecFileFormat getSpectraDataFormat(SpectraData spectraData) {\n    uk.ac.ebi.pride.utilities.data.core.CvParam specFileFormat = spectraData.getFileFormat();\n    if (specFileFormat != null) {\n        if (specFileFormat.getAccession().equals(\"MS:1000613\"))\n            return Constants.SpecFileFormat.DTA;\n        if (specFileFormat.getAccession().equals(\"MS:1001062\"))\n            return Constants.SpecFileFormat.MGF;\n        if (specFileFormat.getAccession().equals(\"MS:1000565\"))\n            return Constants.SpecFileFormat.PKL;\n        if (specFileFormat.getAccession().equals(\"MS:1002996\"))\n            return SpecFileFormat.APL;\n        if (specFileFormat.getAccession().equals(\"MS:1000584\") || specFileFormat.getAccession().equals(\"MS:1000562\"))\n            return Constants.SpecFileFormat.MZML;\n        if (specFileFormat.getAccession().equals(\"MS:1000566\"))\n            return Constants.SpecFileFormat.MZXML;\n        if (specFileFormat.getAccession().equals(\"MS:1001466\"))\n            return Constants.SpecFileFormat.MS2;\n    }\n    return getDataFormatFromFileExtension(spectraData);\n}","429":"public static Constants.SpecIdFormat getSpectraDataIdFormat(String accession) {\n    if (accession.equals(\"MS:1001528\"))\n        return Constants.SpecIdFormat.MASCOT_QUERY_NUM;\n    if (accession.equals(\"MS:1000774\"))\n        return Constants.SpecIdFormat.MULTI_PEAK_LIST_NATIVE_ID;\n    if (accession.equals(\"MS:1000775\"))\n        return Constants.SpecIdFormat.SINGLE_PEAK_LIST_NATIVE_ID;\n    if (accession.equals(\"MS:1001530\"))\n        return Constants.SpecIdFormat.MZML_ID;\n    if (accession.equals(\"MS:1000776\"))\n        return Constants.SpecIdFormat.SCAN_NUMBER_NATIVE_ID;\n    if (accession.equals(\"MS:1000770\"))\n        return Constants.SpecIdFormat.WIFF_NATIVE_ID;\n    if (accession.equals(\"MS:1000777\"))\n        return Constants.SpecIdFormat.MZDATA_ID;\n    if (accession.equals((\"MS:1000768\")))\n        return Constants.SpecIdFormat.SPECTRUM_NATIVE_ID;\n    if (accession.equals(\"MS:1000796\"))\n        return SpecIdFormat.WIFF_MGF_TITLE;\n    return Constants.SpecIdFormat.NONE;\n}","430":"public int size() {\n    int cnt = 0;\n    for (Object anOriginalList : this.originalList) {\n        if (clazz.isInstance(anOriginalList)) {\n            cnt++;\n        }\n    }\n    return cnt;\n}","431":"public boolean isEmpty() {\n    boolean em = false;\n    for (Object anOriginalList : this.originalList) {\n        Object o = anOriginalList;\n        if (clazz.isInstance(o)) {\n            em = true;\n            break;\n        }\n    }\n    return em;\n}","432":"public int indexOf(Object o) {\n    checkArgument(o);\n    int cnt = 0;\n    for (Object anOriginalList : this.originalList) {\n        if (clazz.isInstance(anOriginalList)) {\n            if (o.equals(anOriginalList)) {\n                return cnt;\n            }\n            cnt++;\n        }\n    }\n    return -1;\n}","433":"public static List<SearchEngineParam> getSearchEngineCvTermReferences(List<CvParam> cvParams) {\n    if (cvParams == null) {\n        throw new IllegalArgumentException(\"Input argument for getSearchEngineScoreTypes can not be null\");\n    }\n    List<SearchEngineParam> searchEngines = new ArrayList<SearchEngineParam>();\n    for (CvParam param : cvParams) if (SearchEngineScoreParam.getSearchEngineScoreParamByAccession(param.getAccession()) != null) {\n        SearchEngineScoreParam searchEngineScoreParam = SearchEngineScoreParam.getSearchEngineScoreParamByAccession(param.getAccession());\n        SearchEngineParam seachEngine = searchEngineScoreParam.getSearchEngineParam();\n        searchEngines.add(seachEngine);\n    }\n    return searchEngines;\n}","434":"\/**\n * Get the number of valid sub samples\n *\n * @return int number of sub samples\n *\/\npublic int getNumberOfSubSamples() {\n    int cnt = 0;\n    for (SubSample sample : samples) {\n        if (sample != null) {\n            cnt++;\n        }\n    }\n    return cnt;\n}","435":"public CvParam getSpecies(int index) {\n    CvParam species = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            species = sample.getSpecies();\n        }\n    }\n    return species;\n}","436":"public void setSpecies(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index >= 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setSpecies(cvParam);\n    }\n}","437":"public CvParam getCellLine(int index) {\n    CvParam cellLine = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            cellLine = sample.getCellLine();\n        }\n    }\n    return cellLine;\n}","438":"public void setCellLine(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setCellLine(cvParam);\n    }\n}","439":"public CvParam getTissue(int index) {\n    CvParam tissue = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            tissue = sample.getTissue();\n        }\n    }\n    return tissue;\n}","440":"public void setTissue(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setTissue(cvParam);\n    }\n}","441":"public CvParam getReagent(int index) {\n    CvParam reagent = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            reagent = sample.getReagent();\n        }\n    }\n    return reagent;\n}","442":"public void setReagent(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setReagent(cvParam);\n    }\n}","443":"public CvParam getDisease(int index) {\n    CvParam disease = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            disease = sample.getDisease();\n        }\n    }\n    return disease;\n}","444":"public void setDisease(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setDisease(cvParam);\n    }\n}","445":"public CvParam getGOTerm(int index) {\n    CvParam goTerm = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            goTerm = sample.getGoTerm();\n        }\n    }\n    return goTerm;\n}","446":"public void setGOTerm(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getValue());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setGoTerm(cvParam);\n    }\n}","447":"public CvParam getDescription(int index) {\n    CvParam description = null;\n    if (index >= 0 && index < MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample != null) {\n            description = sample.getDescription();\n        }\n    }\n    return description;\n}","448":"public void setDescription(CvParam cvParam) {\n    int index = getSubSampleIndex(cvParam.getName());\n    if (index > 0 && index <= MAX_SUB_SAMPLE_SIZE) {\n        SubSample sample = samples[index - 1];\n        if (sample == null) {\n            sample = new SubSample(index);\n            samples[index - 1] = sample;\n        }\n        sample.setDescription(cvParam);\n    }\n}","449":"private int getSubSampleIndex(String value) {\n    int index = -1;\n    if (value != null) {\n        Matcher m = SUB_SAMPLE_PATTERN.matcher(value);\n        if (m.matches()) {\n            index = Integer.parseInt(m.group(1));\n        }\n    }\n    return index;\n}","450":"public List<Double> getLabelFreeResults(Collection<QuantCvTermReference> types) {\n    List<Double> results = new ArrayList<Double>();\n    if (labelFreeResults != null) {\n        for (QuantCvTermReference quantCvTermReference : types) {\n            Double val = labelFreeResults.get(quantCvTermReference);\n            results.add(val);\n        }\n    }\n    return results;\n}","451":"public double getDefaultScore() {\n    Object[] scoresArray = scores.values().toArray();\n    Object[] scoresArrayValue = ((Map<SearchEngineScoreCvTermReference, Number>) scoresArray[0]).values().toArray();\n    double scoreValue = -1;\n    for (Object aScoresArrayValue : scoresArrayValue) {\n        if (aScoresArrayValue != null) {\n            scoreValue = ((Double) aScoresArrayValue);\n            return scoreValue;\n        }\n    }\n    return scoreValue;\n}","452":"\/**\n * This is the method should use to instantiate fastMzIdentMLUnmarshaller object. This method is\n * thread safe and also do a lazy loading because of two reasons: 1. XML parsing from mzIdentML\n * file is a memory intensive task 2. MzIdentML is an object with high memory consumption\n *\n * @param mzIdentMLFile Input MzIdentML file with .mzid extension\n * @return FastMzIdentMLUnmarshaller\n *\/\npublic static FastMzIdentMLUnmarshaller getInstance(File mzIdentMLFile) {\n    try {\n        if (fastMzIdentMLUnmarshaller == null) {\n            synchronized (FastMzIdentMLUnmarshaller.class) {\n                if (fastMzIdentMLUnmarshaller == null) {\n                    fastMzIdentMLUnmarshaller = new FastMzIdentMLUnmarshaller(mzIdentMLFile);\n                }\n            }\n        }\n    } catch (Exception e) {\n        log.error(\"mzIdentML file access error : \" + e.getMessage());\n    }\n    return fastMzIdentMLUnmarshaller;\n}","453":"public int getNumberOfUniquePeptides() {\n    Collection<Comparable> peptideIds = getPeptideIds();\n    HashSet<String> peptideSeq = new HashSet();\n    if (peptideIds != null && !peptideIds.isEmpty()) {\n        for (Comparable peptideId : peptideIds) {\n            Peptide peptide = getPeptideById(peptideId);\n            if (peptide != null && peptide.getPeptideSequence() != null)\n                peptideSeq.add(peptide.getPeptideSequence());\n        }\n    }\n    return peptideSeq.size();\n}","454":"public List<Double> getPTMMassesFromPeptide(Peptide peptide) {\n    List<Double> ptmMasses = new ArrayList<>();\n    for (Modification modification : peptide.getModification()) {\n        List<CvParam> cvParams = modification.getCvParam();\n        for (CvParam cvParam : cvParams) {\n            checkCvParam(cvParam);\n        }\n        double monoMasses = modification.getMonoisotopicMassDelta();\n        ptmMasses.add(monoMasses);\n    }\n    return ptmMasses;\n}","455":"public Map<Comparable, SpectraData> getSpectraDataMap() {\n    Inputs inputs = fastMzIdentMLUnmarshaller.getMzIdentML().getDataCollection().getInputs();\n    List<SpectraData> spectraDataList = inputs.getSpectraData();\n    Map<Comparable, SpectraData> spectraDataMap = null;\n    if (spectraDataList != null && spectraDataList.size() > 0) {\n        spectraDataMap = new HashMap<>();\n        for (SpectraData spectraData : spectraDataList) {\n            spectraDataMap.put(spectraData.getId(), spectraData);\n        }\n    }\n    return spectraDataMap;\n}","456":"public String getVersion() {\n    String version = fastMzIdentMLUnmarshaller.getMzIdentML().getVersion();\n    if (!version.matches(Constants.VERSION_NUMBER)) {\n        try {\n            throw new Exception(\"Invalid MzIdentML Version found!\");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    return version;\n}","457":"public Date getCreationDate() throws Exception {\n    Date dateCreation = null;\n    String dateInString = fastMzIdentMLUnmarshaller.getMzIdentML().getCreationDate();\n    try {\n        if (dateInString != \"\") {\n            Calendar calendar = javax.xml.bind.DatatypeConverter.parseDateTime(dateInString);\n            dateCreation = calendar.getTime();\n        }\n    } catch (Exception ex) {\n        throw new Exception(\"Failed to convert creationDate attribute of the MzIdentML Element\", ex);\n    }\n    return dateCreation;\n}","458":"\/**\n * Sets the path settings and returns null.\n *\n * @return null\n *\/\npublic Object call() {\n    waitingHandler = new WaitingHandlerCLIImpl();\n    setPathSettings();\n    if (!waitingHandler.isRunCanceled()) {\n        System.exit(0);\n        return 0;\n    } else {\n        System.exit(1);\n        return 1;\n    }\n}","459":"public static void redirectErrorStream(File aLogFolder) {\n    logFolder = aLogFolder;\n    try {\n        aLogFolder.mkdirs();\n        File file = new File(aLogFolder, \"compomics-utilities.log\");\n        System.setErr(new java.io.PrintStream(new FileOutputStream(file, true)));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}","460":"\/**\n * Returns a concatenation of the streams of the given collections. If a\n * collection is null it is ignored. Returns null if all collections are\n * null.\n *\n * @param <T> the collections\n * @param collections the collections\n *\n * @return the concatenated stream\n *\/\npublic static <T> Stream<T> concatenate(Collection<T>... collections) {\n    Stream<T> result = null;\n    for (Collection<T> collection : collections) {\n        if (collection != null) {\n            result = result == null ? collection.stream() : Stream.concat(result, collection.stream());\n        }\n    }\n    return result;\n}","461":"public DasFeature[] getAllFeatures() {\n    Vector feats = new Vector();\n    while (iXml.indexOf(\"<FEATURE\", lastFeatureEndPosition + 9) != -1) {\n        String feature = iXml.substring(iXml.indexOf(\"<FEATURE\", lastFeatureEndPosition + 9), iXml.indexOf(\"<\/FEATURE>\", lastFeatureEndPosition + 9) + 10);\n        lastFeatureEndPosition = iXml.indexOf(\"<\/FEATURE>\", lastFeatureEndPosition + 9);\n        if (feature.indexOf(\"<NOTE>No features found for the segment<\/NOTE>\") < 0) {\n            DasFeature f = new DasFeature(feature);\n            feats.add(f);\n        }\n    }\n    DasFeature[] features = new DasFeature[feats.size()];\n    feats.toArray(features);\n    return features;\n}","462":"\/**\n * Acquires.\n *\/\npublic void acquire() {\n    try {\n        mutex.acquire();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}","463":"public void release() {\n    try {\n        mutex.release();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}","464":"public static String getExceptionType(Exception e) {\n    if (e.getLocalizedMessage() == null) {\n        return \"null pointer\";\n    } else if (e.getLocalizedMessage().startsWith(\"Protein not found\")) {\n        return \"Protein not found\";\n    } else if (e.getLocalizedMessage().startsWith(\"Error while loading\") || e.getLocalizedMessage().startsWith(\"Error while writing\")) {\n        return \"Serialization\";\n    } else {\n        return e.getLocalizedMessage();\n    }\n}","465":"public String toString() {\n    StringBuffer lsb = new StringBuffer(\"\\n\\t\/**\\n\\t * This variable tracks changes to the object.\\n\\t *\/\\n\\tprotected boolean iUpdated = false;\\n\\n\");\n    lsb.append(\"\\t\/**\\n\\t * This variable can hold generated primary key columns.\\n\\t *\/\\n\\tprotected Object[] iKeys = null;\\n\\n\");\n    for (int i = 0; i < iVars.length; i++) {\n        lsb.append(iVars[i] + \"\\n\\n\");\n    }\n    return lsb.toString() + \"\\n\";\n}","466":"public String toString() {\n    StringBuffer lsb = new StringBuffer(\"\\n\");\n    for (int i = 0; i < iGetters.length; i++) {\n        lsb.append(iGetters[i] + \"\\n\\n\");\n    }\n    for (int i = 0; i < iSetters.length; i++) {\n        lsb.append(iSetters[i] + \"\\n\\n\");\n    }\n    return lsb.toString() + \"\\n\";\n}","467":"public int getCodedColumnType(String aColumnName) {\n    int result = -1;\n    for (int i = 0; i < iColumns.length; i++) {\n        String lColumn = iColumns[i].trim();\n        if (aColumnName.trim().equalsIgnoreCase(lColumn)) {\n            result = iColTypes[i];\n            break;\n        }\n    }\n    return result;\n}","468":"public int getColumnSize(String aColumnName) {\n    int result = -1;\n    for (int i = 0; i < iColumns.length; i++) {\n        String lColumn = iColumns[i].trim();\n        if (aColumnName.trim().equalsIgnoreCase(lColumn)) {\n            result = iColSizes[i];\n            break;\n        }\n    }\n    return result;\n}","469":"public String getConvertedColumnType(String aColumnName) {\n    String result = null;\n    for (int i = 0; i < iColumns.length; i++) {\n        String lColumn = iColumns[i].trim();\n        if (aColumnName.trim().equalsIgnoreCase(lColumn)) {\n            result = iConColTypes[i];\n            break;\n        }\n    }\n    return result;\n}","470":"\/**\n * Committing all changes into the database.\n *\/\npublic void commit() {\n    try {\n        dbMutex.acquire();\n        connection.commit();\n    } catch (Exception e) {\n    } finally {\n        dbMutex.release();\n    }\n}","471":"public void unlock() {\n    dbMutex.acquire();\n    if (debugInteractions) {\n        System.out.println(\"unlocking database\");\n    }\n    connectionActive = true;\n    dbMutex.release();\n}","472":"public Object getObject(long objectKey) {\n    Object object = null;\n    loadObjectMutex.acquire();\n    if (loadedObjects.containsKey(objectKey)) {\n        object = loadedObjects.get(objectKey).object;\n    }\n    loadObjectMutex.release();\n    return object;\n}","473":"private void updateCache() {\n    int cacheSize = getCacheSize();\n    while (cacheSize > keepObjectsThreshold && !memoryCheck()) {\n        int toRemove = cacheSize >> 2;\n        saveObjects(toRemove, null, true);\n        cacheSize = getCacheSize();\n    }\n}","474":"public void saveCache(WaitingHandler waitingHandler, boolean emptyCache) {\n    if (waitingHandler != null) {\n        waitingHandler.resetSecondaryProgressCounter();\n        waitingHandler.setMaxSecondaryProgressCounter(loadedObjects.size() + 1);\n    }\n    int cacheSize = getCacheSize();\n    saveObjects(cacheSize, waitingHandler, emptyCache);\n    if (waitingHandler != null) {\n        waitingHandler.setSecondaryProgressCounterIndeterminate(true);\n    }\n}","475":"public void startGenerator(String aDriver, String aUrl, String aTable, String aUser, String aPassword, String aPackageName, boolean aDebug) throws GeneratorException {\n    Connection lConn = this.getConnection(aDriver, aUrl, aUser, aPassword);\n    DBMetaData dbmd = this.getMetaData(lConn, aTable);\n    if (aDebug) {\n        System.out.println(\"\\n\\n\" + dbmd.toString() + \"\\n\");\n    }\n    try {\n        lConn.close();\n    } catch (Exception e) {\n        System.err.println(e.getMessage());\n    }\n    this.generateAccessor(dbmd, aPackageName, aDebug);\n}","476":"public boolean equals(Object o) {\n    boolean result = false;\n    if (o instanceof Protein) {\n        Protein p = (Protein) o;\n        if ((p.iHeader.getFullHeaderWithAddenda().equals(this.iHeader.getFullHeaderWithAddenda())) && (p.iSequence.getModifiedSequence().equals(this.iSequence.getModifiedSequence())) && (p.iTruncated == this.iTruncated) && (p.iTruncationPosition == this.iTruncationPosition)) {\n            result = true;\n        }\n    }\n    return result;\n}","477":"\/**\n * Simple setter for the sequence. It also clears the mass cache.\n *\n * @param\taSequence\tString with the sequence to be set.\n *\/\npublic void setSequence(String aSequence) {\n    \/\/ Nullpointer check.\n    if (aSequence == null) {\n        throw new NullPointerException(\"Sequence cannot be 'null'!\\n\");\n    } else if (aSequence.trim().equals(\"\")) {\n        throw new IllegalArgumentException(\"Sequence cannot be empty String!\\n\");\n    }\n    this.iSequence = aSequence.trim();\n    this.iMass = -1.0;\n    this.iGravyCached = false;\n    this.iMeekCached = false;\n}","478":"public String toString() {\n    String lResult = \"\";\n    for (MolecularElement lMolecularElement : MolecularElement.values()) {\n        int lCount = this.getElementCount(lMolecularElement);\n        if (lCount > 0) {\n            lResult = lResult + lMolecularElement + this.getElementCount(lMolecularElement) + \" \";\n        }\n    }\n    return lResult;\n}","479":"\/**\n * This method allows the caller to specify the cleavable residues.\n *\n * @param   aCleavage   char[] with the cleavable residues\n *                      (in <b>UPPER CASE<\/b>!).\n *\/\npublic void setCleavage(char[] aCleavage) {\n    super.setCleavage(aCleavage);\n    if (aCleavage != null) {\n        iNtermCleavables = new HashMap(aCleavage.length);\n        iCtermCleavables = new HashMap(aCleavage.length);\n        for (int i = 0; i < aCleavage.length; i++) {\n            iNtermCleavables.put(Character.valueOf(aCleavage[i]), \"1\");\n            iCtermCleavables.put(Character.valueOf(aCleavage[i]), \"1\");\n        }\n    } else {\n        iNtermCleavables = new HashMap();\n        iCtermCleavables = new HashMap();\n    }\n}","480":"public String toString(String aPrepend) {\n    StringBuffer result = new StringBuffer(\"\\n\" + aPrepend + \"Hi, I'm the DualEnzyme '\" + this.getTitle() + \"'.\\n\");\n    result.append(aPrepend + \"I cleave at the sight of:\\n\");\n    result.append(aPrepend + \"\\t- Nterminal: '\" + new String(this.getCleavage(DualEnzyme.NTERMINAL)) + \"'.\\n\");\n    result.append(aPrepend + \"\\t- Cterminal: '\" + new String(this.getCleavage(DualEnzyme.CTERMINAL)) + \"'.\\n\");\n    if (this.getRestrict() != null && this.getRestrict().length > 0) {\n        result.append(aPrepend + \"My activity is restricted by these residus: '\" + new String(this.getRestrict()) + \"'.\\n\");\n    } else {\n        result.append(aPrepend + \"There are no residus that restrict my activity.\\n\");\n    }\n    result.append(aPrepend + \"My position is '\" + ((this.getPosition() == Enzyme.CTERM) ? \"C-terminal\" : \"N-terminal\") + \"'.\\n\");\n    result.append(aPrepend + \"I currently allow \" + ((this.getMiscleavages() == 0) ? \"no\" : \"up to \" + this.getMiscleavages()) + \" missed cleavage\" + ((this.getMiscleavages() == 1) ? \"\" : \"s\") + \".\\n\");\n    return result.toString();\n}","481":"private boolean isCleavable(char[] aSequence, int aPosition, HashMap aCleavables, HashMap aRestrictors) {\n    boolean cleavable = false;\n    if (aPosition >= aSequence.length || aPosition < 0) {\n        throw new IllegalArgumentException(\"Your position (\" + aPosition + \") was outside of sequence boundaries (0, \" + (aSequence.length - 1) + \")!\");\n    }\n    if (aCleavables.containsKey(Character.valueOf(aSequence[aPosition]))) {\n        if ((aPosition + 1 < aSequence.length) && aRestrictors.containsKey(Character.valueOf(aSequence[aPosition + 1]))) {\n            cleavable = false;\n        } else {\n            cleavable = true;\n        }\n    }\n    return cleavable;\n}","482":"public static double[] scaleToMax(double[] values, boolean percent) {\n    double maxValue = Arrays.stream(values).max().orElse(1.0);\n    return scaleValues(values, maxValue, percent);\n}","483":"\/**\n * This method will read a Properties file from the current ClassLoader\n * and return a Properties instance with the Properties from the file. <br>\n * Note: if this doesn't succeed, it'll throw an IllegalArgumentException with\n * some information.\n *\n * @param   aFilename   String with the filename to locate.\n * @return  Properties  instance with the props (or IllegalArgumentException if\n *                      the specified file was not found in the classpath!)\n *\/\npublic static Properties getPropertiesFile(String aFilename) throws IllegalArgumentException {\n    Properties props = new Properties();\n    try {\n        ClassLoader cl = TestCaseLM.class.getClassLoader();\n        InputStream is = cl.getResourceAsStream(aFilename);\n        if (is == null) {\n            throw new IllegalArgumentException(\"File '\" + aFilename + \"' was not found in the classpath!\");\n        } else {\n            props.load(is);\n            is.close();\n        }\n    } catch (IOException ioe) {\n        throw new IllegalArgumentException(\"IOException for file '\" + aFilename + \"': \" + ioe.getMessage());\n    }\n    return props;\n}","484":"public Object get() {\n    while (true) {\n        Thread t = threadVar.get();\n        if (t == null) {\n            return getValue();\n        }\n        try {\n            t.join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            return null;\n        }\n    }\n}","485":"public boolean isSameAs(FractionParameters fractionSettings) {\n    if (!proteinConfidenceMwPlots.equals(fractionSettings.getProteinConfidenceMwPlots())) {\n        return false;\n    }\n    if (this.getFractionMolecularWeightRanges() != null && fractionSettings.getFractionMolecularWeightRanges() != null) {\n        if (!this.getFractionMolecularWeightRanges().equals(fractionSettings.getFractionMolecularWeightRanges())) {\n            return false;\n        }\n    }\n    if ((this.getFractionMolecularWeightRanges() != null && fractionSettings.getFractionMolecularWeightRanges() == null) || (this.getFractionMolecularWeightRanges() == null && fractionSettings.getFractionMolecularWeightRanges() != null)) {\n        return false;\n    }\n    return true;\n}","486":"\/**\n * Returns a short description of the parameters.\n *\n * @return a short description of the parameters\n *\/\npublic String getShortDescription() {\n    String newLine = System.getProperty(\"line.separator\");\n    StringBuilder output = new StringBuilder();\n    output.append(\"Simplify Groups: \").append(getSimplifyGroups()).append(newLine);\n    output.append(\"Simplify on protein evidence: \").append(getSimplifyGroupsEvidence()).append(newLine);\n    output.append(\"Simplify on peptide confidence: \").append(getSimplifyGroupsEvidence()).append(newLine);\n    output.append(\"Peptide confidence threshold: \").append(getConfidenceThreshold()).append(newLine);\n    output.append(\"Simplify on peptide enzymaticity: \").append(getSimplifyGroupsEnzymaticity()).append(newLine);\n    output.append(\"Simplify on peptide variants: \").append(getSimplifyGroupsEnzymaticity()).append(newLine);\n    return output.toString();\n}","487":"public String getShortDescription() {\n    String newLine = System.getProperty(\"line.separator\");\n    StringBuilder output = new StringBuilder();\n    output.append(\"Protein FDR: \").append(defaultProteinFDR).append(\".\").append(newLine);\n    output.append(\"Peptide FDR: \").append(defaultPeptideFDR).append(\".\").append(newLine);\n    output.append(\"PSM FDR: \").append(defaultPsmFDR).append(\".\").append(newLine);\n    return output.toString();\n}","488":"\/**\n * Translate a DNA sequence into 6 reading frames.\n *\n * @param args the DNA sequence to translate\n *\/\npublic static void main(String[] args) {\n    if (args == null || args.length == 0) {\n        logger.error(\"\\n\\nUsage:\\n\\tTranslate <DNA_sequence>\");\n        System.exit(1);\n    }\n    \/\/ Create a NucleotideSequenceImpl.\n    NucleotideSequenceImpl nsi = new NucleotideSequenceImpl(args[0]);\n    AASequenceImpl[] seqs = nsi.translate();\n    for (int i = 0; i < seqs.length; i++) {\n        AASequenceImpl lSeq = seqs[i];\n        logger.info(lSeq.getSequence());\n    }\n}","489":"public void close() {\n    try {\n        this.iOut.flush();\n        this.iOut.close();\n        this.iOut = null;\n    } catch (IOException ioe) {\n        logger.error(ioe.getMessage(), ioe);\n    }\n}","490":"private void writeOutput(HttpServletResponse aRes, String aSequence, double aMass) throws IOException {\n    PrintWriter out = aRes.getWriter();\n    out.println(\"<html>\");\n    out.println(\"\t<head><title>Mass for \" + aSequence + \"<\/title><\/head>\");\n    out.println(\"\t<body>\");\n    out.println(\"\t\t<h1>Mass calculation results<\/h1>\");\n    out.println(\"\t\t<hr \/><br \/><br \/><br \/>\");\n    out.println(\"\t\t<h3>Mass was: <font color=\\\"blue\\\">\" + aMass + \"<\/font> Da.<\/h3>\");\n    out.println(\"\t\t<br \/><br \/>\");\n    out.println(\"\t\t<h4>Sequence was:<h4>\");\n    out.println(\"\t\t<font color=\\\"green\\\">\" + aSequence + \"<\/font>\");\n    out.println(\"\t<\/body>\");\n    out.println(\"<\/html>\");\n    out.flush();\n    out.close();\n}","491":"private void handleError(HttpServletResponse aRes, String aSequence, UnknownElementMassException aUem) throws IOException {\n    PrintWriter out = aRes.getWriter();\n    out.println(\"<html>\");\n    out.println(\"\t<head><title>Unknown element '\" + aUem.getElement() + \"' encountered!<\/title><\/head>\");\n    out.println(\"\t<body>\");\n    out.println(\"\t\t<font color=\\\"red\\\"><h1>Unknown element '\" + aUem.getElement() + \"' encountered!<\/h1><\/font>\");\n    out.println(\"\t\tDid you type the case correctly according to IUPAC standards? <br \/>\");\n    out.println(\"\t\tDid you type amino acid one letter code and in UPPERCASE?\");\n    out.println(\"\t\t<br \/><br \/><hr \/><br \/><br \/>\");\n    aUem.printStackTrace(out);\n    out.println(\"\t<\/body>\");\n    out.println(\"<\/html>\");\n    out.flush();\n    out.close();\n}","492":"private HashMap parseSelfList(String aList) throws Exception {\n    HashMap toReturn = new HashMap();\n    aList = aList.trim();\n    StringTokenizer st = new StringTokenizer(aList, \" =_:\\n\");\n    while (st.hasMoreTokens()) {\n        String key = st.nextToken();\n        Double value = Double.valueOf(st.nextToken());\n        toReturn.put(key, value);\n    }\n    return toReturn;\n}","493":"public boolean hasFlag(String aFlag) {\n    boolean present = false;\n    if (iFlags != null) {\n        for (int i = 0; i < iFlags.length; i++) {\n            String lFlag = iFlags[i];\n            if (lFlag.equals(aFlag)) {\n                present = true;\n                break;\n            }\n        }\n    }\n    return present;\n}","494":"private void parseCommandLine() {\n    if ((iCommandLine == null) || (iCommandLine.length == 0)) {\n        iHasArgs = false;\n    } else {\n        iHasArgs = true;\n        this.parseFlags();\n        this.parseOptions();\n        this.parseParameters();\n    }\n}","495":"public double getHighestIntensity() {\n    Iterator iter = this.iPeaks.values().iterator();\n    double highestIntensity = -1.0;\n    while (iter.hasNext()) {\n        double temp = (Double) iter.next();\n        if (temp > highestIntensity) {\n            highestIntensity = temp;\n        }\n    }\n    return round(highestIntensity);\n}","496":"private double getInnerFormulaMass(StringCharacterIterator aSCI) throws UnknownElementMassException {\n    int multiplicity;\n    String inner = this.isolateInnerPartString(aSCI, '(', ')', false);\n    double mass = this.calculateMass(inner);\n    multiplicity = this.getMultiplicity(aSCI);\n    mass *= multiplicity;\n    return mass;\n}","497":"\/**\n *  Prepares the renderer by querying the data model for the\n *  value and selection state\n *  of the cell at <code>row<\/code>, <code>column<\/code>.\n *  Returns the component (may be a <code>Component<\/code>\n *  or a <code>JComponent<\/code>) under the event location.\n *\n *  @param renderer  the <code>TableCellRenderer<\/code> to prepare\n *  @param rowIndex  the row of the cell to render, where 0 is the first row\n *  @param vColIndex the column of the cell to render,\n * \t\t\twhere 0 is the first column\n *  @return          the <code>Component<\/code> under the event location\n *\/\npublic Component prepareRenderer(TableCellRenderer renderer, int rowIndex, int vColIndex) {\n    Component c = super.prepareRenderer(renderer, rowIndex, vColIndex);\n    if (!isCellSelected(rowIndex, vColIndex)) {\n        if ((rowIndex + 1) % 2 == 0) {\n            if (iEvenRowColor == null) {\n                c.setBackground(getBackground());\n            } else {\n                c.setBackground(iEvenRowColor);\n            }\n        } else {\n            if (iUnevenRowColor == null) {\n                c.setBackground(getBackground());\n            } else {\n                c.setBackground(iUnevenRowColor);\n            }\n        }\n    }\n    return c;\n}","498":"public void addUrParam(UrParameter parameter) {\n    if (urParams == null) {\n        createParamsMap();\n    }\n    urParams.put(parameter.getParameterKey(), parameter);\n}","499":"public static long asLong(String key) {\n    long longKey = 0;\n    char[] keyAsArray = key.toCharArray();\n    for (int i = 0; i < keyAsArray.length; ++i) {\n        long val = HASHVALUELIST[keyAsArray[i]];\n        int sft = ((i * 11) & 63);\n        val = (val << sft) | (val >>> (64 - sft));\n        longKey ^= val;\n    }\n    return longKey;\n}","500":"\/**\n * Static method to get an instance of the factory. Attempts to load the\n * factory from the file set in the path preferences. If any exception\n * occurs it is ignored silently and defaults are used.\n *\n * @return the factory instance\n *\/\npublic static EnzymeFactory getInstance() {\n    if (instance == null) {\n        try {\n            File savedFile = new File(SERIALIZATION_FILE_FOLDER, SERIALIZATION_FILE_NAME);\n            instance = loadFromFile(savedFile);\n            sortedEnzymeNames = null;\n        } catch (Exception e) {\n            setDefaultEnzymes();\n            sortedEnzymeNames = null;\n        }\n    }\n    return instance;\n}","501":"public void remove(Atom atom, Integer isotope) {\n    ArrayList<AtomImpl> newAtomChain = new ArrayList<>(atomChain.size());\n    AtomImpl atom1 = new AtomImpl(atom, isotope);\n    for (AtomImpl atom2 : atomChain) {\n        if (!atom1.isSameAs(atom2)) {\n            newAtomChain.add(atom2);\n        }\n    }\n    atomChain = newAtomChain;\n    mass = -1.0;\n    stringValue = null;\n}","502":"public String toString(boolean isotopeCurlyBrackets) {\n    Atom tempAtom = Atom.getAtom(atomSymbol);\n    if (isotope == 0) {\n        return tempAtom.getLetter();\n    } else {\n        if (getMass() == null) {\n            throw new UnsupportedOperationException(\"Isotope \" + isotope + \" not implemented for atom \" + tempAtom + \".\");\n        }\n        if (isotopeCurlyBrackets) {\n            return tempAtom.getLetter() + \"{\" + Math.round(getMass()) + \"}\";\n        } else {\n            return Math.round(getMass()) + tempAtom.getLetter();\n        }\n    }\n}","503":"public HashMap<String, HashSet<Integer>> getEnsembleSpecies() {\n    HashMap<String, HashSet<Integer>> speciesMap = new HashMap<>(EnsemblGenomeDivision.values().length + 1);\n    for (Integer taxon : ensemblGenomesSpecies.getTaxons()) {\n        String divisionName = ensemblGenomesSpecies.getDivision(taxon).ensemblType;\n        HashSet<Integer> taxons = speciesMap.get(divisionName);\n        if (taxons == null) {\n            taxons = new HashSet<>();\n            speciesMap.put(divisionName, taxons);\n        }\n        taxons.add(taxon);\n    }\n    speciesMap.put(\"vertebrates\", ensemblSpecies.getTaxons());\n    return speciesMap;\n}","504":"public int getAaNumber(int peptideLength) {\n    switch(subType) {\n        case PeptideFragmentIon.A_ION:\n        case PeptideFragmentIon.B_ION:\n        case PeptideFragmentIon.C_ION:\n            return number;\n        case PeptideFragmentIon.X_ION:\n        case PeptideFragmentIon.Y_ION:\n        case PeptideFragmentIon.Z_ION:\n            return peptideLength + 1 - number;\n        default:\n            throw new UnsupportedOperationException(\"Peptide fragment ion of type \" + subType + \" not implemented.\");\n    }\n}","505":"public static Integer getIonType(String ionSymbol) {\n    switch(ionSymbol) {\n        case \"a\":\n            return PeptideFragmentIon.A_ION;\n        case \"b\":\n            return PeptideFragmentIon.B_ION;\n        case \"c\":\n            return PeptideFragmentIon.C_ION;\n        case \"x\":\n            return PeptideFragmentIon.X_ION;\n        case \"y\":\n            return PeptideFragmentIon.Y_ION;\n        case \"z\":\n            return PeptideFragmentIon.Z_ION;\n    }\n    throw new UnsupportedOperationException(\"Ion of type \" + ionSymbol + \" not supported.\");\n}","506":"public static boolean isForward(int subType) {\n    switch(subType) {\n        case A_ION:\n        case B_ION:\n        case C_ION:\n            return true;\n        case X_ION:\n        case Y_ION:\n        case Z_ION:\n            return false;\n    }\n    throw new UnsupportedOperationException(\"Subtype: \" + subType + \" not found.\");\n}","507":"public static int[] getPossibleSubtypes() {\n    int[] possibleTypes = new int[21];\n    for (int i = 0; i <= 20; i++) {\n        possibleTypes[i] = i;\n    }\n    return possibleTypes;\n}","508":"public static String getChargeAsFormattedString(int value) {\n    if (value == 1) {\n        return \"\";\n    }\n    String temp = \"\";\n    for (int i = 0; i < Math.abs(value); i++) {\n        if (value > 0) {\n            temp += \"+\";\n        } else {\n            temp += \"-\";\n        }\n    }\n    return temp;\n}","509":"\/**\n * Adds a possible substitution.\n *\n * @param originalAa the original amino acid represented by its single\n * letter code\n * @param substitutionAa the substituted amino acid represented by its\n * single letter code\n *\/\npublic void addSubstitution(Character originalAa, Character substitutionAa) {\n    HashSet<Character> substitutedAas = substitutions.get(originalAa);\n    if (substitutedAas == null) {\n        substitutedAas = new HashSet<>();\n        substitutions.put(originalAa, substitutedAas);\n    }\n    substitutedAas.add(substitutionAa);\n    HashSet<Character> originalAas = reverseMap.get(originalAa);\n    if (originalAas == null) {\n        originalAas = new HashSet<>();\n        reverseMap.put(substitutionAa, originalAas);\n    }\n    originalAas.add(originalAa);\n}","510":"public void addFeature(Ms2pipFeature ms2pipFeature) {\n    String category = ms2pipFeature.getCategory();\n    Ms2pipFeature[] categoryFeatures = featuresMap.get(category);\n    categoryFeatures = Arrays.copyOf(categoryFeatures, categoryFeatures.length + 1);\n    categoryFeatures[categoryFeatures.length - 1] = ms2pipFeature;\n    featuresMap.put(category, categoryFeatures);\n    nFeatures++;\n}","511":"public static HashMap<String, HashSet<String>> getPeptideProteinMap(ArrayList<PeptideProteinMapping> peptideProteinMappings) {\n    return peptideProteinMappings.stream().collect(Collectors.groupingBy(PeptideProteinMapping::getPeptideSequence)).entrySet().stream().collect(Collectors.toMap(Entry::getKey, entry -> entry.getValue().stream().map(peptideProteinMapping -> peptideProteinMapping.getProteinAccession()).collect(Collectors.toCollection(HashSet::new)), (a, b) -> {\n        throw new IllegalStateException(\"Duplicate key in groupingBy.\");\n    }, HashMap::new));\n}","512":"public int getRankRecursive(int index, int character) {\n    if (index >= 0) {\n        int cell = character >>> BIT_SHIFT;\n        int pos = character & BIT_MASK;\n        boolean left = ((alphabetDirections[cell] >>> pos) & 1) == 1;\n        int result = rank.getRank(index, left);\n        if (left && leftChild != null) {\n            return leftChild.getRankRecursive(result - 1, character);\n        } else if (!left && rightChild != null) {\n            return rightChild.getRankRecursive(result - 1, character);\n        }\n        return result;\n    }\n    return 0;\n}","513":"public int select(int occurrence, int character) {\n    int L = 0, R = lenText - 1, m = -1;\n    while (R - L > 1) {\n        m = (L + R) >>> 1;\n        if (getRank(m, character) <= occurrence) {\n            L = m;\n        } else {\n            R = m;\n        }\n    }\n    return R;\n}","514":"public void setHeaderAsString(String header) {\n    byte[] headerBytes = header.getBytes();\n    this.uncompressedLength = headerBytes.length;\n    TempByteArray tempByteArray = ZstdUtils.zstdCompress(headerBytes);\n    headerAsCompressedString = Arrays.copyOf(tempByteArray.array, tempByteArray.length);\n}","515":"public IonMatch getPrecursorMatch(double precursorMz, double precursorIntensity) {\n    return new IonMatch(precursorMz, precursorIntensity, new PrecursorIon(getTheoreticMass()), getIdentificationCharge());\n}","516":"public void makeSequenceIndependant() {\n    for (String neutralLossName : forwardBoundaries.keySet()) {\n        forwardBoundaries.put(neutralLossName, 1);\n        rewindBoundaries.put(neutralLossName, 1);\n    }\n}","517":"public ArrayList<String> getAccountedNeutralLosses() {\n    if (accountedNeutralLosses == null) {\n        accountedNeutralLosses = new ArrayList<>(forwardBoundaries.keySet());\n    }\n    return accountedNeutralLosses;\n}","518":"public int getRewindStart(String neutralLossName) {\n    Integer start = rewindBoundaries.get(neutralLossName);\n    if (start == null) {\n        return 0;\n    }\n    return start;\n}","519":"private boolean increaseIndex() {\n    index2++;\n    if (index2 == proteinSequenceAsCharArray.length + 1) {\n        index1++;\n        if (index1 == proteinSequenceAsCharArray.length) {\n            return false;\n        }\n        index2 = index1 + 1;\n    }\n    return true;\n}","520":"private boolean increaseIndex() {\n    index2++;\n    if (index2 == proteinSequenceAsCharArray.length + 1) {\n        index1++;\n        if (index1 == proteinSequenceAsCharArray.length) {\n            return false;\n        }\n        index2 = index1 + 1;\n    }\n    return true;\n}","521":"public void resetQcResults() {\n    if (qcFilters == null) {\n        qcFilters = new HashMap<>(1);\n    } else {\n        qcFilters.clear();\n    }\n}","522":"public double getDeltaScore(int site) {\n    if (deltaScoresAtAA == null) {\n        return 0.0;\n    }\n    Double score = deltaScoresAtAA.get(site);\n    if (score == null) {\n        return 0.0;\n    } else {\n        return score;\n    }\n}","523":"public double getProbabilisticScore(int site) {\n    if (probabilisticScoresAtAA == null) {\n        return 0.0;\n    }\n    Double score = probabilisticScoresAtAA.get(site);\n    if (score == null) {\n        return 0.0;\n    } else {\n        return score;\n    }\n}","524":"public int getLocalizationConfidence(int site) {\n    if (ptmLocationAtAA == null) {\n        return NOT_FOUND;\n    }\n    Integer confidence = ptmLocationAtAA.get(site);\n    if (confidence == null) {\n        confidence = NOT_FOUND;\n    }\n    return confidence;\n}","525":"public static String[] getPossibleConfidenceLevels() {\n    String[] result = new String[5];\n    result[0] = \"Not Found\";\n    result[1] = \"Random\";\n    result[2] = \"Doubtful\";\n    result[3] = \"Confident\";\n    result[4] = \"Very Confident\";\n    return result;\n}","526":"public void addSpectrumMatchKey(long spectrumMatchKey) {\n    spectrumMatchesKeys = Arrays.copyOf(spectrumMatchesKeys, spectrumMatchesKeys.length + 1);\n    spectrumMatchesKeys[spectrumMatchesKeys.length - 1] = spectrumMatchKey;\n}","527":"private void setMatchKey() {\n    matchKey = ExperimentObject.asLong(Arrays.stream(accessions).collect(Collectors.joining()));\n}","528":"private void populateGUI(ThermoRawFileParserParameters thermoRawFileParserParameters) {\n    outputFormatCmb.setSelectedItem(thermoRawFileParserParameters.getOutputFormat());\n    if (thermoRawFileParserParameters.isPeackPicking()) {\n        peakPickingCmb.setSelectedIndex(0);\n    } else {\n        peakPickingCmb.setSelectedIndex(1);\n    }\n}","529":"public static int getNPeaksAboveThreshold(Spectrum spectrum, int startIndex, int endIndex, double intensityThreshold) {\n    return (int) IntStream.range(startIndex, endIndex).mapToDouble(i -> spectrum.intensity[i]).filter(intensity -> intensity >= intensityThreshold).count();\n}","530":"public static double[] getRecalibratedMz(TreeMap<Double, Double> mzCorrections, double[] originalMz) {\n    double[] result = new double[originalMz.length];\n    for (int i = 0; i < originalMz.length; i++) {\n        double fragmentMz = originalMz[i];\n        double correction = getCorrection(fragmentMz, mzCorrections);\n        result[i] = fragmentMz - correction;\n    }\n    return result;\n}","531":"\/**\n * Get the binned cumulative probability.\n *\n * @param intensity the intensity\n *\n * @return the binned cumulative probability\n *\/\npublic double getBinnedCumulativeProbability(double intensity) {\n    for (int i = 0; i < orderedBins.length; i++) {\n        int bin = orderedBins[i];\n        if (intensity > bin) {\n            return binSize * i;\n        }\n    }\n    return 1.0;\n}","532":"public double getBinnedCumulativeProbabilityLog(double intensity) {\n    for (int i = 0; i < orderedBins.length; i++) {\n        int bin = orderedBins[i];\n        if (intensity > bin) {\n            return pLog[i];\n        }\n    }\n    return 0.0;\n}","533":"public void close() {\n    try {\n        simpleFileReader.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}","534":"\/**\n * A static method to retrieve the instance of the factory.\n *\n * @return the factory instance\n *\/\npublic static IdfileReaderFactory getInstance() {\n    if (singleton == null) {\n        singleton = new IdfileReaderFactory();\n    }\n    return singleton;\n}","535":"public Integer getSpectrumIndex(String spectrumTitle) {\n    if (spectrumNumberIndexMap == null) {\n        return null;\n    }\n    Integer index = spectrumNumberIndexMap.get(spectrumTitle);\n    if (index == null) {\n        return -1;\n    } else {\n        return index;\n    }\n}","536":"public Double getPrecursorMz(int spectrumIndex) {\n    if (precursorMzMap == null) {\n        return null;\n    }\n    Double mz = precursorMzMap.get(spectrumIndex);\n    if (mz == null) {\n        return null;\n    } else {\n        return mz;\n    }\n}","537":"\/**\n * Writes the given spectrum to the file.\n *\n * @param spectrumTitle The title of the spectrum to write.\n * @param spectrum The spectrum to write.\n *\/\npublic void writeSpectrum(String spectrumTitle, Spectrum spectrum) {\n    String toWrite = asMgf(spectrumTitle, spectrum);\n    writer.write(toWrite, true);\n}","538":"\/**\n * Writes the header of the file.\n *\/\npublic void writeHeader() {\n    writer.writeLine(\"H\\tCreationDate\\t\" + new Date());\n    writer.writeLine(\"H\\tExtractor\\tUnknown\");\n    writer.writeLine(\"H\\tExtractorVersion\\tUnknown\");\n    writer.writeLine(\"H\\tExtractorOptions\\tUnknown\");\n    writer.writeLine(\"H\\tComment\\tCreated by compomics utilities based on http:\/\/cruxtoolkit.sourceforge.net\/ms2-format.html\");\n}","539":"\/**\n * Writes the header of the file.\n *\/\npublic void writeHeader() {\n    writer.writeLine(\"H\\tCreationDate\\t\" + new Date());\n    writer.writeLine(\"H\\tExtractor\\tUnknown\");\n    writer.writeLine(\"H\\tExtractorVersion\\tUnknown\");\n    writer.writeLine(\"H\\tExtractorOptions\\tUnknown\");\n    writer.writeLine(\"H\\tComment\\tCreated by compomics utilities based on http:\/\/cruxtoolkit.sourceforge.net\/ms2-format.html\");\n}","540":"\/**\n * Returns the magic number of currently supported CMS files.\n *\n * @return The magic number of currently supported CMS files.\n *\/\npublic static byte[] getMagicNumber() {\n    try {\n        String magicName = \"CmsFile.1.4\";\n        return magicName.getBytes(ENCODING);\n    } catch (UnsupportedEncodingException e) {\n        throw new RuntimeException(e);\n    }\n}","541":"public double getPrecursorRt(String spectrumTitle) {\n    int index = indexMap.get(spectrumTitle);\n    mutex.acquire();\n    mappedByteBuffer.position(index + Double.BYTES);\n    double precursorRt = mappedByteBuffer.getDouble();\n    mutex.release();\n    return precursorRt;\n}","542":"public int getSpectrumLevel(String spectrumTitle) {\n    int index = indexMap.get(spectrumTitle);\n    mutex.acquire();\n    mappedByteBuffer.position(index + 3 * Double.BYTES);\n    int spectrumLevel = mappedByteBuffer.getInt();\n    mutex.release();\n    return spectrumLevel;\n}","543":"public static byte[] uncompress(byte[] compressedByteArray, int uncompressedLength) {\n    ZstdDecompressor decompressor = new ZstdDecompressor();\n    byte[] uncompressedByteAray = ZstdUtils.zstdDecompress(decompressor, compressedByteArray, uncompressedLength);\n    return uncompressedByteAray;\n}","544":"public static boolean containsForbiddenCharacter(String string) {\n    for (String forbiddenCharacter : FORBIDDEN_CHARACTERS) {\n        if (string.contains(forbiddenCharacter)) {\n            return true;\n        }\n    }\n    return false;\n}","545":"public static ArrayList<Protocol> getDefaultProtocols() {\n    ArrayList<Protocol> result = new ArrayList<>();\n    result.add(new Protocol(\"In Gel Protein Digestion\", new ArrayList<>(Arrays.asList(new CvTerm(\"PRIDE\", \"PRIDE:0000025\", \"Reduction\", \"DTT\"), new CvTerm(\"PRIDE\", \"PRIDE:0000026\", \"Alkylation\", \"iodoacetamide\"), new CvTerm(\"PRIDE\", \"PRIDE:0000160\", \"Enzyme\", \"Trypsin\")))));\n    return result;\n}","546":"public static ProjectSummaryList getProjectSummaryList(String query, PrideFilter... filters) throws IOException {\n    ProjectSummaryList summaryList = new ProjectSummaryList();\n    String projectListURL = getQueryURL(PrideQuery.GET_PROJECTS_BY_CRITERIA.getQueryTemplate(false), query, filters);\n    boolean moreResults = true;\n    int page = 0;\n    while (moreResults) {\n        ProjectSummaryList subSummary = MARSHALLER.getProjectSummaryList(projectListURL + \"&page=\" + page);\n        if (subSummary == null || subSummary.getList().isEmpty()) {\n            moreResults = false;\n        } else {\n            summaryList.getList().addAll(subSummary.getList());\n        }\n        page++;\n    }\n    return summaryList;\n}","547":"private static ProteinDetailList bufferProteinIdentifications(String queryURL) throws IOException {\n    ProteinDetailList proteins = new ProteinDetailList();\n    boolean moreResults = true;\n    int page = 0;\n    while (moreResults) {\n        ProteinDetailList subList = (ProteinDetailList) MARSHALLER.getProteinDetailList(queryURL + \"?show=\" + PAGE_SIZE + \"&page=\" + page);\n        if (subList.getList().isEmpty()) {\n            moreResults = false;\n        } else {\n            proteins.getList().addAll(subList.getList());\n        }\n        page++;\n    }\n    return proteins;\n}","548":"private static PsmDetailList bufferPSMs(String queryURL) throws IOException {\n    PsmDetailList psms = new PsmDetailList();\n    boolean moreResults = true;\n    int page = 0;\n    while (moreResults) {\n        PsmDetailList subList = (PsmDetailList) MARSHALLER.getPeptideDetailList(queryURL + \"?show=\" + PAGE_SIZE + \"&page=\" + page);\n        if (subList.getList().isEmpty()) {\n            moreResults = false;\n        } else {\n            psms.getList().addAll(subList.getList());\n        }\n        page++;\n    }\n    return psms;\n}","549":"private Object loadObject(File aFile) throws FileNotFoundException, IOException, ClassNotFoundException {\n    Object object = null;\n    FileInputStream fis = new FileInputStream(aFile);\n    try {\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        try {\n            ObjectInputStream in = new ObjectInputStream(bis);\n            try {\n                object = in.readObject();\n            } finally {\n                in.close();\n            }\n        } finally {\n            bis.close();\n        }\n    } finally {\n        fis.close();\n    }\n    return object;\n}","550":"private void deleteObject(File folder, String aFileName) {\n    String fileName = aFileName + extension;\n    if (new File(folder, fileName).exists()) {\n        boolean deleted = new File(folder, fileName).delete();\n        if (!deleted) {\n            JOptionPane.showMessageDialog(null, \"Failed to delete the file \\'\" + new File(folder, fileName).getAbsolutePath() + \"\\'.\\n\" + \"Please delete the file manually.\", \"File Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}","551":"private void processInput() {\n    String input = sequenceTxt.getText().trim();\n    double mass = StandardMasses.h2o.mass + input.chars().mapToDouble(aa -> AminoAcid.getAminoAcid((char) aa).getMonoisotopicMass()).sum();\n    massTxt.setText(mass + \"\");\n}","552":"\/**\n * Update the file listing.\n *\/\nprivate void updateFileListing() {\n    String fileListing = \"<html><ol>\";\n    for (int i = 0; i < files.size(); i++) {\n        fileListing += \"<li>\" + files.get(i).getName() + \" - <a href=\\\"\" + i + \"\\\">remove<\/a><\/li>\";\n    }\n    fileListing += \"<\/ol><\/html>\";\n    selectedFilesEditorPane.setText(fileListing);\n    selectedFilesEditorPane.setCaretPosition(0);\n}","553":"public static void installEscapeCloseOperation(final JDialog dialog) {\n    Action dispatchClosing = new AbstractAction() {\n\n        public void actionPerformed(ActionEvent event) {\n            dialog.dispatchEvent(new WindowEvent(dialog, WindowEvent.WINDOW_CLOSING));\n        }\n    };\n    JRootPane root = dialog.getRootPane();\n    root.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeStroke, dispatchWindowClosingActionMapKey);\n    root.getActionMap().put(dispatchWindowClosingActionMapKey, dispatchClosing);\n}","554":"private int estimateWidth() {\n    int lEstimateX = iXStart;\n    for (int i = 0; i < iSequenceComponents.length; i++) {\n        lEstimateX += this.getFontMetrics(iBaseFont).stringWidth(iSequenceComponents[i]) + iHorizontalSpace;\n        lEstimateX += iBarWidth + iHorizontalSpace;\n    }\n    lEstimateX += iXStart;\n    return lEstimateX;\n}","555":"private void updateItem(int index) {\n    if (isPopupVisible()) {\n        E item = getItemAt(index);\n        item.selected ^= true;\n        removeItemAt(index);\n        insertItemAt(item, index);\n        setSelectedItem(item);\n    }\n}","556":"\/**\n * Set up the GUI.\n *\/\nprivate void setUpGUI() {\n    filtersTable.getTableHeader().setReorderingAllowed(false);\n    JPanel proteinCorner = new JPanel();\n    proteinCorner.setBackground(filtersTable.getTableHeader().getBackground());\n    filtersScrollPane.setCorner(ScrollPaneConstants.UPPER_RIGHT_CORNER, proteinCorner);\n    filtersScrollPane.getViewport().setOpaque(false);\n    filtersTable.getColumn(\" \").setMaxWidth(50);\n    filtersTable.getColumn(\" \").setMinWidth(50);\n}","557":"private void formWindowClosing(java.awt.event.WindowEvent evt) {\n    try {\n        enzymeFactory.saveFactory();\n    } catch (IOException e) {\n        JOptionPane.showMessageDialog(this, \"An error occurred while saving the enzymes.\", \"Saving Error\", JOptionPane.WARNING_MESSAGE);\n    }\n    dispose();\n}","558":"public static void main(String[] args) {\n    JFrame temp = new JFrame();\n    DateChooser dc = new DateChooser(temp);\n    dc.setVisible(true);\n    Calendar c = dc.getSelectedDate();\n    if (c != null) {\n        logger.info(\"\\n\\nSelected date was: \" + new SimpleDateFormat(\"dd-MM-yyyy\").format(c.getTime()) + \"\\n\\n\");\n    } else {\n        logger.info(\"\\n\\nNo date selected!\\n\\n\");\n    }\n    System.exit(0);\n}","559":"public int getViewIndex(int row) {\n    if (viewIndexes == null) {\n        return row;\n    }\n    int nRows = getRowCount();\n    if (nRows != viewIndexes.size()) {\n        initiateSorter();\n    }\n    if (row < 0 || row >= nRows) {\n        nRows--;\n        throw new IllegalArgumentException(\"Row \" + row + \" must be between 0 and \" + nRows);\n    }\n    return viewIndexes.get(row);\n}","560":"public int getRowNumber(int viewIndex) {\n    if (viewIndexes == null) {\n        return viewIndex;\n    }\n    int nRows = getRowCount();\n    if (nRows != viewIndexes.size()) {\n        initiateSorter();\n    }\n    if (viewIndex < 0 || viewIndex >= nRows) {\n        nRows--;\n        throw new IllegalArgumentException(\"View index \" + viewIndex + \" must be between 0 and \" + nRows + \".\");\n    }\n    return viewIndexes.indexOf(viewIndex);\n}","561":"public void setAnnotationsMirrored(List<SpectrumAnnotation> aAnnotations) {\n    this.iAnnotationsMirroredSpectra = new Vector(50, 25);\n    if (aAnnotations != null) {\n        HashSet removeDupes = new HashSet(aAnnotations.size());\n        for (SpectrumAnnotation annotation : aAnnotations) {\n            String key = annotation.getLabel() + annotation.getMZ();\n            if (removeDupes.contains(key)) {\n            } else {\n                removeDupes.add(key);\n                this.iAnnotationsMirroredSpectra.add(annotation);\n            }\n        }\n    }\n}","562":"protected void annotatePeaks(Graphics g, Vector annotations, boolean mirrored) {\n    if (annotations != null && annotations.size() > 0 && !miniature) {\n        HashMap<String, Integer> annotatedPeaks = new HashMap<>();\n        for (Object o : annotations) {\n            if (o instanceof SpectrumAnnotation) {\n                SpectrumAnnotation sa = (SpectrumAnnotation) o;\n                this.annotate(sa, g, annotatedPeaks, mirrored);\n            }\n        }\n    }\n}","563":"public void addAdditionalDataset(String peptideSequence, Integer peptideCharge, Color dataPointAndLineColor, Color areaUnderCurveColor, int labelDifference) throws IOException {\n    AASequenceImpl validatedPeptideSequence = validatePeptideSequence(peptideSequence);\n    peptideSequences.add(validatedPeptideSequence);\n    peptideCharges.add(peptideCharge);\n    IsotopicDistributionSpectrum isotopicDistributionSpectrum = calculateIsotopicDistribution(validatedPeptideSequence, peptideCharge, labelDifference);\n    this.processIsotopicDistribution(isotopicDistributionSpectrum, dataPointAndLineColor, areaUnderCurveColor);\n    rescaleWithLeftSidePadding();\n    this.showFileName = false;\n    this.showPrecursorDetails = false;\n    this.showResolution = false;\n}","564":"private void rescaleWithLeftSidePadding() {\n    double tempMinXValue = getMinXAxisValue();\n    tempMinXValue -= 1;\n    if (tempMinXValue < 0) {\n        tempMinXValue = 0;\n    }\n    this.rescale(tempMinXValue, getMaxXAxisValue());\n}","565":"public boolean validateInput() {\n    String name = nameTxt.getText();\n    for (char character : name.toCharArray()) {\n        String charAsString = character + \"\";\n        if (charAsString.matches(\"[^\\\\dA-Za-z ]\")) {\n            JOptionPane.showMessageDialog(this, \"Unsupported character in parameters name (\" + character + \"). Please avoid special characters in parameters name.\", \"Special Character\", JOptionPane.INFORMATION_MESSAGE);\n            return false;\n        }\n    }\n    return true;\n}","566":"\/**\n * Set up the GUI.\n *\/\nprivate void setUpGui() {\n    neutralLossesCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));\n    alignOnConfidentCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));\n    scoreCmb.setRenderer(new AlignedListCellRenderer(SwingConstants.CENTER));\n    scoreCmb.setEnabled(editable);\n    neutralLossesCmb.setEnabled(editable);\n    alignOnConfidentCmb.setEnabled(editable);\n    thresholdTxt.setEditable(editable);\n    thresholdTxt.setEnabled(editable);\n}","567":"private void setTableProperties() {\n    TableColumnModel tableColumnModel = psmScoresJTable.getColumnModel();\n    tableColumnModel.getColumn(0).setMaxWidth(30);\n    psmScoresJScrollPane.getViewport().setOpaque(false);\n    for (int i = 0; i < PsmScore.values().length; i++) {\n        tableColumnModel.getColumn(i + 2).setCellRenderer(new TrueFalseIconRenderer(new ImageIcon(this.getClass().getResource(\"\/icons\/selected_green-new.png\")), null, \"On\", \"Off\"));\n    }\n}","568":"public PsmScoringParameters getPsmScoringPreferences() {\n    PsmScoringParameters psmScoringPreferences = new PsmScoringParameters();\n    psmScoringPreferences.clearAllScores();\n    for (Integer algorithm : spectrumMatchingScores.keySet()) {\n        HashSet<Integer> scores = spectrumMatchingScores.get(algorithm);\n        for (Integer score : scores) {\n            psmScoringPreferences.addScore(algorithm, score);\n        }\n    }\n    return psmScoringPreferences;\n}","569":"\/**\n * Set up the GUI.\n *\/\nprivate void setUpGui() {\n    matchingCmb.setRenderer(new com.compomics.util.gui.renderers.AlignedListCellRenderer(SwingConstants.CENTER));\n    tagMatchingCmb.setRenderer(new com.compomics.util.gui.renderers.AlignedListCellRenderer(SwingConstants.CENTER));\n    matchingCmb.setEnabled(editable);\n    xSpinner.setEnabled(editable);\n    tagMatchingCmb.setEnabled(editable);\n    maxPtmsPerTagTextField.setEnabled(editable);\n}","570":"public SequenceMatchingParameters getSequenceMatchingPreferences() {\n    SequenceMatchingParameters sequenceMatchingPreferences = new SequenceMatchingParameters();\n    sequenceMatchingPreferences.setSequenceMatchingType((SequenceMatchingParameters.MatchingType) matchingCmb.getSelectedItem());\n    sequenceMatchingPreferences.setLimitX((Double) xSpinner.getValue());\n    sequenceMatchingPreferences.setEnzymaticTagsOnly(tagMatchingCmb.getSelectedIndex() == 1);\n    sequenceMatchingPreferences.setMaxPtmsPerTagPeptide(Integer.parseInt(maxPtmsPerTagTextField.getText()));\n    sequenceMatchingPreferences.setMinAminoAcidScore((Integer) minAaScoreSpinner.getValue());\n    sequenceMatchingPreferences.setMinTagLength(Integer.parseInt(minTagLengthTextField.getText()));\n    return sequenceMatchingPreferences;\n}","571":"private void populateGUI(PepnovoParameters pepnovoParameters) {\n    hitListLengthSpinner.setValue(pepnovoParameters.getHitListLength());\n    if (pepnovoParameters.isCorrectPrecursorMass()) {\n        correctPrecursorMassCmb.setSelectedIndex(1);\n    } else {\n        correctPrecursorMassCmb.setSelectedIndex(0);\n    }\n    if (pepnovoParameters.isEstimateCharge()) {\n        estimateChargeCmb.setSelectedIndex(1);\n    } else {\n        estimateChargeCmb.setSelectedIndex(0);\n    }\n}","572":"\/**\n * Sets up the GUI.\n *\/\nprivate void setUpGUI() {\n    activationTypeCmb.setRenderer(new com.compomics.util.gui.renderers.AlignedListCellRenderer(SwingConstants.CENTER));\n    activationTypeCmb.setEnabled(editable);\n    minPrecursorMassTextField.setEditable(editable);\n    minPrecursorMassTextField.setEnabled(editable);\n    maxPrecursorMassTextField.setEditable(editable);\n    maxPrecursorMassTextField.setEnabled(editable);\n}","573":"private void outputFormatCmbActionPerformed(java.awt.event.ActionEvent evt) {\n    if (outputFormatCmb.getSelectedIndex() != 0 && this.isVisible()) {\n        SwingUtilities.invokeLater(new Runnable() {\n\n            public void run() {\n                JOptionPane.showMessageDialog(MyriMatchParametersDialog.this, JOptionEditorPane.getJOptionEditorPane(\"Note that the MyriMatch pepXML format is not compatible with <a href=\\\"https:\/\/compomics.github.io\/projects\/peptide-shaker.html\\\">PeptideShaker<\/a>.\"), \"Format Warning\", JOptionPane.WARNING_MESSAGE);\n            }\n        });\n    }\n}","574":"\/**\n * Set up the GUI.\n *\/\nprivate void setUpGui() {\n    validatedColorPanel.setBackground(utilitiesUserParameters.getSparklineColor());\n    notValidatedColorPanel.setBackground(utilitiesUserParameters.getSparklineColorNonValidated());\n    notFoundColorPanel.setBackground(utilitiesUserParameters.getSparklineColorNotFound());\n    possibleColorPanel.setBackground(utilitiesUserParameters.getSparklineColorPossible());\n    doubtfulColorPanel.setBackground(utilitiesUserParameters.getSparklineColorDoubtful());\n    falsePositiveColorPanel.setBackground(utilitiesUserParameters.getSparklineColorFalsePositives());\n}","575":"private void setSelected(String section, ExportFeature exportFeature, Boolean selected) {\n    if (selected) {\n        if (!selection.containsKey(section)) {\n            selection.put(section, new ArrayList<>());\n        }\n        if (!selection.get(section).contains(exportFeature)) {\n            selection.get(section).add(exportFeature);\n        }\n    } else {\n        if (selection.containsKey(section)) {\n            selection.get(section).remove(exportFeature);\n            if (selection.get(section).isEmpty()) {\n                selection.remove(section);\n            }\n        }\n    }\n}","576":"\/**\n * Update the selection to the given atom.\n *\n * @param atom the atom\n * @param isotope the isotope\n * @param occurrence the occurrence\n *\/\nprivate void updateSelection(Atom atom, int isotope, int occurrence) {\n    if (atom != null) {\n        atomCmb.setSelectedItem(atom.getLetter());\n        updateIsotopes();\n        for (String istopeString : isotopesMap.keySet()) {\n            if (isotopesMap.get(istopeString) == isotope) {\n                isotopeCmb.setSelectedItem(istopeString);\n            }\n        }\n        occurenceSpinner.setValue(occurrence);\n        atomChainDialog.updateAtomComposition();\n    }\n}","577":"public ArrayList<String> getCheckedItems(ListModel model) {\n    ArrayList<String> sl = new ArrayList<>();\n    for (int i = 0; i < model.getSize(); i++) {\n        Object o = model.getElementAt(i);\n        if (o instanceof CheckableItem && ((CheckableItem) o).selected) {\n            sl.add(o.toString());\n        }\n    }\n    return sl;\n}","578":"public void setCheckedItem(ListModel model, String itemName) {\n    for (int i = 0; i < model.getSize(); i++) {\n        Object o = model.getElementAt(i);\n        if (o instanceof CheckableItem && ((CheckableItem) o).text.equalsIgnoreCase(itemName)) {\n            ((CheckableItem) o).selected = true;\n        }\n    }\n}","579":"public Integer getPreferredAccessionColumnWidth(JTable table, int colIndex, int margin) {\n    DefaultTableColumnModel colModel = (DefaultTableColumnModel) table.getColumnModel();\n    TableColumn col = colModel.getColumn(colIndex);\n    TableCellRenderer renderer = col.getHeaderRenderer();\n    if (renderer == null) {\n        renderer = table.getTableHeader().getDefaultRenderer();\n    }\n    Component comp = renderer.getTableCellRendererComponent(table, col.getHeaderValue(), false, false, 0, 0);\n    int width = comp.getPreferredSize().width;\n    width += 2 * margin;\n    return width;\n}","580":"public void setString(final String displayString) {\n    if (displayProgress) {\n        SwingUtilities.invokeLater(new Runnable() {\n\n            public void run() {\n                progressBar.setStringPainted(displayString != null);\n                progressBar.setString(displayString);\n            }\n        });\n    }\n}","581":"private void setTipOfTheDay(ArrayList<String> tips) {\n    this.tips = tips;\n    if (tips == null || tips.isEmpty()) {\n        showTipOfTheDayCheckBox.setSelected(false);\n        showTipOfTheDayCheckBox.setEnabled(false);\n        tipOfTheDayJPanel.setVisible(false);\n    }\n}","582":"private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {\n    if (runFinished || runCanceled) {\n        if (waitingHandlerParent instanceof DummyFrame) {\n            ((DummyFrame) waitingHandlerParent).dispose();\n        }\n        this.dispose();\n    } else {\n        setRunCanceled();\n    }\n}","583":"\/**\n * Loads the user preferences on the GUI.\n *\/\nprivate void loadPreferencesOnGUI() {\n    try {\n        utilitiesUserParameters = UtilitiesUserParameters.loadUserParameters();\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(this, \"An error occurred while loading the user preferences.\", \"User Preferences Error\", JOptionPane.WARNING_MESSAGE);\n        e.printStackTrace();\n        utilitiesUserParameters = new UtilitiesUserParameters();\n    }\n    updatesCheck.setSelected(utilitiesUserParameters.isAutoUpdate());\n}","584":"private void savePreferences() {\n    utilitiesUserParameters.setAutoUpdate(updatesCheck.isSelected());\n    try {\n        UtilitiesUserParameters.saveUserParameters(utilitiesUserParameters);\n    } catch (Exception e) {\n        JOptionPane.showMessageDialog(this, \"An error occurred while saving the user preferences.\", \"User Preferences Error\", JOptionPane.WARNING_MESSAGE);\n        e.printStackTrace();\n    }\n}","585":"public void setModel(TableModel aModel, boolean aSortable) {\n    TableModel tempModel = aModel;\n    if (aSortable) {\n        TableModel oldModel = super.getModel();\n        TableSorter sorter = new TableSorter(aModel);\n        if (sorter != null) {\n            if ((oldModel != null) && (oldModel instanceof TableSorter)) {\n                ((TableSorter) oldModel).removeMouseListenerToHeaderInTable(this);\n            }\n            sorter.addMouseListenerToHeaderInTable(this);\n        }\n        tempModel = sorter;\n    }\n    super.setModel(tempModel);\n}","586":"\/**\n * Main method. For testing purposes only.\n *\n * @param args the arguments\n *\/\npublic static void main(String[] args) {\n    \/\/ set the look and feel\n    try {\n        UtilitiesGUIDefaults.setLookAndFeel();\n    } catch (Exception e) {\n        \/\/ ignore\n    }\n    new VennDiagramDialog(new JFrame(), null, null, true);\n}","587":"private void valueFontSizeMenuItemActionPerformed(java.awt.event.ActionEvent evt) {\n    String value = JOptionPane.showInputDialog(this, \"Values Font Size:\", vennDiagramPanel.getFontSize());\n    if (value != null) {\n        try {\n            vennDiagramPanel.setFontSize(Integer.parseInt(value));\n            vennDiagramPanel.updatePlot();\n        } catch (NumberFormatException e) {\n            JOptionPane.showMessageDialog(this, \"Font size has to be an integer!\", \"Font Error\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    }\n}","588":"private void legendFontSizeMenuItemActionPerformed(java.awt.event.ActionEvent evt) {\n    String value = JOptionPane.showInputDialog(this, \"Legend Font Size:\", vennDiagramPanel.getFontSizeLegend());\n    if (value != null) {\n        try {\n            vennDiagramPanel.setFontSizeLegend(Integer.parseInt(value));\n            vennDiagramPanel.updatePlot();\n        } catch (NumberFormatException e) {\n            JOptionPane.showMessageDialog(this, \"Font size has to be an integer!\", \"Font Error\", JOptionPane.INFORMATION_MESSAGE);\n        }\n    }\n}","589":"\/**\n * Returns factorial 0 to 20 in an array.\n *\n * @return Factorial 0 to 20 in an array.\n *\/\npublic static long[] getFactorialsCache() {\n    long[] result = new long[21];\n    result[0] = 1;\n    for (int i = 1; i <= 20; i++) {\n        result[i] = result[i - 1] * i;\n    }\n    return result;\n}","590":"public static double medianSorted(double[] input) {\n    int length = input.length;\n    if (input.length == 1) {\n        return input[0];\n    }\n    if (length % 2 == 1) {\n        return input[(length - 1) \/ 2];\n    } else {\n        return (input[length \/ 2] + input[(length) \/ 2 - 1]) \/ 2;\n    }\n}","591":"public static double percentile(ArrayList<Double> input, double percentile) {\n    if (input == null) {\n        throw new IllegalArgumentException(\"Attempting to estimate the percentile of a null object.\");\n    }\n    int length = input.size();\n    if (length == 0) {\n        throw new IllegalArgumentException(\"Attempting to estimate the percentile of an empty list.\");\n    }\n    ArrayList<Double> sortedInput = new ArrayList<>(input);\n    Collections.sort(sortedInput);\n    return percentileSorted(sortedInput, percentile);\n}","592":"public double[] excludeNullValues(Double[] data) {\n    ArrayList<Double> list = new ArrayList<>();\n    for (Double value : data) {\n        if (value != null) {\n            list.add(value);\n        }\n    }\n    double[] newArray = new double[list.size()];\n    for (int i = 0; i < list.size(); i++) {\n        newArray[i] = list.get(i);\n    }\n    return newArray;\n}","593":"public void printCentroids() {\n    for (int centroidNumber = 0; centroidNumber < NUM_CLUSTERS; centroidNumber++) {\n        System.out.print(\"     \" + (centroidNumber + 1) + \"\\t\\t\");\n        for (int valueNumber = 0; valueNumber < NUM_VALUES; valueNumber++) {\n            if (valueNumber > 0) {\n                System.out.print(\"\\t\");\n            }\n            System.out.print(Util.roundDouble(centroids[centroidNumber][valueNumber], 2));\n        }\n        System.out.println();\n    }\n}","594":"public ArrayList<String> getClusterMembers(int clusterIndex) {\n    ArrayList<String> clusterMembers = new ArrayList<>();\n    for (int sampleIndex = 0; sampleIndex < NUM_SAMPLES; sampleIndex++) {\n        if (clusters[sampleIndex] == clusterIndex) {\n            clusterMembers.add(SAMPLE_IDS[sampleIndex]);\n        }\n    }\n    return clusterMembers;\n}","595":"protected String getJsonStringFromFile(File jsonFile) throws FileNotFoundException, IOException {\n    StringBuilder stringBuilder = new StringBuilder();\n    BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(jsonFile)));\n    try {\n        String line;\n        while ((line = in.readLine()) != null) {\n            stringBuilder.append(line);\n        }\n    } finally {\n        in.close();\n    }\n    return stringBuilder.toString();\n}","596":"private JsonElement get(final JsonObject wrapper, String memberName) {\n    final JsonElement elem = wrapper.get(memberName);\n    if (elem == null) {\n        throw new JsonParseException(\"No '\" + memberName + \"' member found in what was expected to be an interface wrapper.\");\n    }\n    return elem;\n}","597":"\/**\n * This method reads a line of text from the buffer.\n * It returns a 'null' if the EOF is encountered.\n *\n * @return  String  with the current line in the buffer, or 'null' if the end\n *                  of the buffer has been reached.\n *\/\npublic String readLine() {\n    String result = null;\n    if (!iEOF) {\n        int returnIndex = iLocation;\n        iLocation++;\n        if (iLocation == iData.size()) {\n            iEOF = true;\n        } else if (iLocation > iData.size()) {\n            throw new ArrayIndexOutOfBoundsException(\"Vector elements count up to element \" + (iData.size() - 1) + \" and current index is \" + iLocation + \".\");\n        }\n        result = (String) iData.get(returnIndex);\n    }\n    return result;\n}","598":"public int monitorProgress() {\n    int result = 0;\n    if (iBypassCache) {\n        try {\n            result = this.iMaximum - available();\n        } catch (IOException ioe) {\n            throw new RuntimeException(\"Failure when monitoring real-time read progress!\");\n        }\n    } else {\n        result = this.iMaximum - this.iRemainder;\n    }\n    return result;\n}","599":"\/**\n * Get the operating system.\n *\n * @return This method returns the underlying operating system as a\n * OperatingSystemEnum instance.\n *\/\npublic static OperatingSystemEnum getOperatingSystem() {\n    String lOSName = System.getProperty(\"os.name\").toLowerCase();\n    if (lOSName.indexOf(\"win\") > -1) {\n        return OperatingSystemEnum.WINDOWS;\n    } else if (lOSName.indexOf(\"uni\") > -1) {\n        return OperatingSystemEnum.UNIX;\n    } else if (lOSName.indexOf(\"mac\") > -1) {\n        return OperatingSystemEnum.MACOS;\n    } else {\n        return null;\n    }\n}","600":"public static String getPathOfClass(String aClassname) {\n    String path;\n    String lFileSeparator = System.getProperties().get(\"file.separator\").toString();\n    path = PropertiesManager.getInstance().getClass().getProtectionDomain().getCodeSource().getLocation().toString();\n    if (path.startsWith(\"file:\")) {\n        path = path.substring(\"file:\".length(), path.lastIndexOf(lFileSeparator) + 1);\n    } else {\n        path = path.substring(0, path.lastIndexOf(lFileSeparator) + 1);\n    }\n    path = path.replace(\"%20\", \" \");\n    path = path.replace(\"%5b\", \"[\");\n    path = path.replace(\"%5d\", \"]\");\n    return path;\n}","601":"\/**\n * Accept all directories, *.pkl.spo files.\n *\n * @param f the file\n * @return true if the file passes the filter\n *\/\npublic boolean accept(File f) {\n    if (f.isDirectory()) {\n        return true;\n    }\n    String extension = FileFilterUtils.getExtension(f);\n    if (extension != null) {\n        if (extension.equals(FileFilterUtils.spo) || extension.equals(FileFilterUtils.SPO)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    return false;\n}","602":"public static Object readObject(File serializedFile) throws IOException, ClassNotFoundException {\n    FileInputStream fis = new FileInputStream(serializedFile);\n    try {\n        BufferedInputStream bis = new BufferedInputStream(fis);\n        try {\n            ObjectInputStream in = new ObjectInputStream(bis);\n            try {\n                Object object = in.readObject();\n                return object;\n            } finally {\n                in.close();\n            }\n        } finally {\n            bis.close();\n        }\n    } finally {\n        fis.close();\n    }\n}","603":"public void updateProperties(final CompomicsTools aTool, final String aPropertiesFileName, final Properties aNewProperties) {\n    Properties lProperties = getProperties(aTool, aPropertiesFileName);\n    Iterator lUpdatedProperties = aNewProperties.keySet().iterator();\n    while (lUpdatedProperties.hasNext()) {\n        Object aKey = lUpdatedProperties.next();\n        lProperties.put(aKey, aNewProperties.get(aKey));\n    }\n    storeProperties(aPropertiesFileName, aTool, lProperties);\n}","604":"public void newLine() {\n    try {\n        bw.newLine();\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}","605":"\/**\n * Returns a file reader, text or gz, according to the extension of the file.\n *\n * @param file the file\n *\n * @return a file reader\n *\/\npublic static SimpleFileReader getFileReader(File file) {\n    if (file.getName().endsWith(\".gz\")) {\n        return new SimpleGzReader(file);\n    }\n    return new SimpleTextReader(file);\n}","606":"public void closeServer() throws IOException {\n    if (serverIsOpen()) {\n        issueCommand(\"QUIT\");\n        if (!serverIsOpen()) {\n            return;\n        }\n        controlSocket.close();\n        controlSocket = null;\n        serverInput = null;\n        serverOutput = null;\n    }\n}","607":"public void login(String user, String password) throws IOException {\n    if (!serverIsOpen()) {\n        throw new FtpLoginException(\"Error: not connected to host.\\n\");\n    }\n    this.user = user;\n    this.password = password;\n    if (issueCommand(\"USER \" + user) == FTP_ERROR) {\n        throw new FtpLoginException(\"Error: User not found.\\n\");\n    }\n    if (password != null && issueCommand(\"PASS \" + password) == FTP_ERROR) {\n        throw new FtpLoginException(\"Error: Wrong Password.\\n\");\n    }\n}","608":"public BufferedReader getAscii(String filename) throws IOException {\n    m_bGettingFile = true;\n    Socket s = null;\n    try {\n        s = openDataConnection(\"RETR \" + filename);\n    } catch (FileNotFoundException fileException) {\n        throw new FileNotFoundException();\n    }\n    return new BufferedReader(new InputStreamReader(s.getInputStream()));\n}","609":"public BufferedInputStream getBinary(String filename) throws IOException {\n    m_bGettingFile = true;\n    Socket s = null;\n    try {\n        s = openDataConnection(\"RETR \" + filename);\n    } catch (FileNotFoundException fileException) {\n        throw new FileNotFoundException();\n    }\n    return new BufferedInputStream(s.getInputStream());\n}","610":"\/**\n * Tar a given folder to a file.\n *\n * @param folder The original folder to tar.\n * @param destinationFile The destination file.\n * @param waitingHandler A waiting handler used to cancel the process (can\n * be null).\n *\n * @throws ArchiveException Thrown whenever an error occurred while taring.\n * @throws IOException Thrown whenever an error occurred while\n * reading\/writing files.\n *\/\npublic static void tarFolder(File folder, File destinationFile, WaitingHandler waitingHandler) throws ArchiveException, IOException {\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destinationFile));\n    try (TarArchiveOutputStream tarOutput = (TarArchiveOutputStream) new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.TAR, bos)) {\n        tarOutput.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        File matchFolder = folder;\n        addFolderContent(tarOutput, matchFolder, waitingHandler);\n    }\n}","611":"public static void tarFolderContent(File folder, File destinationFile, HashSet<String> exceptionsPaths, WaitingHandler waitingHandler) throws ArchiveException, IOException {\n    BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destinationFile));\n    try (TarArchiveOutputStream tarOutput = (TarArchiveOutputStream) new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.TAR, bos)) {\n        tarOutput.setLongFileMode(TarArchiveOutputStream.LONGFILE_GNU);\n        for (File file : folder.listFiles()) {\n            String path = file.getAbsolutePath();\n            if (!exceptionsPaths.contains(path)) {\n                if (file.isDirectory()) {\n                    addFolderContent(tarOutput, file, waitingHandler);\n                } else {\n                    addFile(tarOutput, file, waitingHandler);\n                }\n            }\n        }\n    }\n}","612":"public void write(String sectionName, String content) {\n    SimpleSemaphore sectionSemaphore = semaphoreMap.get(sectionName);\n    sectionSemaphore.acquire();\n    SimpleFileWriter tempWriter = tempWriterMap.get(sectionName);\n    tempWriter.write(content);\n    sectionSemaphore.release();\n}","613":"public void write(String sectionName, char[] buffer, int offset, int length) {\n    SimpleSemaphore sectionSemaphore = semaphoreMap.get(sectionName);\n    sectionSemaphore.acquire();\n    SimpleFileWriter tempWriter = tempWriterMap.get(sectionName);\n    tempWriter.write(buffer, offset, length);\n    sectionSemaphore.release();\n}","614":"public static void zip(File originFile, File destinationFile, WaitingHandler waitingHandler, long totalUncompressedFileSize) throws IOException {\n    try (ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destinationFile)))) {\n        addToZip(originFile, out, waitingHandler, totalUncompressedFileSize);\n    }\n}","615":"public static boolean deleteDir(File dir) {\n    boolean empty = emptyDir(dir);\n    if (!empty) {\n        return false;\n    }\n    return dir.delete();\n}","616":"public static String removeExtension(String fileName) {\n    if (fileName.endsWith(\".gz\")) {\n        fileName = fileName.substring(0, fileName.length() - 3);\n    }\n    int pointIndex = fileName.lastIndexOf(\".\");\n    return pointIndex > 0 ? fileName.substring(0, pointIndex) : fileName;\n}","617":"public static int getFileSize(URL url) {\n    HttpURLConnection conn = null;\n    try {\n        conn = (HttpURLConnection) url.openConnection();\n        conn.setRequestMethod(\"HEAD\");\n        conn.getInputStream();\n        return conn.getContentLength();\n    } catch (IOException e) {\n        return -1;\n    } finally {\n        conn.disconnect();\n    }\n}","618":"private void pathTableMouseReleased(java.awt.event.MouseEvent evt) {\n    if (evt != null && pathTable.rowAtPoint(evt.getPoint()) != -1) {\n        pathTable.setRowSelectionInterval(pathTable.rowAtPoint(evt.getPoint()), pathTable.rowAtPoint(evt.getPoint()));\n    }\n    if (evt != null && evt.getButton() == MouseEvent.BUTTON3 && pathTable.getSelectedRow() != -1) {\n        pathSettingsPopupMenu.show(pathTable, evt.getX(), evt.getY());\n    }\n    if (evt != null && evt.getButton() == MouseEvent.BUTTON1 && evt.getClickCount() == 2) {\n        editSelectedPath();\n    }\n}","619":"private void editSelectedPath() {\n    int selectedRow = pathTable.getSelectedRow();\n    String name = (String) pathTable.getValueAt(selectedRow, 1);\n    PathKey pathKey = nameToKey.get(name);\n    File selectedFile = FileChooserUtil.getUserSelectedFolder(this, \"Select \" + pathKey.getId() + \" Folder\", keyToPathMap.get(pathKey), pathKey.getId() + \" Folder\", \"Select\", false);\n    if (selectedFile != null) {\n        keyToPathMap.put(pathKey, selectedFile.getAbsolutePath());\n        ((DefaultTableModel) pathTable.getModel()).fireTableDataChanged();\n    }\n}","620":"private void setDefaultPath() {\n    File selectedFile = FileChooserUtil.getUserSelectedFolder(this, \"Select Default Folder\", null, \"Default Folder\", \"Select\", false);\n    if (selectedFile != null) {\n        for (PathKey pathKey : keyToPathMap.keySet()) {\n            keyToPathMap.put(pathKey, selectedFile.getAbsolutePath());\n        }\n        ((DefaultTableModel) pathTable.getModel()).fireTableDataChanged();\n    }\n}","621":"\/**\n * Returns the list of file as argument for the command line.\n *\n * @param files the files\n *\n * @return the list of file as string for command line argument\n *\/\npublic static String getCommandLineArgument(ArrayList<File> files) {\n    String result = \"\";\n    for (File file : files) {\n        if (!result.equals(\"\")) {\n            result += SEPARATOR;\n        }\n        result += getQuoteType() + file.getAbsolutePath() + getQuoteType();\n    }\n    return result;\n}","622":"public static ArrayList<String> splitInput(String cliInput) {\n    ArrayList<String> results = new ArrayList<>();\n    if (cliInput == null || cliInput.trim().length() == 0) {\n        return results;\n    }\n    for (String tempInput : cliInput.split(SEPARATOR)) {\n        results.add(tempInput.trim());\n    }\n    return results;\n}","623":"\/**\n * Returns true if the input is an integer value inside the given range.\n *\n * @param argType the name of the argument\n * @param arg the content of the argument\n * @param minValue the minimum value allowed\n * @param maxValue the maximum value allowed\n * @return true if the input is an integer value inside the given range\n *\/\npublic static boolean inIntegerRange(String argType, String arg, int minValue, int maxValue) {\n    boolean valid = true;\n    try {\n        int value = Integer.valueOf(arg);\n        if (value < minValue || value > maxValue) {\n            System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not in the range [\" + minValue + \" - \" + maxValue + \"].\" + System.getProperty(\"line.separator\"));\n            valid = false;\n        }\n    } catch (NumberFormatException e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not an integer value!\" + System.getProperty(\"line.separator\"));\n        valid = false;\n    } catch (Exception e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: \" + e.getLocalizedMessage() + System.getProperty(\"line.separator\"));\n        valid = false;\n    }\n    return valid;\n}","624":"public static boolean inDoubleRange(String argType, String arg, double minValue, double maxValue) {\n    boolean valid = true;\n    try {\n        double value = Double.valueOf(arg);\n        if (value < minValue || value > maxValue) {\n            System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not in the range [\" + minValue + \" - \" + maxValue + \"].\" + System.getProperty(\"line.separator\"));\n            valid = false;\n        }\n    } catch (NumberFormatException e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not a floating value!\" + System.getProperty(\"line.separator\"));\n        valid = false;\n    } catch (Exception e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: \" + e.getLocalizedMessage() + System.getProperty(\"line.separator\"));\n        valid = false;\n    }\n    return valid;\n}","625":"public static boolean isInList(String argType, String arg, List<String> supportedInput) {\n    boolean valid = true;\n    if (!supportedInput.contains(arg)) {\n        valid = false;\n        String errorMessage = System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Found \" + arg + \". Supported input: [\";\n        for (int i = 0; i < supportedInput.size(); i++) {\n            if (i > 0) {\n                errorMessage += \", \";\n            }\n            errorMessage += supportedInput.get(i);\n        }\n        errorMessage += \"].\" + System.getProperty(\"line.separator\");\n        System.out.println(errorMessage);\n    }\n    return valid;\n}","626":"public static boolean isInteger(String argType, String arg) {\n    boolean valid = true;\n    try {\n        Integer.valueOf(arg);\n    } catch (NumberFormatException e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not an integer value!\" + System.getProperty(\"line.separator\"));\n        valid = false;\n    } catch (Exception e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: \" + e.getLocalizedMessage() + System.getProperty(\"line.separator\"));\n        valid = false;\n    }\n    return valid;\n}","627":"public static boolean isDouble(String argType, String arg) {\n    boolean valid = true;\n    try {\n        Double.valueOf(arg);\n    } catch (NumberFormatException e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: Not a floating value!\" + System.getProperty(\"line.separator\"));\n        valid = false;\n    } catch (Exception e) {\n        System.out.println(System.getProperty(\"line.separator\") + \"Error parsing the \" + argType + \" option: \" + e.getLocalizedMessage() + System.getProperty(\"line.separator\"));\n        valid = false;\n    }\n    return valid;\n}","628":"public static boolean newVersionReleased(MavenJarFile jarFile, URL jarRepository) throws IOException, XMLStreamException {\n    String currentVersionNumber = jarFile.getVersionNumber();\n    if (currentVersionNumber.contains(\"b\") || currentVersionNumber.contains(\"beta\")) {\n        return false;\n    }\n    boolean newVersion = false;\n    String versionRepoURLString = new StringBuilder(jarRepository.toExternalForm()).append(jarFile.getGroupId().replaceAll(\"\\\\.\", \"\/\")).append(\"\/\").append(jarFile.getArtifactId()).append(\"\/maven-metadata.xml\").toString();\n    String latestRemoteRelease = WebDAO.getLatestVersionNumberFromRemoteRepo(new URL(versionRepoURLString));\n    if (latestRemoteRelease != null && new CompareVersionNumbers().compare(currentVersionNumber, latestRemoteRelease) == 1) {\n        newVersion = true;\n    }\n    return newVersion;\n}","629":"public File writeStreamToDisk(InputStream in, String name, File outputLocationFolder) throws FileNotFoundException, IOException {\n    if (!outputLocationFolder.exists()) {\n        if (!outputLocationFolder.mkdirs()) {\n            throw new IOException(\"Could not create the folder \\'\" + outputLocationFolder.getAbsolutePath() + \"\\' to write stream to disk.\");\n        }\n    }\n    File outputFile = new File(outputLocationFolder, name);\n    FileOutputStream out = null;\n    try {\n        out = new FileOutputStream(outputFile);\n        IOUtils.copyLarge(in, out);\n    } finally {\n        if (out != null) {\n            out.close();\n        }\n    }\n    in.close();\n    return outputFile;\n}","630":"\/**\n * Write a comment line as '# key: value'.\n *\n * @param key the key\n * @param value the value\n *\/\npublic void writeComment(String key, String value) {\n    String line = String.join(\"\", \"# \", key, \": \", value);\n    logWriter.writeLine(line);\n}","631":"public void writeHeaders() {\n    logWriter.writeLine(\"time\", \"type\", \"log\");\n}","632":"public void logError(String message) {\n    String now = Instant.now().toString();\n    logWriter.writeLine(now, \"Error\", \"\\\"\" + message.replace(Util.LINE_SEPARATOR, \" \") + \"\\\"\");\n}","633":"public static IPatternFingerprinter makePatternFingerprint(Collection<String> keyCollection, Collection<Double> valueCollection) {\n    List<IFeature> features = new ArrayList<>();\n    List<String> keyList = new ArrayList<>(keyCollection);\n    List<Double> valueList = new ArrayList<>(valueCollection);\n    for (int index = 0; index < keyList.size(); index++) {\n        String key = keyList.get(index);\n        Double value = valueList.get(index);\n        features.add(new Feature(key, value));\n    }\n    return new PatternFingerprinter(features);\n}","634":"@Override\npublic synchronized void addBinary(BitSet fingerprint) throws CDKException {\n    if (featureSet == null) {\n        throw new CDKException(\"Cannot perform PatternFingerprint.add() as Fingerprint not initialized\");\n    }\n    for (int i = 0; i < fingerprint.size(); i++) {\n        if (fingerprint.get(i)) {\n            add(new Feature(valueOf(i), 1.0));\n        }\n    }\n}","635":"@Override\npublic synchronized BitSet getFingerprint(IAtomContainer mol) throws CDKException {\n    if (!has2DCoordinates(mol)) {\n        StructureDiagramGenerator structureDiagramGenerator = new StructureDiagramGenerator();\n        structureDiagramGenerator.setMolecule(mol, true);\n        if (isConnected(mol)) {\n            structureDiagramGenerator.generateCoordinates();\n            mol = structureDiagramGenerator.getMolecule();\n        } else {\n            LOGGER.debug(\"Disconnected components needs to be layout separately\");\n        }\n    }\n    return fingerprinter.getBitFingerprint(mol).asBitSet();\n}","636":"@Override\npublic int compare(MolFingerprint o1, MolFingerprint o2) {\n    int len1 = o1.getBooleanArray().length;\n    int len2 = o2.getBooleanArray().length;\n    int n = min(len1, len2);\n    if (len1 == len2) {\n        if (o1.equals(o2)) {\n            return 0;\n        } else {\n            return -1;\n        }\n    }\n    return max(len1, len2) - n;\n}","637":"\/**\n * @param molSet\n * @throws CDKException\n *\/\nprivate static IPatternFingerprinter getSumOfFingerprints(IAtomContainerSet molSet) throws CDKException, Exception {\n    FingerprintGenerator molFingerprint = new FingerprintGenerator();\n    IPatternFingerprinter fp = new PatternFingerprinter(getFingerprinterSize());\n    for (IAtomContainer mol : molSet.atomContainers()) {\n        BitSet booleanArray = molFingerprint.getFingerprint(mol);\n        for (int i = 0; i < booleanArray.size(); i++) {\n            if (booleanArray.get(i)) {\n                fp.add(new Feature(valueOf(i), 1.0));\n            }\n        }\n    }\n    return fp;\n}","638":"private static IPatternFingerprinter summationPatterns(IPatternFingerprinter pattern1, IPatternFingerprinter pattern2) throws CDKException {\n    PatternFingerprinter patternFingerprinter = null;\n    if (pattern1 != null && pattern2 != null && pattern1.getFingerprintSize() == pattern2.getFingerprintSize()) {\n        patternFingerprinter = new PatternFingerprinter(pattern1.getFingerprintSize());\n        patternFingerprinter.add(pattern1);\n        patternFingerprinter.add(pattern2);\n    } else {\n        throw new CDKException(\"Index < 0: \");\n    }\n    return patternFingerprinter;\n}","639":"\/**\n * Determine if this set is an (improper) subset of another.\n *\n * @param source the set we are testing for.\n * @param destination the set we are testing against.\n * @return source is a subset of destination, yes then return true else\n * false\n * @throws CDKException\n *\/\npublic static boolean isSubset(BitSet source, BitSet destination) throws CDKException {\n    boolean flag = false;\n    if (source.cardinality() <= destination.cardinality()) {\n        not_null(source);\n        \/* make a copy of the source set *\/\n        BitSet copy_other = (BitSet) source.clone();\n        \/* and or in *\/\n        copy_other.and(destination);\n        \/* if it hasn't changed, we were a subset *\/\n        flag = copy_other.equals(source);\n    }\n    return flag;\n}","640":"public static boolean isSuperSet(BitSet source, BitSet destination) throws CDKException {\n    boolean flag = false;\n    if (source.cardinality() >= destination.cardinality()) {\n        not_null(source);\n        BitSet copy_other = (BitSet) source.clone();\n        copy_other.and(destination);\n        flag = copy_other.equals(destination);\n    }\n    return flag;\n}","641":"\/**\n * @param Molecule1 BitSet\n * @param Molecule2 BitSet\n * @return <B>Similarity <U>Tanimoto, Jaccard<\/U> <\/B>\n * <B>c\/(a+b-c)><\/B>\n * @throws java.lang.Exception\n *\/\npublic static synchronized float getTanimotoSimilarity(BitSet Molecule1, BitSet Molecule2) throws Exception {\n    BitSet bitset1 = (BitSet) Molecule1.clone();\n    BitSet bitset2 = (BitSet) Molecule2.clone();\n    float _bitset1_cardinality = bitset1.cardinality();\n    float _bitset2_cardinality = bitset2.cardinality();\n    \/\/        System.out.println(\"bitset1: \"+ bitset1.size() + \" \" + \" bitset2\" + bitset2.size());\n    if (bitset1.size() != bitset2.size()) {\n        throw new Exception(\"BitSets must have the same bit length\");\n    }\n    BitSet one_and_two = (BitSet) bitset1.clone();\n    one_and_two.and(bitset2);\n    float _common_bit_count = one_and_two.cardinality();\n    return _common_bit_count \/ (_bitset1_cardinality + _bitset2_cardinality - _common_bit_count);\n}","642":"public static synchronized double getCosineSimilarity(BitSet Molecule1, BitSet Molecule2) throws Exception {\n    BitSet bitset1 = (BitSet) Molecule1.clone();\n    BitSet bitset2 = (BitSet) Molecule2.clone();\n    float _bitset1_cardinality = bitset1.cardinality();\n    float _bitset2_cardinality = bitset2.cardinality();\n    if (bitset1.size() != bitset2.size()) {\n        throw new Exception(\"Bisets must have the same bit length\");\n    }\n    BitSet one_and_two = (BitSet) bitset1.clone();\n    one_and_two.and(bitset2);\n    float _common_bit_count = one_and_two.cardinality();\n    return _common_bit_count \/ (sqrt(_bitset1_cardinality * _bitset2_cardinality));\n}","643":"public static synchronized double getDiceSimilarity(BitSet Molecule1, BitSet Molecule2) throws Exception {\n    BitSet bitset1 = (BitSet) Molecule1.clone();\n    BitSet bitset2 = (BitSet) Molecule2.clone();\n    float _bitset1_cardinality = bitset1.cardinality();\n    float _bitset2_cardinality = bitset2.cardinality();\n    if (bitset1.size() != bitset2.size()) {\n        throw new Exception(\"Bisets must have the same bit length\");\n    }\n    BitSet one_and_two = (BitSet) bitset1.clone();\n    one_and_two.and(bitset2);\n    float _common_bit_count = one_and_two.cardinality();\n    return 2 * _common_bit_count \/ (_bitset1_cardinality + _bitset2_cardinality);\n}","644":"\/**\n * @param centralAtom\n * @param atomContainer\n * @param angleMap\n * @return\n *\/\n@Override\npublic IStereoElement execute(IAtom centralAtom, IAtomContainer atomContainer, SortedMap<Double, IBond> angleMap) {\n    int[] permutation = getMatchPermutation();\n    List<IBond> bonds = new ArrayList<>(angleMap.values());\n    IAtom[] ligandAtoms = new IAtom[4];\n    for (int index = 0; index < 4; index++) {\n        IBond bond = bonds.get(permutation[index]);\n        ligandAtoms[index] = bond.getOther(centralAtom);\n    }\n    return new TetrahedralChirality(centralAtom, ligandAtoms, getStereo());\n}","645":"@Override\npublic IStereoElement execute(IAtom centralAtom, IAtomContainer atomContainer, SortedMap<Double, IBond> angleMap) {\n    int[] permutation = getMatchPermutation();\n    List<IBond> bonds = new ArrayList<>(angleMap.values());\n    IAtom[] ligandAtoms = new IAtom[4];\n    for (int index = 0; index < 4; index++) {\n        IBond bond = bonds.get(permutation[index]);\n        ligandAtoms[index] = bond.getOther(centralAtom);\n    }\n    ITetrahedralChirality.Stereo chirality = CLOCKWISE;\n    return new TetrahedralChirality(centralAtom, ligandAtoms, chirality);\n}","646":"@Override\npublic IStereoElement execute(IAtom centralAtom, IAtomContainer atomContainer, SortedMap<Double, IBond> angleMap) {\n    int[] permutation = getMatchPermutation();\n    List<IBond> bonds = new ArrayList<>(angleMap.values());\n    IAtom[] ligandAtoms = new IAtom[4];\n    for (int index = 0; index < 4; index++) {\n        IBond bond = bonds.get(permutation[index]);\n        ligandAtoms[index] = bond.getOther(centralAtom);\n    }\n    ITetrahedralChirality.Stereo chirality = ANTI_CLOCKWISE;\n    return new TetrahedralChirality(centralAtom, ligandAtoms, chirality);\n}","647":"@Override\npublic Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer, boolean getNoneAssesments) {\n    Map<IAtom, IStereoAndConformation> chiralities = new HashMap<>();\n    WedgeStereoLifter lifter = new WedgeStereoLifter();\n    for (IAtom atom : atomContainer.atoms()) {\n        IStereoAndConformation chirality = getChirality2D(lifter, atom, atomContainer);\n        if (getNoneAssesments || chirality != NONE) {\n            chiralities.put(atom, chirality);\n        }\n    }\n    return chiralities;\n}","648":"\/**\n * Creates mapping PDFs for all the processed reaction mappings\n *\n * @param reactor\n * @param outputDirectoryName\n * @param outFileName\n * @throws Exception\n *\/\npublic static synchronized void writeMappingRXN(Reactor reactor, String outputDirectoryName, String outFileName) throws Exception {\n    String reactionID = reactor.getReactionWithAtomAtomMapping().getID();\n    IReaction mappedReaction = reactor.getReactionWithAtomAtomMapping();\n    if (reactionID == null) {\n        reactionID = valueOf(currentTimeMillis());\n        reactor.getReactionWithAtomAtomMapping().setID(reactionID);\n    }\n    String outputFile = outputDirectoryName;\n    outputFile += separator + outFileName;\n    try (MDLV2000RXNWriter rxnW = new MDLV2000RXNWriter(new FileWriter(new File(outputFile)))) {\n        rxnW.write(mappedReaction);\n    }\n}","649":"@Override\npublic synchronized boolean getReactionBalanceFlag() throws IOException {\n    boolean flag = true;\n    if (!Objects.equals(this.getLabledReactantAtomsCount(), this.getLabledProductAtomsCount())) {\n        flag = false;\n    }\n    if (!getReactionBalanceFlagWithoutHydrogen()) {\n        flag = false;\n    }\n    return flag;\n}","650":"private synchronized List<IAtom> getLabledReactantAtoms() {\n    List<IAtom> reactantAtoms = new ArrayList<>();\n    IAtomContainerSet MSet = reactionWithUniqueSTOICHIOMETRY.getReactants();\n    for (int j = 0; j < MSet.getAtomContainerCount(); j++) {\n        IAtomContainer M = MSet.getAtomContainer(j);\n        for (int k = 0; k < M.getAtomCount(); k++) {\n            reactantAtoms.add(M.getAtom(k));\n        }\n    }\n    return unmodifiableList(reactantAtoms);\n}","651":"private synchronized List<IAtom> getLabledProductAtoms() {\n    List<IAtom> productAtoms = new ArrayList<>();\n    IAtomContainerSet MSet = reactionWithUniqueSTOICHIOMETRY.getProducts();\n    for (int j = 0; j < MSet.getAtomContainerCount(); j++) {\n        IAtomContainer M = MSet.getAtomContainer(j);\n        for (int k = 0; k < M.getAtomCount(); k++) {\n            productAtoms.add(M.getAtom(k));\n        }\n    }\n    return unmodifiableList(productAtoms);\n}","652":"@Override\npublic AbstractVertexSignature signatureForVertex(int subgraphAtomIndex) {\n    if (useAdjLists) {\n        int actualIndex = indexLookup.get(subgraphAtomIndex);\n        return new SubgraphAtomSignature(atomContainer, actualIndex, subgraphAdjacencyLists);\n    } else {\n        return new SubgraphAtomSignature(atomContainer, subgraphAtomIndex);\n    }\n}","653":"private void search(DefinedMapping vertex, int currentLabel, int[] labels, List<DefinedMapping> component) {\n    if (vertex.isVisited()) {\n    } else {\n        vertex.setVisited(true);\n        labels[vertex.getIndex()] = currentLabel;\n        component.add(vertex);\n        adjacencyTable[vertex.getIndex()].stream().forEach((neighbour) -> {\n            if (neighbour.isVisited()) {\n            } else {\n                search(neighbour, currentLabel, labels, component);\n            }\n        });\n    }\n}","654":"@Override\npublic synchronized boolean isValuePresent(BitSet value) throws IOException {\n    for (BitSet bitset : fingerPrintMap.values()) {\n        try {\n            if (getTanimotoSimilarity(value, bitset) == 1.0) {\n                return true;\n            }\n        } catch (Exception ex) {\n            LOGGER.error(SEVERE, null, ex);\n        }\n    }\n    return false;\n}","655":"@Override\npublic synchronized AtomAtomMapping getAtomMatch(int indexI, int indexJ) throws IOException {\n    IKey key = new Key(indexI, indexJ);\n    if (mcsAtomMap.containsKey(key)) {\n        return mcsAtomMap.get(key);\n    } else {\n        try {\n            throw new CDKException(\"Key not found:\" + key + \" in \" + mcsAtomMap.keySet());\n        } catch (CDKException ex) {\n            LOGGER.error(SEVERE, null, ex);\n        }\n    }\n    return null;\n}","656":"public synchronized String getDefination(String _recID) {\n    String _data = null;\n    if (reactionMap.containsKey(_recID)) {\n        Map<String, ReactionFileData> DataMap = reactionMap.get(_recID);\n        if (DataMap.containsKey(defin)) {\n            _data = DataMap.get(defin).getValue(0);\n        }\n    }\n    return _data.trim();\n}","657":"public synchronized String getEntry(String _recID) {\n    String _data = null;\n    if (reactionMap.containsKey(_recID)) {\n        Map<String, ReactionFileData> DataMap = reactionMap.get(_recID);\n        if (DataMap.containsKey(entry)) {\n            _data = DataMap.get(entry).getValue(0);\n        }\n    }\n    return _data.trim();\n}","658":"public synchronized String getEquation(String _recID) {\n    String _data = null;\n    if (reactionMap.containsKey(_recID)) {\n        Map<String, ReactionFileData> DataMap = reactionMap.get(_recID);\n        if (DataMap.containsKey(equat)) {\n            _data = DataMap.get(equat).getValue(0);\n        }\n    }\n    return _data.trim();\n}","659":"synchronized public String getName(String _recID) {\n    String _data = null;\n    if (reactionMap.containsKey(_recID)) {\n        Map<String, ReactionFileData> DataMap = reactionMap.get(_recID);\n        if (DataMap.containsKey(name)) {\n            _data = DataMap.get(name).getValue(0).trim();\n        }\n    }\n    return _data;\n}","660":"public synchronized String getRpair(String _recID) {\n    String _data = null;\n    if (reactionMap.containsKey(_recID)) {\n        Map<String, ReactionFileData> DataMap = reactionMap.get(_recID);\n        if (DataMap.containsKey(rpair)) {\n            _data = DataMap.get(rpair).getValue(0);\n        }\n    }\n    return _data.trim();\n}","661":"protected synchronized boolean isMajorSubgraphColumn(Holder mh, int IndexI, int IndexJ) throws IOException, CDKException {\n    double queryColScore = mh.getCliqueMatrix().getValue(IndexI, IndexJ);\n    if (queryColScore > 0) {\n        for (int col = 0; col < colSize; col++) {\n            if (flagMatrix[IndexI][col] && col != IndexJ) {\n                double colCSize = mh.getCliqueMatrix().getValue(IndexI, col);\n                if (queryColScore < colCSize) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}","662":"protected synchronized boolean isMajorSubgraphRow(Holder mh, int IndexI, int IndexJ) throws IOException, CDKException {\n    double queryRowScore = mh.getCliqueMatrix().getValue(IndexI, IndexJ);\n    if (queryRowScore > 0) {\n        for (int row = 0; row < rowSize; row++) {\n            if (flagMatrix[row][IndexJ] && row != IndexI) {\n                int eSize = mh.getReactionContainer().getEduct(row).getAtomCount();\n                double rowRSize = mh.getCliqueMatrix().getValue(row, IndexJ);\n                if (queryRowScore < rowRSize) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}","663":"protected synchronized boolean isMinEnergyColumn(Holder mh, int IndexI, int IndexJ) throws IOException, CDKException {\n    double refEnergy = mh.getEnergyMatrix().getValue(IndexI, IndexJ);\n    if (mh.getCliqueMatrix().getValue(IndexI, IndexJ) > 0) {\n        for (int col = 0; col < colSize; col++) {\n            if (flagMatrix[IndexI][col] && col != IndexJ) {\n                double colEnergy = mh.getEnergyMatrix().getValue(IndexI, col);\n                if (refEnergy > 0 && colEnergy > 0 && refEnergy > colEnergy) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}","664":"protected synchronized boolean isMinorSubgraphColumn(Holder mh, int IndexI, int IndexJ) throws IOException, CDKException {\n    boolean flag = true;\n    double queryColScore = mh.getCliqueMatrix().getValue(IndexI, IndexJ);\n    if (queryColScore > 0.) {\n        for (int col = 0; col < colSize; col++) {\n            if (flagMatrix[IndexI][col] && col != IndexJ) {\n                double targetColScore = mh.getCliqueMatrix().getValue(IndexI, col);\n                if (queryColScore > targetColScore && targetColScore > 0.) {\n                    return true;\n                }\n            }\n        }\n    }\n    return flag;\n}","665":"protected synchronized boolean isMinorSubgraphRow(Holder mh, int IndexI, int IndexJ) {\n    boolean flag = true;\n    double queryRowScore = mh.getCliqueMatrix().getValue(IndexI, IndexJ);\n    if (queryRowScore > 0.) {\n        for (int row = 0; row < rowSize; row++) {\n            if (flagMatrix[row][IndexJ] && row != IndexI) {\n                double targetRowScore = mh.getCliqueMatrix().getValue(row, IndexJ);\n                if (queryRowScore > targetRowScore && targetRowScore > 0.) {\n                    return false;\n                }\n            }\n        }\n    }\n    return flag;\n}","666":"protected synchronized boolean isMinorSubgraphColumn(EBIMatrix similarityMatrix, int IndexI, int IndexJ) {\n    boolean flag = true;\n    double queryColScore = similarityMatrix.getValue(IndexI, IndexJ);\n    if (queryColScore > 0.) {\n        for (int col = 0; col < colSize; col++) {\n            if (flagMatrix[IndexI][col] && col != IndexJ) {\n                double targetColScore = similarityMatrix.getValue(IndexI, col);\n                if (queryColScore > targetColScore && targetColScore > 0.) {\n                    return true;\n                }\n            }\n        }\n    }\n    return flag;\n}","667":"protected synchronized boolean isMinorSubgraphRow(EBIMatrix similarityMatrix, int IndexI, int IndexJ) {\n    boolean flag = true;\n    double queryRowScore = similarityMatrix.getValue(IndexI, IndexJ);\n    if (queryRowScore > 0.) {\n        for (int row = 0; row < rowSize; row++) {\n            if (flagMatrix[row][IndexJ] && row != IndexI) {\n                double targetRowScore = similarityMatrix.getValue(row, IndexJ);\n                if (queryRowScore > targetRowScore && targetRowScore > 0.) {\n                    return false;\n                }\n            }\n        }\n    }\n    return flag;\n}","668":"protected synchronized boolean isMajorSubgraphColumn(EBIMatrix similarityMatrix, int IndexI, int IndexJ) {\n    double queryColumnscore = similarityMatrix.getValue(IndexI, IndexJ);\n    if (queryColumnscore > 0) {\n        for (int col = 0; col < colSize; col++) {\n            if (flagMatrix[IndexI][col] && col != IndexJ) {\n                double colCSize = similarityMatrix.getValue(IndexI, col);\n                if (queryColumnscore < colCSize) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}","669":"protected synchronized boolean isMajorSubgraphRow(EBIMatrix similarityMatrix, int IndexI, int IndexJ) {\n    double queryRowScore = similarityMatrix.getValue(IndexI, IndexJ);\n    if (queryRowScore > 0) {\n        for (int row = 0; row < rowSize; row++) {\n            if (flagMatrix[row][IndexJ] && row != IndexI) {\n                double rowRSize = similarityMatrix.getValue(row, IndexJ);\n                if (queryRowScore < rowRSize) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}","670":"public synchronized boolean getFlag() {\n    for (int i = 0; i < rowSize; i++) {\n        for (int j = 0; j < colSize; j++) {\n            if (this.flagMatrix[i][j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n}","671":"private List getCanNeigh(final IAtom a, final IAtomContainer container, final int[] canonicalLabels) {\n    List<IAtom> v = container.getConnectedAtomsList(a);\n    if (v.size() > 1) {\n        sort(v, (IAtom a1, IAtom a2) -> {\n            int l1 = canonicalLabels[container.indexOf(a1)];\n            int l2 = canonicalLabels[container.indexOf(a2)];\n            if (l1 < l2) {\n                return -1;\n            } else if (l1 > l2) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n    }\n    return v;\n}","672":"@Override\npublic int[] getCanonicalPermutation(IAtomContainer container) {\n    RBlastMoleculeSignature molSig = new RBlastMoleculeSignature(container);\n    if (height == -1) {\n        return molSig.getAtomSignature(atomIndex).getCanonicalLabelling(container.getAtomCount());\n    } else {\n        return molSig.getAtomSignature(atomIndex, height).getCanonicalLabelling(container.getAtomCount());\n    }\n}","673":"@Override\nprotected int[] getConnected(int atomIndex) {\n    List<IAtom> connectedAtoms = atomContainer.getConnectedAtomsList(atomContainer.getAtom(atomIndex));\n    int[] connected = new int[connectedAtoms.size()];\n    int i = 0;\n    for (IAtom connectedAtom : connectedAtoms) {\n        connected[i] = atomContainer.indexOf(connectedAtom);\n        i++;\n    }\n    return connected;\n}","674":"private RBlastAtomSignature match(int atomIndex, List<String> signatureStrings, RBlastMoleculeSignature moleculeSignature) {\n    for (int height = maxHeight; height >= minHeight; height--) {\n        RBlastAtomSignature sigOfHAtI = moleculeSignature.getAtomSignature(atomIndex, height);\n        String signatureStringOfHAtI = sigOfHAtI.toCanonicalString();\n        for (String querySignatureString : signatureStrings) {\n            if (querySignatureString.equals(signatureStringOfHAtI)) {\n                out.println(\"match of height \" + height + \" at \" + atomIndex + \" to \" + querySignatureString);\n                return sigOfHAtI;\n            }\n        }\n    }\n    return null;\n}","675":"@Override\npublic synchronized boolean isValuePresent(BitSet value) throws IOException {\n    for (BitSet bitset : FingerPrintMap.values()) {\n        try {\n            if (getTanimotoSimilarity(value, bitset) == 1.0) {\n                return true;\n            }\n        } catch (Exception ex) {\n            LOGGER.error(SEVERE, null, ex);\n        }\n    }\n    return false;\n}","676":"@Override\npublic synchronized boolean compareAtomContainer(String key, IAtomContainer mol) throws Exception {\n    mol = removeHydrogensExceptSingleAndPreserveAtomID(mol);\n    try {\n        boolean flag = molContainer.containsKey(key);\n        if (flag && mol.getAtomCount() > 0) {\n            IAtomContainer molFromContainer = molContainer.get(key);\n            return isIdentical(mol, molFromContainer, true);\n        }\n    } catch (Exception ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    return false;\n}","677":"public static boolean isSubset(double[] query, double[] target) throws CDKException {\n    if (query.length != target.length) {\n        throw new CDKException(\"Unequal Fingerprint size can't be processed\");\n    }\n    for (int i = 0; i < query.length; i++) {\n        if (query[i] > target[i]) {\n            return false;\n        }\n    }\n    return true;\n}","678":"public static boolean isSubset(IPatternFingerprinter query, IPatternFingerprinter target) throws CDKException {\n    if (query.getFingerprintSize() != target.getFingerprintSize()) {\n        throw new CDKException(\"Unequal Fingerprint size can't be processed\");\n    }\n    BitSet q = query.getHashedFingerPrint();\n    BitSet t = target.getHashedFingerPrint();\n    for (int i = 0; i < q.length(); i++) {\n        if (!(t.get(i) & q.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}","679":"public static double getSimilarity(IPatternFingerprinter fp1, IPatternFingerprinter fp2) throws CDKException, Exception {\n    double score = 0.0;\n    int size1 = fp1.getFingerprintSize();\n    int size2 = fp2.getFingerprintSize();\n    if (size1 != size2) {\n        throw new CDKException(\"Features vectors must be of the same length\");\n    } else {\n        double[] structFeatures1 = fp1.getWeightedHashedFingerPrint();\n        double[] structFeatures2 = fp2.getWeightedHashedFingerPrint();\n        score = getSimilarity(structFeatures1, structFeatures2);\n    }\n    return score;\n}","680":"public EBIMatrix getS() {\n    EBIMatrix X = new EBIMatrix(n, n);\n    double[][] S = X.getArray();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            S[i][j] = 0.0;\n        }\n        S[i][i] = this.s[i];\n    }\n    return X;\n}","681":"public int rank() {\n    double eps = pow(2.0, -52.0);\n    double tol = max(m, n) * s[0] * eps;\n    int r = 0;\n    for (int i = 0; i < s.length; i++) {\n        if (s[i] > tol) {\n            r++;\n        }\n    }\n    return r;\n}","682":"public EBIMatrix getU() {\n    EBIMatrix X = new EBIMatrix(n, n);\n    double[][] U = X.getArray();\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i <= j) {\n                U[i][j] = LU[i][j];\n            } else {\n                U[i][j] = 0.0;\n            }\n        }\n    }\n    return X;\n}","683":"public EBIMatrix getH() {\n    EBIMatrix X = new EBIMatrix(m, n);\n    double[][] H = X.getArray();\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i >= j) {\n                H[i][j] = QR[i][j];\n            } else {\n                H[i][j] = 0.0;\n            }\n        }\n    }\n    return X;\n}","684":"private int rankPermutationLexicographically(int[] permutation) {\n    int rank = 0;\n    int n = permutation.length;\n    int[] counter = new int[n + 1];\n    arraycopy(permutation, 0, counter, 1, n);\n    for (int j = 1; j <= n; j++) {\n        rank += ((counter[j] - 1) * factorial(n - j));\n        for (int i = j + 1; i < n; i++) {\n            if (counter[i] > counter[j]) {\n                counter[i]--;\n            }\n        }\n    }\n    return rank;\n}","685":"private int[] unrankPermutationLexicographically(int rank, int size) {\n    int[] permutation = new int[size + 1];\n    permutation[size] = 1;\n    for (int j = 1; j < size; j++) {\n        int d = (rank % factorial(j + 1)) \/ factorial(j);\n        rank -= d * factorial(j);\n        permutation[size - j] = d + 1;\n        for (int i = size - j + 1; i <= size; i++) {\n            if (permutation[i] > d) {\n                permutation[i]++;\n            }\n        }\n    }\n    int[] shiftedPermutation = new int[size];\n    for (int i = 1; i < permutation.length; i++) {\n        shiftedPermutation[i - 1] = permutation[i] - 1;\n    }\n    return shiftedPermutation;\n}","686":"protected Map<IAtom, IAtom> atomAtomMap(IReaction reaction, IReaction clone, Map<IAtomContainer, int[]> permutationMap) {\n    Map<IAtom, IAtom> atomAtom = new Hashtable<>();\n    IAtomContainerSet reactants = reaction.getReactants();\n    IAtomContainerSet clonedReactants = clone.getReactants();\n    atomAtomMap(reactants, clonedReactants, permutationMap, atomAtom);\n    IAtomContainerSet products = reaction.getProducts();\n    IAtomContainerSet clonedProducts = clone.getProducts();\n    atomAtomMap(products, clonedProducts, permutationMap, atomAtom);\n    return atomAtom;\n}","687":"protected Map<IChemObject, Integer> makeIndexMap(IReaction reaction) {\n    Map<IChemObject, Integer> indexMap = new HashMap<>();\n    List<IAtomContainer> all = getAllAtomContainers(reaction);\n    int globalIndex = 0;\n    for (IAtomContainer ac : all) {\n        for (IAtom atom : ac.atoms()) {\n            indexMap.put(atom, globalIndex);\n            globalIndex++;\n        }\n    }\n    return indexMap;\n}","688":"@Override\npublic int[] getCanonicalPermutation(IAtomContainer container) {\n    long[] labels;\n    try {\n        labels = getUSmilesNumbers(container);\n    } catch (CDKException ex) {\n        labels = label(container, toAdjList(container));\n        LOGGER.error(SEVERE, null, ex);\n    }\n    int[] permute = new int[labels.length];\n    for (int i = 0; i < labels.length; i++) {\n        permute[i] = (int) labels[i] - 1;\n    }\n    return permute;\n}","689":"\/**\n * @param mol\n * @return\n *\/\npublic static IAtomContainer getMoleculeWithLayoutCheck(IAtomContainer mol) {\n    if (!has2DCoordinates(mol)) {\n        try {\n            StructureDiagramGenerator sdg = new StructureDiagramGenerator(new AtomContainer(mol));\n            sdg.generateCoordinates();\n            mol = sdg.getMolecule();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    return mol;\n}","690":"\/**\n * @param checkAromaticity\n * @return\n *\/\n@Override\npublic int getHBondAcceptors(boolean checkAromaticity) {\n    IMolecularDescriptor acc = new HBondAcceptorCountDescriptor();\n    Object[] hBondparams = { checkAromaticity };\n    try {\n        acc.setParameters(hBondparams);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    int acceptors = ((IntegerResult) acc.calculate(molecule).getValue()).intValue();\n    return acceptors;\n}","691":"@Override\npublic int getHBondDoners(boolean checkAromaticity) {\n    IMolecularDescriptor don = new HBondDonorCountDescriptor();\n    Object[] hBondparams = { checkAromaticity };\n    try {\n        don.setParameters(hBondparams);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    int donors = ((IntegerResult) don.calculate(molecule).getValue()).intValue();\n    return donors;\n}","692":"@Override\npublic double getXlogP(boolean checkAromaticity) {\n    IMolecularDescriptor xlogP = new XLogPDescriptor();\n    Object[] xlogPparams = { checkAromaticity, TRUE };\n    try {\n        xlogP.setParameters(xlogPparams);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    double xlogPvalue = ((DoubleResult) xlogP.calculate(molecule).getValue()).doubleValue();\n    return xlogPvalue;\n}","693":"@Override\npublic double getTPSADescriptor(boolean checkAromaticity) {\n    TPSADescriptor tpsa = new TPSADescriptor();\n    Object[] tpsaParameter = { checkAromaticity };\n    try {\n        tpsa.setParameters(tpsaParameter);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    double tpsaValue = ((DoubleResult) tpsa.calculate(molecule).getValue()).doubleValue();\n    return tpsaValue;\n}","694":"@Override\npublic double getMolecularWeight() {\n    WeightDescriptor mw = new WeightDescriptor();\n    Object[] mwparams = { \"*\" };\n    try {\n        mw.setParameters(mwparams);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    double value = ((DoubleResult) mw.calculate(molecule).getValue()).doubleValue();\n    return value;\n}","695":"@Override\npublic int getRotatableBondsCountDescriptor(boolean includeTerminals, boolean excludeAmides) {\n    RotatableBondsCountDescriptor rbcd = new RotatableBondsCountDescriptor();\n    Object[] params = { includeTerminals, excludeAmides };\n    int value = -1;\n    try {\n        rbcd.setParameters(params);\n        value = ((IntegerResult) rbcd.calculate(molecule).getValue()).intValue();\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    return value;\n}","696":"@Override\npublic int getLargestPiSystemDescriptor(boolean checkAromaticity) {\n    LargestPiSystemDescriptor lps = new LargestPiSystemDescriptor();\n    Object[] mwparams = { checkAromaticity };\n    try {\n        lps.setParameters(mwparams);\n    } catch (CDKException ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    int value = ((IntegerResult) lps.calculate(molecule).getValue()).intValue();\n    return value;\n}","697":"\/**\n * @param map\n * @return\n *\/\npublic static synchronized Map<Object, Double> valueInAscendingOrder(Map<Object, Double> map) {\n    List<Map.Entry<Object, Double>> list = new LinkedList<>(map.entrySet());\n    \/\/ Sort the list using an annonymous inner class implementing Comparator for the compare method\n    \/\/ Return 0 for bond match, -1 for less than and +1 for more then (Aceending Order Sort)\n    sort(\/\/ Return 0 for bond match, -1 for less than and +1 for more then (Aceending Order Sort)\n    list, \/\/ Return 0 for bond match, -1 for less than and +1 for more then (Aceending Order Sort)\n    (Map.Entry<Object, Double> entry, Map.Entry<Object, Double> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() > entry1.getValue() ? 1 : -1)));\n    \/\/ LOGGER.info(list);\n    Map<Object, Double> result = new LinkedHashMap<>();\n    list.forEach((entry) -> {\n        result.put(entry.getKey(), entry.getValue());\n    });\n    return result;\n}","698":"public static synchronized Map<Object, Double> valueInDescendingOrder(Map<Object, Double> map) {\n    List<Map.Entry<Object, Double>> list = new LinkedList<>(map.entrySet());\n    sort(list, (Map.Entry<Object, Double> entry, Map.Entry<Object, Double> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() < entry1.getValue() ? 1 : -1)));\n    Map<Object, Double> result = new LinkedHashMap<>();\n    list.forEach((entry) -> {\n        result.put(entry.getKey(), entry.getValue());\n    });\n    return result;\n}","699":"public static synchronized Map<Integer, Integer> intValueInAscendingOrder(Map<Integer, Integer> map) {\n    List<Map.Entry<Integer, Integer>> list = new LinkedList<>(map.entrySet());\n    sort(list, (Map.Entry<Integer, Integer> entry, Map.Entry<Integer, Integer> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() > entry1.getValue() ? 1 : -1)));\n    Map<Integer, Integer> result = new LinkedHashMap<>();\n    list.forEach((entry) -> {\n        result.put(entry.getKey(), entry.getValue());\n    });\n    return result;\n}","700":"public static synchronized Map<Integer, Integer> intValueInDescendingOrder(Map<Integer, Integer> map) {\n    List<Map.Entry<Integer, Integer>> list = new LinkedList<>(map.entrySet());\n    sort(list, (Map.Entry<Integer, Integer> entry, Map.Entry<Integer, Integer> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() < entry1.getValue() ? 1 : -1)));\n    Map<Integer, Integer> result = new LinkedHashMap<>();\n    for (Map.Entry<Integer, Integer> entry : list) {\n        result.put(entry.getKey(), entry.getValue());\n    }\n    return result;\n}","701":"public static synchronized Map<Double, Double> doubleValueInAscendingOrder(Map<Double, Double> map) {\n    List<Map.Entry<Double, Double>> list = new LinkedList<>(map.entrySet());\n    sort(list, (Map.Entry<Double, Double> entry, Map.Entry<Double, Double> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() > entry1.getValue() ? 1 : -1)));\n    Map<Double, Double> result = new LinkedHashMap<>();\n    list.forEach((entry) -> {\n        result.put(entry.getKey(), entry.getValue());\n    });\n    return result;\n}","702":"public static synchronized Map<Double, Double> doubleValueInDescendingOrder(Map<Double, Double> map) {\n    List<Map.Entry<Double, Double>> list = new LinkedList<>(map.entrySet());\n    sort(list, (Map.Entry<Double, Double> entry, Map.Entry<Double, Double> entry1) -> (entry.getValue().equals(entry1.getValue()) ? 0 : (entry.getValue() < entry1.getValue() ? 1 : -1)));\n    Map<Double, Double> result = new LinkedHashMap<>();\n    list.forEach((entry) -> {\n        result.put(entry.getKey(), entry.getValue());\n    });\n    return result;\n}","703":"public File createDirectory(String parentDirName, String childDirName, boolean SUFFIX) throws IOException {\n    if (SUFFIX) {\n        setSuffix();\n        String dirSuffix = getSuffix();\n        childDirName = childDirName.concat(\".\");\n        childDirName = childDirName.concat(dirSuffix);\n        dir = new File(parentDirName, childDirName);\n        createDir();\n    } else {\n        dir = new File(parentDirName, childDirName);\n        createDir();\n    }\n    return dir;\n}","704":"private String formatMDLInt(int i, int l) {\n    String s = \"\", fs = \"\";\n    NumberFormat nf = getNumberInstance(ENGLISH);\n    nf.setParseIntegerOnly(true);\n    nf.setMinimumIntegerDigits(1);\n    nf.setMaximumIntegerDigits(l);\n    nf.setGroupingUsed(false);\n    s = nf.format(i);\n    l -= s.length();\n    for (int f = 0; f < l; f++) {\n        fs += \" \";\n    }\n    fs += s;\n    return fs;\n}","705":"public IAtomContainer getMoleculeWithLayoutCheck() {\n    if (!has2DCoordinates(molecule)) {\n        try {\n            StructureDiagramGenerator sdg = new StructureDiagramGenerator(new AtomContainer(molecule));\n            sdg.generateCoordinates();\n            molecule = sdg.getMolecule();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    return molecule;\n}","706":"private void initIOSettings() {\n    forceWriteAs2DCoords = addSetting(new BooleanIOSetting(OptForceWriteAs2DCoordinates, IOSetting.Importance.LOW, \"Should coordinates always be written as 2D?\", \"false\"));\n    writeMajorIsotopes = addSetting(new BooleanIOSetting(OptWriteMajorIsotopes, IOSetting.Importance.LOW, \"Write atomic mass of any non-null atomic mass including major isotopes (e.g. [12]C)\", \"true\"));\n    writeAromaticBondTypes = addSetting(new BooleanIOSetting(OptWriteAromaticBondTypes, IOSetting.Importance.LOW, \"Should aromatic bonds be written as bond type 4?\", \"false\"));\n    writeQueryFormatValencies = addSetting(new BooleanIOSetting(OptWriteQueryFormatValencies, IOSetting.Importance.LOW, \"Should valencies be written in the MDL Query format? (deprecated)\", \"false\"));\n    writeDefaultProps = addSetting(new BooleanIOSetting(OptWriteDefaultProperties, IOSetting.Importance.LOW, \"Write trailing zero's on atom\/bond property blocks even if they're not used.\", \"true\"));\n}","707":"private static IChemModel newModel(final IAtomContainer container) {\n    if (container == null) {\n        throw new NullPointerException(\"cannot create chem model for a null container\");\n    }\n    final IChemObjectBuilder builder = container.getBuilder();\n    final IChemModel model = builder.newInstance(IChemModel.class);\n    final IAtomContainerSet containers = builder.newInstance(IAtomContainerSet.class);\n    containers.addAtomContainer(container);\n    model.setMoleculeSet(containers);\n    return model;\n}","708":"static String dataHeader(final String line) {\n    if (line.length() > 2 && line.charAt(0) != '>' && line.charAt(1) != ' ') {\n        return null;\n    }\n    int i = line.indexOf('<', 2);\n    if (i < 0) {\n        return null;\n    }\n    int j = line.indexOf('>', i);\n    if (j < 0) {\n        return null;\n    }\n    return line.substring(i + 1, j);\n}","709":"public static EBIMatrix constructWithCopy(double[][] A) {\n    int m = A.length;\n    int n = A[0].length;\n    EBIMatrix X = new EBIMatrix(m, n);\n    double[][] C = X.getArray();\n    for (int i = 0; i < m; i++) {\n        if (A[i].length != n) {\n            throw new IllegalArgumentException(\"All rows must have the same length.\");\n        }\n        arraycopy(A[i], 0, C[i], 0, n);\n    }\n    return X;\n}","710":"public synchronized EBIMatrix getMatrix(int[] r, int[] c) {\n    EBIMatrix X = new EBIMatrix(r.length, c.length);\n    double[][] B = X.getArray();\n    try {\n        for (int i = 0; i < r.length; i++) {\n            for (int j = 0; j < c.length; j++) {\n                B[i][j] = matrix[r[i]][c[j]];\n            }\n        }\n    } catch (ArrayIndexOutOfBoundsException e) {\n        throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n    }\n    return X;\n}","711":"public double contraction() {\n    int i, j;\n    double result = 0d;\n    for (i = 0; i < getRowDimension(); i++) {\n        for (j = 0; j < getColumnDimension(); j++) {\n            result += matrix[i][j];\n        }\n    }\n    return result;\n}","712":"public synchronized double norm1() {\n    double f = 0;\n    for (int j = 0; j < columns; j++) {\n        double s = 0;\n        for (int i = 0; i < rows; i++) {\n            s += abs(matrix[i][j]);\n        }\n        f = max(f, s);\n    }\n    return f;\n}","713":"public synchronized double normInf() {\n    double f = 0;\n    for (int i = 0; i < rows; i++) {\n        double s = 0;\n        for (int j = 0; j < columns; j++) {\n            s += abs(matrix[i][j]);\n        }\n        f = max(f, s);\n    }\n    return f;\n}","714":"\/**\n * @param reaction\n * @return New Standardized reaction Object\n * @throws Exception\n *\/\n@Override\npublic synchronized IReaction standardize(IReaction reaction) throws Exception {\n    String ReactionID = reaction.getID();\n    cleanMapping(reaction);\n    if (ReactionID == null) {\n        ReactionID = Long.toString(currentTimeMillis());\n        reaction.setID(ReactionID);\n    }\n    CDKReactionBuilder rBuilder = new CDKReactionBuilder();\n    IReaction standardizedReaction = rBuilder.standardize(reaction);\n    return standardizedReaction;\n}","715":"public static Integer getFreeValenceElectrons(IAtomContainer m, IAtom atom, boolean skipHydrogen) throws CDKException {\n    initialize();\n    Integer totalConnectedBondOrder = 0;\n    List<IAtom> connectedAtoms = m.getConnectedAtomsList(atom);\n    int counterH = 0;\n    for (IAtom connAtom : connectedAtoms) {\n        if (skipHydrogen && connAtom.getSymbol().equalsIgnoreCase(\"H\")) {\n            counterH++;\n        }\n        IBond bond = m.getBond(atom, connAtom);\n        totalConnectedBondOrder += convertBondOrder(bond);\n    }\n    Integer charge = Objects.equals(atom.getFormalCharge(), UNSET) ? 0 : atom.getFormalCharge();\n    return skipHydrogen ? (getValenceElectron(atom) - totalConnectedBondOrder + counterH - charge) : (getValenceElectron(atom) - totalConnectedBondOrder - charge);\n}","716":"public static String[] getElements() {\n    initialize();\n    String[] st = new String[valencElectronMap.size()];\n    int i = 0;\n    for (String s : valencElectronMap.keySet()) {\n        st[i++] = s;\n    }\n    return st;\n}","717":"\/**\n * @param Molecule1 BitSet\n * @param Molecule2 BitSet\n * <B>Note:<\/B> Can be Normalized to the range 1 to 0 if all attributes are\n * normalized to this range and the result is divided in N\n * @return <B>Distance (Dissimilarity) <U>Euclidean<\/U><\/B>\n * <B>sqrt(a+b-2c)<\/B>\n * <B>sqrt(OnA+OnB-2*c)<\/B>\n * @throws java.lang.Exception\n *\/\npublic static double getEuclideanDistance(BitSet Molecule1, BitSet Molecule2) throws Exception {\n    A = (BitSet) Molecule1.clone();\n    B = (BitSet) Molecule2.clone();\n    float _bitset1_cardinality = A.cardinality();\n    float _bitset2_cardinality = B.cardinality();\n    if (A.size() != B.size()) {\n        throw new Exception(\"Bisets must have the same bit length\");\n    }\n    BitSet one_and_two = (BitSet) A.clone();\n    one_and_two.and(B);\n    float _common_bit_count = one_and_two.cardinality();\n    double Val = sqrt((_bitset1_cardinality + _bitset2_cardinality - _common_bit_count) - _common_bit_count);\n    return Val;\n}","718":"\/\/    \/**\n\/\/     *\n\/\/     * @param reaction\n\/\/     *\/\n\/\/    protected void setLonePairs(IReaction reaction) {\n\/\/        LonePairElectronChecker checker = new LonePairElectronChecker();\n\/\/        setLonePairs(reaction.getReactants(), checker);\n\/\/        setLonePairs(reaction.getProducts(), checker);\n\/\/    }\n\/\/\n\/\/    \/**\n\/\/     *\n\/\/     * @param AtomContainerSet\n\/\/     * @param checker\n\/\/     *\/\n\/\/    protected void setLonePairs(IAtomContainerSet AtomContainerSet, LonePairElectronChecker checker) {\n\/\/        for (IAtomContainer atomContainer : AtomContainerSet.atomContainers()) {\n\/\/            try {\n\/\/                checker.saturate(atomContainer);\n\/\/            } catch (CDKException c) {\n\/\/                LOGGER.error(SEVERE, null, c);\n\/\/            }\n\/\/        }\n\/\/    }\n\/\/\n\/\/    \/**\n\/\/     *\n\/\/     * @param reaction\n\/\/     *\/\n\/\/    protected void detectAromaticity(IReaction reaction) {\n\/\/        detectAromaticity(reaction.getReactants());\n\/\/        detectAromaticity(reaction.getProducts());\n\/\/    }\n\/\/\n\/\/    \/**\n\/\/     *\n\/\/     * @param molSet\n\/\/     *\/\n\/\/    protected void detectAromaticity(IAtomContainerSet molSet) {\n\/\/        for (IAtomContainer ac : molSet.atomContainers()) {\n\/\/            try {\n\/\/                aromatizeCDK(ac);\n\/\/            } catch (CDKException e) {\n\/\/                \/\/ TODO Auto-generated catch block\n\/\/                LOGGER.error(e);\n\/\/            }\n\/\/        }\n\/\/    }\n\/\/\n\/\/    \/**\n\/\/     *\n\/\/     * @param reaction\n\/\/     *\/\n\/\/    protected void setMappingIDs(IReaction reaction) {\n\/\/        int i = 0;\n\/\/        for (IMapping mapping : reaction.mappings()) {\n\/\/            IAtom a0 = (IAtom) mapping.getChemObject(0);\n\/\/            IAtom a1 = (IAtom) mapping.getChemObject(1);\n\/\/            Object mappingID = a0.getProperty(ATOM_ATOM_MAPPING);\n\/\/            \/\/            Integer mappingID =\n\/\/            \/\/                (Integer)a0.getProperty(CDKConstants.ATOM_ATOM_MAPPING);\n\/\/            if (mappingID != null) {\n\/\/                a0.setID(valueOf(mappingID));\n\/\/                a1.setID(valueOf(mappingID));\n\/\/            } else {\n\/\/                a0.setID(valueOf(i));\n\/\/                a1.setID(valueOf(i));\n\/\/            }\n\/\/            i++;\n\/\/        }\n\/\/    }\n\/\/\n\/**\n * @param reaction\n *\/\nprotected void renumberMappingIDs(IReaction reaction) {\n    int i = 1;\n    for (IMapping mapping : reaction.mappings()) {\n        IAtom a0 = (IAtom) mapping.getChemObject(0);\n        IAtom a1 = (IAtom) mapping.getChemObject(1);\n        a0.setID(valueOf(i));\n        a1.setID(valueOf(i));\n        mapping.setID(valueOf(i));\n        i++;\n    }\n}","719":"public synchronized String getInChI(IAtomContainer mol, List<INCHI_OPTION> options) throws CDKException {\n    String inchi = \"\";\n    try {\n        _genInchi = factory.getInChIGenerator(convertRGroupsToMetals(mol), options);\n        inchi();\n        inchi = _genInchi.getInchi();\n    } catch (CDKException e) {\n        LOGGER.debug(\"Error in generating InChI code \" + e);\n    }\n    return inchi;\n}","720":"protected static void printAtoms(IAtomContainer mol) {\n    out.print(\"Atom: \");\n    for (IAtom a : mol.atoms()) {\n        out.print(a.getSymbol());\n        if (a.getID() != null) {\n            out.print(\"[\" + a.getID() + \"]\");\n        }\n    }\n    out.println();\n    out.println();\n}","721":"protected static void printMolecule(IAtomContainer molecule) {\n    out.println(\"AtomContainer \" + molecule.getID() + \": \" + molecule.getAtomCount());\n    for (int i = 0; i < molecule.getAtomCount(); i++) {\n        out.print(molecule.getAtom(i).getSymbol() + \" : \" + molecule.getAtom(i).getID() + \",  \");\n    }\n    out.println();\n}","722":"\/**\n * @param mappings to be set\n *\/\nprivate void setMappingMap(Iterable<IMapping> mappings) {\n    Iterator<IMapping> mappingIterator = mappings.iterator();\n    while (mappingIterator.hasNext()) {\n        IMapping mappingObject = mappingIterator.next();\n        IAtom atomEduct = (IAtom) mappingObject.getChemObject(0);\n        IAtom atomProduct = (IAtom) mappingObject.getChemObject(1);\n        mappingMap.put(atomEduct, atomProduct);\n    }\n}","723":"public static void printBEMatrix(BEMatrix beMatrix) {\n    List<IAtom> atomArray = beMatrix.getAtoms();\n    out.println(atomArray.size());\n    for (int i = 0; i < atomArray.size(); i++) {\n        out.print(atomArray.get(i).getSymbol() + atomArray.get(i).getID() + \"\\t\");\n    }\n    out.println();\n    for (int i = 0; i < beMatrix.getRowDimension(); i++) {\n        for (int j = 0; j < beMatrix.getColumnDimension(); j++) {\n            out.print(beMatrix.getValue(i, j) + \"\\t\");\n        }\n        out.println();\n    }\n}","724":"\/**\n * Used CDK to generate moiety\n *\n * @param reactant\n * @param product\n * @param remove_AAM\n * @return\n *\/\npublic static String getMoietyAsSMILES(IAtomContainer reactant, IAtomContainer product, boolean remove_AAM) {\n    AtomAtomMapping atomAtomMapping = new AtomAtomMapping(reactant, product);\n    for (IAtom a : reactant.atoms()) {\n        for (IAtom b : product.atoms()) {\n            if (a.getID() == null ? b.getID() == null : a.getID().equals(b.getID())) {\n                \/\/store mapping if they share IDs\n                atomAtomMapping.put(a, b);\n            }\n        }\n    }\n    StringBuilder sb = new StringBuilder(\"\");\n    try {\n        sb.append(getSMILES(atomAtomMapping.getCommonFragment(), remove_AAM));\n    } catch (Exception ex) {\n        LOGGER.error(SEVERE, null, ex);\n    }\n    return sb.toString();\n}","725":"protected static void setFragmentMatches(SortedMap<String, Integer> atomRCChangesMap, List<IAtomContainer> fragments) throws CloneNotSupportedException {\n    for (IAtomContainer fragment : fragments) {\n        CountSubstructures countSubstructures = new CountSubstructures(fragment);\n        atomRCChangesMap.keySet().stream().forEach((pattern) -> {\n            int hit = 0;\n            try {\n                hit = countSubstructures.substructureSize(pattern);\n            } catch (CDKException ex) {\n                LOGGER.error(SEVERE, null, ex);\n            }\n            int val = hit == 0 ? 0 : atomRCChangesMap.get(pattern) + 1;\n            atomRCChangesMap.put(pattern, val);\n        });\n    }\n}","726":"protected static String getCanonisedBondChangePattern(IBond reactBond, IBond prodBond) {\n    String concatE = getCanonicalisedBondChangePattern(reactBond);\n    String concatP = getCanonicalisedBondChangePattern(prodBond);\n    List<String> pattern = new ArrayList<>(2);\n    pattern.add(0, concatE);\n    pattern.add(1, concatP);\n    sort(pattern, CASE_INSENSITIVE_ORDER);\n    return pattern.get(0).concat(\"*\").concat(pattern.get(1));\n}","727":"protected static List<ReactionCenterFragment> getCircularReactionPatternFingerprints(IAtomContainer molOrignal, IAtom atom, EnumSubstrateProduct type) throws Exception, CloneNotSupportedException {\n    List<ReactionCenterFragment> fragmentsRC = new ArrayList<>();\n    IAtomContainer clone = molOrignal.clone();\n    for (int i = 0; i < 3; i++) {\n        String smiles = getCircularSMILES(clone, atom, i, true);\n        ReactionCenterFragment reactionCenterFragment = new ReactionCenterFragment(smiles, i, type);\n        fragmentsRC.add(reactionCenterFragment);\n    }\n    String smiles = getCircularSMILES(clone, atom, -1, true);\n    ReactionCenterFragment reactionCenterFragment = new ReactionCenterFragment(smiles, -1, type);\n    fragmentsRC.add(reactionCenterFragment);\n    return fragmentsRC;\n}","728":"\/**\n * @param g\n * @param c\n * @param v\n *\/\npublic void drawArrow(Graphics2D g, Point2d c, Vector2d v) {\n    Stroke savedStroke = g.getStroke();\n    g.setStroke(new BasicStroke());\n    if (params.drawFatArrow) {\n        if (params.arrowType == BIDIRECTIONAL) {\n            drawDoubleHeadedFatArrow(g, c, v, null);\n        } else {\n            drawFatArrow(g, c, v, null);\n        }\n    } else {\n        drawThinArrow(g, c, v, null);\n    }\n    g.setStroke(savedStroke);\n}","729":"\/**\n * @param atomContainer\n * @param w\n * @param h\n * @return\n *\/\npublic Image drawHull(IAtomContainer atomContainer, int w, int h) {\n    Image image = super.makeBlankImage(w, h);\n    Graphics2D g = (Graphics2D) image.getGraphics();\n    if (params.useAntialias) {\n        g.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON);\n    }\n    for (int i = 0; i < atomContainer.getAtomCount(); i++) {\n        atomContainer.getAtom(i).setID(valueOf(i));\n    }\n    params.drawAtomID = true;\n    drawHull(atomContainer, g);\n    return image;\n}","730":"\/**\n * Adds an automatically calculated offset to the coordinates of all atoms\n * such that all coordinates are positive and the smallest x or y coordinate\n * is exactly zero. See comment for center(IAtomContainer atomCon, Dimension\n * areaDim, HashMap renderingCoordinates) for details on coordinate sets\n *\n * @param atomCon AtomContainer for which all the atoms are translated to\n * positive coordinates\n *\/\npublic static void translateAllPositive(IAtomContainer atomCon) {\n    double minX = Double.MAX_VALUE;\n    double minY = Double.MAX_VALUE;\n    Iterator<IAtom> atoms = atomCon.atoms().iterator();\n    while (atoms.hasNext()) {\n        IAtom atom = (IAtom) atoms.next();\n        if (atom.getPoint2d() != null) {\n            if (atom.getPoint2d().x < minX) {\n                minX = atom.getPoint2d().x;\n            }\n            if (atom.getPoint2d().y < minY) {\n                minY = atom.getPoint2d().y;\n            }\n        }\n    }\n    logger.debug(\"Translating: minx=\" + minX + \", minY=\" + minY);\n    translate2D(atomCon, minX * -1, minY * -1);\n}","731":"public static void rotate(IAtomContainer atomCon, Point2d center, double angle) {\n    Point2d point;\n    double costheta = Math.cos(angle);\n    double sintheta = Math.sin(angle);\n    IAtom atom;\n    for (int i = 0; i < atomCon.getAtomCount(); i++) {\n        atom = atomCon.getAtom(i);\n        point = atom.getPoint2d();\n        double relativex = point.x - center.x;\n        double relativey = point.y - center.y;\n        point.x = relativex * costheta - relativey * sintheta + center.x;\n        point.y = relativex * sintheta + relativey * costheta + center.y;\n    }\n}","732":"public static Point2d get2DCenter(Iterator<IAtom> atoms) {\n    IAtom atom;\n    double xsum = 0;\n    double ysum = 0;\n    int length = 0;\n    while (atoms.hasNext()) {\n        atom = (IAtom) atoms.next();\n        if (atom.getPoint2d() != null) {\n            xsum += atom.getPoint2d().x;\n            ysum += atom.getPoint2d().y;\n        }\n        ++length;\n    }\n    return new Point2d(xsum \/ (double) length, ysum \/ (double) length);\n}","733":"public static Point2d get2DCenter(IAtomContainer container) {\n    double centerX = 0;\n    double centerY = 0;\n    double counter = 0;\n    Iterator<IAtom> atoms = container.atoms().iterator();\n    while (atoms.hasNext()) {\n        IAtom atom = (IAtom) atoms.next();\n        if (atom.getPoint2d() != null) {\n            centerX += atom.getPoint2d().x;\n            centerY += atom.getPoint2d().y;\n            counter++;\n        }\n    }\n    return new Point2d(centerX \/ (counter), centerY \/ (counter));\n}","734":"public static Point3d get3DCenter(IAtomContainer ac) {\n    double centerX = 0;\n    double centerY = 0;\n    double centerZ = 0;\n    double counter = 0;\n    Iterator<IAtom> atoms = ac.atoms().iterator();\n    while (atoms.hasNext()) {\n        IAtom atom = (IAtom) atoms.next();\n        if (atom.getPoint3d() != null) {\n            centerX += atom.getPoint3d().x;\n            centerY += atom.getPoint3d().y;\n            centerZ += atom.getPoint3d().z;\n            counter++;\n        }\n    }\n    return new Point3d(centerX \/ (counter), centerY \/ (counter), centerZ \/ (counter));\n}","735":"public static double getAngle(double xDiff, double yDiff) {\n    double angle = 0;\n    if (xDiff >= 0 && yDiff >= 0) {\n        angle = Math.atan(yDiff \/ xDiff);\n    } else if (xDiff < 0 && yDiff >= 0) {\n        angle = Math.PI + Math.atan(yDiff \/ xDiff);\n    } else if (xDiff < 0 && yDiff < 0) {\n        angle = Math.PI + Math.atan(yDiff \/ xDiff);\n    } else if (xDiff >= 0 && yDiff < 0) {\n        angle = 2 * Math.PI + Math.atan(yDiff \/ xDiff);\n    }\n    return angle;\n}","736":"public static int[] distanceCalculator(int[] coords, double dist) {\n    double angle;\n    if ((coords[2] - coords[0]) == 0) {\n        angle = Math.PI \/ 2;\n    } else {\n        angle = Math.atan(((double) coords[3] - (double) coords[1]) \/ ((double) coords[2] - (double) coords[0]));\n    }\n    int begin1X = (int) (Math.cos(angle + Math.PI \/ 2) * dist + coords[0]);\n    int begin1Y = (int) (Math.sin(angle + Math.PI \/ 2) * dist + coords[1]);\n    int begin2X = (int) (Math.cos(angle - Math.PI \/ 2) * dist + coords[0]);\n    int begin2Y = (int) (Math.sin(angle - Math.PI \/ 2) * dist + coords[1]);\n    int end1X = (int) (Math.cos(angle - Math.PI \/ 2) * dist + coords[2]);\n    int end1Y = (int) (Math.sin(angle - Math.PI \/ 2) * dist + coords[3]);\n    int end2X = (int) (Math.cos(angle + Math.PI \/ 2) * dist + coords[2]);\n    int end2Y = (int) (Math.sin(angle + Math.PI \/ 2) * dist + coords[3]);\n    return new int[] { begin1X, begin1Y, begin2X, begin2Y, end1X, end1Y, end2X, end2Y };\n}","737":"public static IAtom getClosestAtom(int xPosition, int yPosition, IAtomContainer atomCon) {\n    IAtom closestAtom = null;\n    IAtom currentAtom;\n    double smallestMouseDistance = -1;\n    double mouseDistance;\n    double atomX;\n    double atomY;\n    for (int i = 0; i < atomCon.getAtomCount(); i++) {\n        currentAtom = atomCon.getAtom(i);\n        atomX = currentAtom.getPoint2d().x;\n        atomY = currentAtom.getPoint2d().y;\n        mouseDistance = Math.sqrt(Math.pow(atomX - xPosition, 2) + Math.pow(atomY - yPosition, 2));\n        if (mouseDistance < smallestMouseDistance || smallestMouseDistance == -1) {\n            smallestMouseDistance = mouseDistance;\n            closestAtom = currentAtom;\n        }\n    }\n    return closestAtom;\n}","738":"public static IAtom getClosestAtom(IAtomContainer atomCon, IAtom atom) {\n    IAtom closestAtom = null;\n    double min = Double.MAX_VALUE;\n    Point2d atomPosition = atom.getPoint2d();\n    for (int i = 0; i < atomCon.getAtomCount(); i++) {\n        IAtom currentAtom = atomCon.getAtom(i);\n        if (!currentAtom.equals(atom)) {\n            double d = atomPosition.distance(currentAtom.getPoint2d());\n            if (d < min) {\n                min = d;\n                closestAtom = currentAtom;\n            }\n        }\n    }\n    return closestAtom;\n}","739":"public static IAtom getClosestAtom(double xPosition, double yPosition, IAtomContainer atomCon) {\n    IAtom closestAtom = null;\n    IAtom currentAtom;\n    double smallestMouseDistance = -1;\n    double mouseDistance;\n    double atomX;\n    double atomY;\n    for (int i = 0; i < atomCon.getAtomCount(); i++) {\n        currentAtom = atomCon.getAtom(i);\n        atomX = currentAtom.getPoint2d().x;\n        atomY = currentAtom.getPoint2d().y;\n        mouseDistance = Math.sqrt(Math.pow(atomX - xPosition, 2) + Math.pow(atomY - yPosition, 2));\n        if (mouseDistance < smallestMouseDistance || smallestMouseDistance == -1) {\n            smallestMouseDistance = mouseDistance;\n            closestAtom = currentAtom;\n        }\n    }\n    return closestAtom;\n}","740":"public static IBond getClosestBond(int xPosition, int yPosition, IAtomContainer atomCon) {\n    Point2d bondCenter;\n    IBond closestBond = null;\n    double smallestMouseDistance = -1;\n    double mouseDistance;\n    Iterator<IBond> bonds = atomCon.bonds().iterator();\n    while (bonds.hasNext()) {\n        IBond currentBond = (IBond) bonds.next();\n        bondCenter = get2DCenter(currentBond.atoms());\n        mouseDistance = Math.sqrt(Math.pow(bondCenter.x - xPosition, 2) + Math.pow(bondCenter.y - yPosition, 2));\n        if (mouseDistance < smallestMouseDistance || smallestMouseDistance == -1) {\n            smallestMouseDistance = mouseDistance;\n            closestBond = currentBond;\n        }\n    }\n    return closestBond;\n}","741":"public static IBond getClosestBond(double xPosition, double yPosition, IAtomContainer atomCon) {\n    Point2d bondCenter;\n    IBond closestBond = null;\n    double smallestMouseDistance = -1;\n    double mouseDistance;\n    Iterator<IBond> bonds = atomCon.bonds().iterator();\n    while (bonds.hasNext()) {\n        IBond currentBond = (IBond) bonds.next();\n        bondCenter = get2DCenter(currentBond.atoms());\n        mouseDistance = Math.sqrt(Math.pow(bondCenter.x - xPosition, 2) + Math.pow(bondCenter.y - yPosition, 2));\n        if (mouseDistance < smallestMouseDistance || smallestMouseDistance == -1) {\n            smallestMouseDistance = mouseDistance;\n            closestBond = currentBond;\n        }\n    }\n    return closestBond;\n}","742":"@Deprecated\npublic static int has2DCoordinatesNew(IAtomContainer container) {\n    if (container == null) {\n        return 0;\n    }\n    boolean no2d = false;\n    boolean with2d = false;\n    for (IAtom atom : container.atoms()) {\n        if (atom.getPoint2d() == null) {\n            no2d = true;\n        } else {\n            with2d = true;\n        }\n    }\n    if (!no2d && with2d) {\n        return 2;\n    } else if (no2d && with2d) {\n        return 1;\n    } else {\n        return 0;\n    }\n}","743":"public static boolean has3DCoordinates(IAtomContainer container) {\n    if (container == null || container.getAtomCount() == 0) {\n        return Boolean.FALSE;\n    }\n    for (IAtom atom : container.atoms()) {\n        if (atom == null || atom.getPoint3d() == null) {\n            return Boolean.FALSE;\n        }\n    }\n    return Boolean.TRUE;\n}","744":"public void add(String label, Point2D point) {\n    Rectangle2D bounds = new Rectangle2D.Double(point.getX(), point.getY(), 0, 0);\n    childMap.put(label, bounds);\n    if (root == null) {\n        root = new Rectangle2D.Double(bounds.getMinX(), bounds.getMinY(), bounds.getWidth(), bounds.getHeight());\n    } else {\n        root.add(point);\n    }\n}","745":"public BoundsTree transform(AffineTransform transform) {\n    BoundsTree transformedTree = new BoundsTree(rootLabel);\n    for (String key : childMap.keySet()) {\n        Rectangle2D shape = childMap.get(key);\n        transformedTree.add(key, transform.createTransformedShape(shape).getBounds2D());\n    }\n    return transformedTree;\n}","746":"public void shiftMoleculeSet(IAtomContainerSet molSet, BoundsTree molSetBoundsTree, double dx, double dy) {\n    int counter = 0;\n    String rootLabel = molSet.getID();\n    for (IAtomContainer molecule : molSet.atomContainers()) {\n        String label = rootLabel + \"_\" + molecule.getID() + \":\" + counter;\n        Rectangle2D bounds = molSetBoundsTree.get(label);\n        bounds.setFrame(bounds.getCenterX() + dx, bounds.getCenterY() + dy, bounds.getWidth(), bounds.getHeight());\n        translate2D(molecule, dx, dy);\n        counter++;\n    }\n}","747":"public void invert(IAtomContainer ac) {\n    if (shouldInvert && ac.getProperty(INVERTED) == null || !((Boolean) ac.getProperty(INVERTED))) {\n        for (IAtom atom : ac.atoms()) {\n            atom.getPoint2d().y *= -1;\n        }\n        ac.setProperty(INVERTED, TRUE);\n    }\n    shouldInvert = false;\n}","748":"public void highlightSubgraphs(RBlastReaction rBlastReaction) {\n    List<Color> colors = getColors(rBlastReaction.getMappedSubgraphs().size());\n    int blockIndex = 0;\n    for (BlockPair subgraphMapping : rBlastReaction.getMappedSubgraphs()) {\n        Block productBlock = subgraphMapping.getProductBlock();\n        Block reactantBlock = subgraphMapping.getReactantBlock();\n        Color color = getColorForBlock(colors, blockIndex);\n        highlightSubgraph(reactantBlock, color);\n        highlightSubgraph(productBlock, color);\n        blockIndex++;\n    }\n}","749":"public Point2d getCenter() {\n    Point2d center = new Point2d();\n    for (Point2d hullPoint : hull) {\n        center.x += hullPoint.x;\n        center.y += hullPoint.y;\n    }\n    center.x \/= hull.length;\n    center.y \/= hull.length;\n    return center;\n}","750":"public static List<RootSystem> findRootSystems(IReaction reaction, List<String> signatureStrings) {\n    List<RootSystem> rootSystems = new ArrayList<>();\n    SignatureMatcher matcher = new SignatureMatcher();\n    getAllAtomContainers(reaction).forEach(atomContainer -> {\n        List<IAtom> roots = matcher.getMatchingRootAtoms(signatureStrings, atomContainer);\n        rootSystems.addAll(find(atomContainer, roots));\n    });\n    return rootSystems;\n}","751":"\/**\n * Compare two AtomContainers based on their 2D position.\n *\n * @param atCont1\n * @param atCont2\n * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)\n *\/\n@Override\npublic int compare(IAtomContainer atCont1, IAtomContainer atCont2) {\n    if (atCont1 != null && atCont2 != null) {\n        Point2d p1 = get2DCenter(atCont1);\n        Point2d p2 = get2DCenter(atCont2);\n        if (p1 != null && p2 != null) {\n            if (p1.x != p2.x) {\n                return Double.valueOf(p1.x).compareTo(p2.x);\n            } else {\n                return Double.valueOf(p1.y).compareTo(p2.y);\n            }\n        }\n    }\n    return 0;\n}","752":"\/**\n * @param labelMap\n * @param labelBounds\n * @param g\n *\/\npublic void draw(Map<String, String> labelMap, BoundsTree labelBounds, Graphics2D g) {\n    \/\/ layout labels according to the positions in the moleculeBounds\n    for (String boundsLabel : labelMap.keySet()) {\n        String label = labelMap.get(boundsLabel);\n        Rectangle2D bounds = labelBounds.get(boundsLabel);\n        double x = bounds.getCenterX();\n        double y = bounds.getCenterY();\n        Point2f p = super.getTextPoint(g, label, x, y);\n        \/\/            System.out.println(\"drawing string at \" + x + \" \" + y);\n        g.drawString(label, p.x, p.y);\n    }\n}","753":"public Highlighter getFirstHighlighter() {\n    Highlighter highlightDrawer;\n    if (highlightDrawers.isEmpty()) {\n        if (params.useCircularHighlight) {\n            highlightDrawer = new OutlineHighlighter(params);\n        } else {\n            highlightDrawer = new SimpleHighlighter(params);\n        }\n        highlightDrawers.add(highlightDrawer);\n    } else {\n        highlightDrawer = highlightDrawers.get(0);\n    }\n    return highlightDrawer;\n}","754":"\/**\n * @param mols\n * @param cellCanvas\n * @param g\n *\/\npublic void draw(List<IAtomContainer> mols, Dimension cellCanvas, Graphics2D g) {\n    canvasGenerator.layout(mols, cellCanvas);\n    AffineTransform originalTransform = g.getTransform();\n    mols.stream().map(mol -> {\n        Rectangle2D canvas = canvasGenerator.getCanvasForAtomContainer(mol);\n        g.translate(canvas.getCenterX(), canvas.getCenterY());\n        double zoom = calculateZoom(mol, canvas);\n        g.scale(zoom, zoom);\n        moleculeDrawer.drawMolecule(mol, g);\n        return mol;\n    }).forEachOrdered(_item -> {\n        g.setTransform(originalTransform);\n    });\n}","755":"\/**\n * @param molecule\n * @param g\n *\/\n@Override\npublic void drawHighlights(IAtomContainer molecule, Graphics2D g) {\n    atomColorMap.keySet().stream().filter(atom -> (molecule.contains(atom))).forEachOrdered(atom -> {\n        Color color = atomColorMap.get(atom);\n        drawHighlight(atom, color, g);\n    });\n    bondColorMap.keySet().stream().filter(bond -> (molecule.contains(bond))).forEachOrdered(bond -> {\n        Color color = bondColorMap.get(bond);\n        drawHighlight(bond, color, g);\n    });\n}","756":"public void drawHighlight(IAtom atom, Color color, Graphics2D g) {\n    Color actualColor;\n    if (params.highlightsAbove) {\n        actualColor = getTranslucentColor(color);\n    } else {\n        actualColor = color;\n    }\n    g.setColor(actualColor);\n    double r = params.highlightRadius;\n    double d = r * 2;\n    Point2d p = atom.getPoint2d();\n    g.fill(new Ellipse2D.Double(p.x - r, p.y - r, d, d));\n}","757":"\/**\n * @param molSet\n * @param molSetBoundsTree\n * @param dx\n * @param dy\n *\/\npublic void shiftMoleculeSet(IAtomContainerSet molSet, BoundsTree molSetBoundsTree, double dx, double dy) {\n    \/\/        System.out.println(molSetBoundsTree);\n    int counter = 0;\n    for (IAtomContainer molecule : molSet.atomContainers()) {\n        String molLabel = molSet.getID() + \"_\" + molecule.getID() + \":\" + counter;\n        \/\/            System.out.println(\"shifting \" + molLabel + \" from \" + BoundsPrinter.toString(GeometryTools.getRectangle2D(molecule)));\n        Rectangle2D bounds = molSetBoundsTree.get(molLabel);\n        bounds.setFrame(bounds.getMinX() + dx, bounds.getMinY() + dy, bounds.getWidth(), bounds.getHeight());\n        translate2D(molecule, dx, dy);\n        \/\/            System.out.println(\"shifting \" + molecule.getID() + \" to \" + BoundsPrinter.toString(GeometryTools.getRectangle2D(molecule)));\n        counter++;\n    }\n}","758":"@Override\npublic BoundsTree layout(IAtomContainer atomContainer, String rootLabel, Graphics2D graphics) {\n    atomLayout.reset();\n    setGraphics(graphics);\n    currentObject = atomContainer;\n    boundsTree = new BoundsTree(rootLabel);\n    for (IAtom atom : atomContainer.atoms()) {\n        boundsTree.add(rootLabel, atomLayout.layout(atom, graphics));\n    }\n    return boundsTree;\n}","759":"\/**\n * @param atom\n * @return\n *\/\npublic String getAnnotationPositionsAsString(IAtom atom) {\n    StringBuilder sb = new StringBuilder(\"|\");\n    BitSet positions = getAtomAnnotationPositions(atom);\n    AnnotationPosition[] values = values();\n    for (int i = 0; i < values.length; i++) {\n        if (positions.get(i)) {\n            sb.append(values[i]);\n            sb.append(\"|\");\n        }\n    }\n    return sb.toString();\n}","760":"public Vector2d getVectorFromPosition(AnnotationPosition position) {\n    switch(position) {\n        case N:\n            return vN;\n        case NE:\n            return vNE;\n        case E:\n            return vE;\n        case SE:\n            return vSE;\n        case S:\n            return vS;\n        case SW:\n            return vSW;\n        case W:\n            return vW;\n        case NW:\n            return vNW;\n        default:\n            return vN;\n    }\n}","761":"public Vector2d getLeftPerpendicularFromPosition(AnnotationPosition position) {\n    switch(position) {\n        case N:\n            return vW;\n        case NE:\n            return vNW;\n        case E:\n            return vN;\n        case SE:\n            return vNE;\n        case S:\n            return vE;\n        case SW:\n            return vSE;\n        case W:\n            return vS;\n        case NW:\n            return vSW;\n        default:\n            return vN;\n    }\n}","762":"public Vector2d getRightPerpendicularFromPosition(AnnotationPosition position) {\n    switch(position) {\n        case N:\n            return vE;\n        case NE:\n            return vSE;\n        case E:\n            return vS;\n        case SE:\n            return vSW;\n        case S:\n            return vW;\n        case SW:\n            return vNW;\n        case W:\n            return vN;\n        case NW:\n            return vNE;\n        default:\n            return vS;\n    }\n}","763":"public void setUsedPosition(IAtom atom, AnnotationPosition position) {\n    BitSet pos = getAtomAnnotationPositions(atom);\n    pos.set(position.ordinal());\n}","764":"private void drawBoundsTree(BoundsTree tree, List<String> labels, Color color, Graphics2D g) {\n    java.util.Random random = new java.util.Random();\n    labels.forEach(label -> {\n        Rectangle2D bounds = tree.get(label);\n        g.setColor(color);\n        g.draw(bounds);\n        g.setColor(RED);\n        Point2f p = super.getTextPoint(g, label, bounds.getCenterX(), bounds.getCenterY());\n        g.drawString(label, p.x, p.y);\n    });\n}","765":"public void transpose() {\n    Ligand<A> tmp = tail;\n    tail = head;\n    head = tmp;\n    depth *= -1;\n    head.setParent(tail.getAtom());\n    head.reset();\n    tail.reset();\n}","766":"@Override\npublic MutableDescriptor getDescriptor(A first, A second) {\n    Map.Entry<A, A> entry = new HashMap.SimpleEntry(first, second);\n    MutableDescriptor mutableDescriptor = bondMap.get(entry);\n    if (mutableDescriptor == null) {\n        mutableDescriptor = new MutableDescriptor();\n        bondMap.put(entry, mutableDescriptor);\n        bondMap.put(new HashMap.SimpleEntry(second, first), mutableDescriptor);\n    }\n    return mutableDescriptor;\n}","767":"public List<DescriptorList> append(Collection<? extends DescriptorList> lists) {\n    List<DescriptorList> created = new ArrayList<>(lists.size());\n    for (DescriptorList list : lists) {\n        if (!list.descriptors.isEmpty()) {\n            created.add(new DescriptorList(this, list));\n        }\n    }\n    if (created.isEmpty()) {\n        created.add(this);\n    }\n    return created;\n}","768":"\/**\n * Access the atomic number for a provided atom. The atomic can be 0 to\n * allow for cases such as 'R' or '*' but should never be negative.\n *\n * @param atom the atom to access the atomic number for\n * @return a positive integer value that is the atomic number for the given\n * atom\n *\/\n@Override\npublic int getAtomicNumber(A atom) {\n    int value = accessor.getAtomicNumber(atom);\n    switch(value) {\n        case 1:\n            return 0;\n        case 0:\n            return 1;\n        default:\n            return value;\n    }\n}","769":"public void writeAttributes() throws IOException {\n    for (Map.Entry<String, Map<String, String>> entry : attributes.entrySet()) {\n        try (FileWriter attributeWriter = new FileWriter(new File(folder, entry.getKey() + \".noa\"))) {\n            attributeWriter.write(entry.getKey().replaceAll(\" \", \".\") + \" (class=String)\" + NEW_LINE);\n            for (Map.Entry<String, String> nodeEntry : entry.getValue().entrySet()) {\n                attributeWriter.write(nodeEntry.getKey() + \" = \" + nodeEntry.getValue() + NEW_LINE);\n            }\n        }\n    }\n}","770":"public synchronized IAtomContainer getMapCommonFragmentOnTarget() throws CloneNotSupportedException {\n    IAtomContainer ac = getTarget().clone();\n    List<IAtom> unmappedAtoms = Collections.synchronizedList(new ArrayList<>());\n    for (IAtom atom : getTarget().atoms()) {\n        if (!mapping.containsValue(atom)) {\n            unmappedAtoms.add(ac.getAtom(getTargetIndex(atom)));\n        }\n    }\n    unmappedAtoms.stream().forEach((atom) -> {\n        ac.removeAtom(atom);\n    });\n    return ac;\n}","771":"public Set<IAtom> commonVertices(IAtomContainer ac, IBond e1, IBond e2) {\n    Set<IAtom> commonVertices = new LinkedHashSet<>();\n    if (e1.getBegin().equals(e2.getBegin())) {\n        commonVertices.add(e1.getBegin());\n    }\n    if (e1.getBegin().equals(e2.getEnd())) {\n        commonVertices.add(e1.getBegin());\n    }\n    if (e1.getEnd().equals(e2.getBegin())) {\n        commonVertices.add(e1.getEnd());\n    }\n    if (e1.getEnd().equals(e2.getEnd())) {\n        commonVertices.add(e1.getEnd());\n    }\n    return commonVertices;\n}","772":"public Iterable<Edge> edgesOf(Vertex currentVertex) {\n    validateVertex(currentVertex);\n    Integer v = vertices.indexOf(currentVertex);\n    Set<Edge> edgesOfVertex = new LinkedHashSet<>();\n    edges().stream().map((e) -> {\n        if (e.getSource().equals(v)) {\n            edgesOfVertex.add(e);\n        }\n        return e;\n    }).filter((e) -> (e.getSink().equals(v))).forEachOrdered((e) -> {\n        edgesOfVertex.add(e);\n    });\n    return edgesOfVertex;\n}","773":"\/**\n * Creates a new instance of Post Filter and removes redundant mapping(s).\n *\n * @param mappings\n * @return Filtered non-redundant mappings\n *\/\npublic synchronized static List<Map<Integer, Integer>> filter(List<List<Integer>> mappings) {\n    List<Map<Integer, Integer>> final_MAPPINGS = new ArrayList<>();\n    mappings.stream().map(map -> {\n        Map<Integer, Integer> mapping = new TreeMap<>();\n        for (int i = 0; i < map.size(); i = i + 2) {\n            mapping.put(map.get(i), map.get(i + 1));\n        }\n        return mapping;\n    }).forEachOrdered(mapping -> {\n        final_MAPPINGS.add(mapping);\n    });\n    return final_MAPPINGS;\n}","774":"private synchronized Map<IBond, IBond> makeBondMapOfAtomMap(IAtomContainer ac1, IAtomContainer ac2, AtomAtomMapping mapping) {\n    Map<IBond, IBond> bondbondMappingMap = Collections.synchronizedMap(new HashMap<>());\n    mapping.getMappingsByAtoms().entrySet().stream().forEach((Map.Entry<IAtom, IAtom> map1) -> {\n        mapping.getMappingsByAtoms().entrySet().stream().filter((map2) -> (map1.getKey() != map2.getKey())).forEach((Map.Entry<IAtom, IAtom> map2) -> {\n            IBond bond1;\n            bond1 = ac1.getBond(map1.getKey(), map2.getKey());\n            IBond bond2 = ac2.getBond(map1.getValue(), map2.getValue());\n            if (bond1 != null && bond2 != null && !bondbondMappingMap.containsKey(bond1)) {\n                bondbondMappingMap.put(bond1, bond2);\n            }\n        });\n    });\n    return bondbondMappingMap;\n}","775":"protected synchronized List getMaximum(List overlaps) {\n    List list = null;\n    int count = 0;\n    for (Object o : overlaps) {\n        List arrayList = (ArrayList) o;\n        if (arrayList.size() > count) {\n            list = arrayList;\n            count = arrayList.size();\n        }\n    }\n    return list;\n}","776":"public static BitSet getBitSet(IAtomContainer ac) {\n    BitSet bs;\n    int n = ac.getBondCount();\n    if (n != 0) {\n        bs = new BitSet(n);\n        for (int i = 0; i < n; i++) {\n            bs.set(i);\n        }\n    } else {\n        bs = new BitSet();\n    }\n    return bs;\n}","777":"private BitSet buildB(BitSet sourceBitSet, BitSet targetBitSet) throws CDKException {\n    this.setSourceBitSet(sourceBitSet);\n    this.setTargetBitSet(targetBitSet);\n    BitSet bistSet = new BitSet();\n    getGraph().stream().filter((rNode) -> ((sourceBitSet.get(rNode.getRMap().getId1()) || sourceBitSet.isEmpty()) && (targetBitSet.get(rNode.getRMap().getId2()) || targetBitSet.isEmpty()))).forEachOrdered((rNode) -> {\n        bistSet.set(getGraph().indexOf(rNode));\n    });\n    return bistSet;\n}","778":"@Override\npublic String toString() {\n    String message = \"\";\n    int jIndex = 0;\n    for (CDKRNode rNode : getGraph()) {\n        message += \"-------------\" + NEW_LINE + \"CDKRNode \" + jIndex + NEW_LINE + rNode.toString() + NEW_LINE;\n        jIndex++;\n    }\n    return message;\n}","779":"private boolean isContainedIn(BitSet sourceBitSet, BitSet targetBitSet) {\n    boolean result = false;\n    if (sourceBitSet.isEmpty()) {\n        return true;\n    }\n    BitSet setA = (BitSet) sourceBitSet.clone();\n    setA.and(targetBitSet);\n    if (setA.equals(sourceBitSet)) {\n        result = true;\n    }\n    return result;\n}","780":"protected static int searchCorrespondingAtom(int mappedAtomsSize, int atomFromOtherMolecule, int molecule, List<Integer> mapped_atoms_org) {\n    List<Integer> mapped_atoms = new ArrayList<>(mapped_atoms_org);\n    int corresponding_atom = 0;\n    for (int a = 0; a < mappedAtomsSize; a++) {\n        if ((molecule == 1) && (mapped_atoms.get(a * 2 + 0) == atomFromOtherMolecule)) {\n            corresponding_atom = mapped_atoms.get(a * 2 + 1);\n        }\n        if ((molecule == 2) && (mapped_atoms.get(a * 2 + 1) == atomFromOtherMolecule)) {\n            corresponding_atom = mapped_atoms.get(a * 2 + 0);\n        }\n    }\n    return corresponding_atom;\n}","781":"protected static List<String> generateCTabCopy(IAtomContainer atomContainer) throws IOException {\n    List<String> c_tab_copy = new ArrayList<>();\n    for (int a = 0; a < atomContainer.getBondCount(); a++) {\n        String AtomI = atomContainer.getBond(a).getAtom(0).getSymbol();\n        String AtomJ = atomContainer.getBond(a).getAtom(1).getSymbol();\n        c_tab_copy.add(AtomI);\n        c_tab_copy.add(AtomJ);\n        c_tab_copy.add(\"X\");\n        c_tab_copy.add(\"X\");\n    }\n    return c_tab_copy;\n}","782":"protected static int countArcsLeft(List<Integer> TEMPMARCS, int neighborBondNumA, int neighborBondNumB) {\n    int arcsleft = 0;\n    for (int a = 0; a < neighborBondNumA; a++) {\n        for (int b = 0; b < neighborBondNumB; b++) {\n            if (TEMPMARCS.get(a * neighborBondNumB + b) == (1)) {\n                arcsleft++;\n            }\n        }\n    }\n    return arcsleft;\n}","783":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<IAtom, IAtom> object1, Map<IAtom, IAtom> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","784":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<Integer, Integer> object1, Map<Integer, Integer> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","785":"public synchronized static Set<Map<Integer, Integer>> filter(List<List<Integer>> mappings) {\n    Set<Map<Integer, Integer>> final_MAPPINGS = new TreeSet<>();\n    mappings.stream().map((map) -> {\n        Map<Integer, Integer> mapping = new TreeMap<>();\n        for (int i = 0; i < map.size(); i = i + 2) {\n            mapping.put(map.get(i), map.get(i + 1));\n        }\n        return mapping;\n    }).forEachOrdered((mapping) -> {\n        final_MAPPINGS.add(mapping);\n    });\n    return final_MAPPINGS;\n}","786":"public static IAtomContainer getSubgraphProjectAtoms(IAtomContainer ac1, Set<Integer> mapping) throws CloneNotSupportedException {\n    IAtomContainer ac = ac1.clone();\n    Set<IAtom> remove = new HashSet<>();\n    for (IAtom a : ac1.atoms()) {\n        if (!mapping.contains(ac1.indexOf(a))) {\n            remove.add(a);\n        }\n    }\n    remove.forEach((a) -> {\n        ac.removeAtom(a);\n    });\n    System.out.println(\"\");\n    return ac;\n}","787":"public static void aromatizeDayLight(IAtomContainer molecule) throws CDKException {\n    ElectronDonation model = ElectronDonation.daylight();\n    CycleFinder cycles = Cycles.or(Cycles.all(), Cycles.relevant());\n    Aromaticity aromaticity = new Aromaticity(model, cycles);\n    try {\n        aromaticity.apply(molecule);\n    } catch (CDKException e) {\n        LOGGER.error(Level.WARNING, \"Aromaticity detection failed due to presence of unset \" + \"atom hybridisation\", molecule.getID());\n    }\n}","788":"public static void aromatizeCDK(IAtomContainer molecule) throws CDKException {\n    ElectronDonation model = ElectronDonation.cdk();\n    CycleFinder cycles = Cycles.cdkAromaticSet();\n    Aromaticity aromaticity = new Aromaticity(model, cycles);\n    ExtAtomContainerManipulator.percieveAtomTypesAndConfigureAtoms(molecule);\n    try {\n        aromaticity.apply(molecule);\n    } catch (CDKException e) {\n        LOGGER.error(Level.WARNING, \"Aromaticity detection failed due to presence of unset \" + \"atom hybridisation\", molecule.getID());\n    }\n}","789":"\/**\n * @param ac\n * @return\n * @throws CDKException\n * @throws IOException\n *\/\npublic static String create(IAtomContainer ac) throws CDKException, IOException {\n    EdgeToBondMap bonds = withSpaceFor(ac);\n    int[][] graph = toAdjList(ac, bonds);\n    long[] labels = label(ac, graph, betterInvariants(ac, graph, bonds));\n    Graph g = CDK2BEAM.toBeamGraph(ac);\n    g = g.permute(toPermutation(labels));\n    \/\/ ensure consistent Kekule form\n    g = g.resonate();\n    return g.toSmiles();\n}","790":"private Set<String> findAndFilterExpectedColumns(final Set<String> actualCols, final Set<String> expectedCols) {\n    final Set<String> missingColumns = new HashSet<>(expectedCols);\n    missingColumns.removeAll(actualCols);\n    if (!missingColumns.isEmpty()) {\n        throw new PicardException(String.format(\"LIBRARY_PARAMS file %s is missing the following columns: %s.\", LIBRARY_PARAMS.getAbsolutePath(), StringUtil.join(\", \", missingColumns)));\n    }\n    final Set<String> remainingColumns = new HashSet<>(actualCols);\n    remainingColumns.removeAll(expectedCols);\n    return remainingColumns;\n}","791":"private void checkRgTagColumns(final Set<String> rgTagColumns) {\n    final Set<String> forbiddenHeaders = buildSamHeaderParameters(null).keySet();\n    forbiddenHeaders.retainAll(rgTagColumns);\n    if (!forbiddenHeaders.isEmpty()) {\n        throw new PicardException(\"Illegal ReadGroup tags in library params(barcode params) file(\" + LIBRARY_PARAMS.getAbsolutePath() + \") Offending headers = \" + StringUtil.join(\", \", forbiddenHeaders));\n    }\n    for (final String column : rgTagColumns) {\n        if (column.length() > 2) {\n            throw new PicardException(\"Column label (\" + column + \") unrecognized.  Library params(barcode params) can only contain the columns \" + \"(OUTPUT, LIBRARY_NAME, SAMPLE_ALIAS, BARCODE, BARCODE_<X> where X is a positive integer) OR two letter RG tags!\");\n        }\n    }\n}","792":"\/**\n * Creates a copy of metric initialized with only non-accumulated and non-calculated values set\n *\/\npublic BarcodeMetric copy() {\n    final BarcodeMetric result = new BarcodeMetric();\n    result.BARCODE = this.BARCODE;\n    result.BARCODE_WITHOUT_DELIMITER = this.BARCODE_WITHOUT_DELIMITER;\n    result.BARCODE_NAME = this.BARCODE_NAME;\n    result.LIBRARY_NAME = this.LIBRARY_NAME;\n    result.barcodeBytes = this.barcodeBytes;\n    return result;\n}","793":"private static Collection<IlluminaTileMetrics> determineLastValueForLaneTileMetricsCode(final Iterator<IlluminaTileMetrics> tileMetricsIterator) {\n    final Map<TileMetricsOutReader.IlluminaLaneTileCode, IlluminaTileMetrics> filteredTileMetrics = new HashMap<>();\n    for (final IlluminaTileMetrics illuminaTileMetrics : new IterableAdapter<>(tileMetricsIterator)) {\n        filteredTileMetrics.put(illuminaTileMetrics.getLaneTileCode(), illuminaTileMetrics);\n    }\n    return filteredTileMetrics.values();\n}","794":"public void setOrCheckTile(final int tile) {\n    if (tileIsSet()) {\n        if (this.tile != tile) {\n            throw new PicardException(\"Tile number mismatch for \" + this + \" : \" + this.tile + \" != \" + tile);\n        }\n    } else {\n        this.tile = tile;\n    }\n}","795":"public void setOrCheckLane(final int lane) {\n    if (laneIsSet()) {\n        if (this.lane != lane) {\n            throw new PicardException(\"Lane number mismatch for \" + this + \" : \" + this.lane + \" != \" + lane);\n        }\n    } else {\n        this.lane = lane;\n    }\n}","796":"public void setOrCheckX(final int x) {\n    if (xIsSet()) {\n        if (this.x != x) {\n            throw new PicardException(\"X value mismatch for \" + this + \" : \" + this.x + \" != \" + x);\n        }\n    } else {\n        this.x = x;\n    }\n}","797":"public void setOrCheckY(final int y) {\n    if (yIsSet()) {\n        if (this.y != y) {\n            throw new PicardException(\"Y value mismatch for \" + this + \" : \" + this.y + \" != \" + y);\n        }\n    } else {\n        this.y = y;\n    }\n}","798":"public TileIndexRecord findTile(final int tileNumber) {\n    for (final TileIndexRecord rec : this) {\n        if (rec.tile == tileNumber)\n            return rec;\n        if (rec.tile > tileNumber) {\n            break;\n        }\n    }\n    throw new NoSuchElementException(String.format(\"Tile %d not found in %s\", tileNumber, tileIndexFile));\n}","799":"private static final List<ReadDescriptor> readStructureStringToDescriptors(final String readStructure) {\n    final Matcher fullMatcher = FullPattern.matcher(readStructure);\n    if (!fullMatcher.matches()) {\n        throw new IllegalArgumentException(readStructure + \" cannot be parsed as a ReadStructure! \" + ReadStructureMsg);\n    }\n    final Matcher subMatcher = SubPattern.matcher(readStructure);\n    final List<ReadDescriptor> descriptors = new ArrayList<>();\n    while (subMatcher.find()) {\n        final ReadDescriptor rd = new ReadDescriptor(Integer.parseInt(subMatcher.group(1)), ReadType.valueOf(subMatcher.group(2)));\n        descriptors.add(rd);\n    }\n    return descriptors;\n}","800":"private int[] fileNameToLaneAndTile(final String fileName) {\n    final String[] tokens = fileName.split(File.pathSeparator);\n    final Matcher matcher = FileNamePattern.matcher(tokens[tokens.length - 1]);\n    if (!matcher.matches()) {\n        throw new PicardException(\"File name not of the right structure: <filePath>\/s_<lane>_<tile>(_pos.txt|_pos.txt.gz|_pos.txt.bz2.locs|.clocs).  File name (\" + fileName + \")\");\n    }\n    return new int[] { Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)) };\n}","801":"\/**\n * Grab the next set of offset values, decompress them.\n * @return the position information of the next offset values\n *\/\n@Override\nprotected PositionInfo unsafeNextInfo() {\n    final byte xByte = byteIterator.next();\n    final byte yByte = byteIterator.next();\n    final float xPos = UnsignedTypeUtil.uByteToInt(xByte) \/ 10f + xOffset;\n    final float yPos = UnsignedTypeUtil.uByteToInt(yByte) \/ 10f + yOffset;\n    ++currentClusterInBin;\n    checkAndAdvanceBin();\n    return new PositionInfo(xPos, yPos, getLane(), getTile());\n}","802":"public int getTileOfNextCluster() {\n    if (cycleFilesParser.hasNext()) {\n        return currentTile;\n    }\n    if (currentTile < tileOrder.last()) {\n        return tileOrder.higher(currentTile);\n    }\n    throw new NoSuchElementException();\n}","803":"\/**\n * @return True if we have more clusters to read\n *\/\npublic boolean hasNext() {\n    final boolean more = parsers[0].hasNext();\n    if (!more) {\n        for (int i = 1; i < parsers.length; i++) {\n            if (parsers[i].hasNext()) {\n                throw new PicardException(\"Unequal length Illumina files in \" + basecallDirectory + \", lane \" + lane + \". Failing parser: \" + parsers[i].getClass().getName());\n            }\n        }\n    }\n    return more;\n}","804":"private static boolean areAllQualitiesAboveMinimum(final byte[][] qualityScores, final int minimumBaseQuality) {\n    if (qualityScores == null)\n        return true;\n    for (final byte[] qs : qualityScores) {\n        for (final byte q : qs) {\n            if (q < minimumBaseQuality) {\n                return false;\n            }\n        }\n    }\n    return true;\n}","805":"private byte[][] parseBaseCalls(final InfiniumFileTOC toc) throws IOException {\n    stream.skipBytes(toc.getOffset());\n    final int arrayLen = Integer.reverseBytes(stream.readInt());\n    final byte[][] curBaseCalls = new byte[arrayLen][2];\n    for (int i = 0; i < arrayLen; i++) {\n        byte[] baseCallBytes = curBaseCalls[i];\n        for (int j = 0; j < baseCallBytes.length; j++) {\n            baseCallBytes[j] = stream.readByte();\n            if (baseCallBytes[j] == 0) {\n                baseCallBytes[j] = NO_CALL_CHAR;\n            }\n        }\n    }\n    return curBaseCalls;\n}","806":"static ImmutablePair<Double, Integer> calculateIsDeletion(final String fivePrimeSeq, final String threePrimeSeq, final boolean indelSequenceMatch, final String genomicDeletionFivePrime, final String indelSeq, final String genomicDeletionThreePrime) {\n    ImmutablePair<String, String> leftShiftedGenomicDeletionSeqs = illuminaLeftShift(genomicDeletionFivePrime, indelSeq, genomicDeletionThreePrime);\n    int deletionContextSuffixMatchLength = commonSuffixLength(leftShiftedGenomicDeletionSeqs.left, fivePrimeSeq);\n    int deletionContextPrefixMatchLength = commonPrefixLength(leftShiftedGenomicDeletionSeqs.right, threePrimeSeq);\n    final int minDeletionContextMaxLength = Math.min(deletionContextPrefixMatchLength, deletionContextSuffixMatchLength);\n    int maxDeletionContext = Math.min(genomicDeletionFivePrime.length(), fivePrimeSeq.length()) + Math.min(genomicDeletionThreePrime.length(), threePrimeSeq.length()) + indelSeq.length();\n    double deletionContextScore = 0.0;\n    if (indelSequenceMatch) {\n        deletionContextScore = ((double) (deletionContextPrefixMatchLength + deletionContextSuffixMatchLength + indelSeq.length())) \/ maxDeletionContext;\n    }\n    return new ImmutablePair<>(deletionContextScore, minDeletionContextMaxLength);\n}","807":"InfiniumFileTOC[] getTableOfContents() throws IOException {\n    final InfiniumFileTOC[] tableOfContents = new InfiniumFileTOC[getNumberOfEntries()];\n    for (int i = 0; i < getNumberOfEntries(); i++) {\n        final InfiniumFileTOC toc = new InfiniumFileTOC();\n        toc.setTableOfContentsId(Short.reverseBytes(stream.readShort()));\n        toc.setOffset(Integer.reverseBytes(stream.readInt()));\n        tableOfContents[i] = toc;\n    }\n    return tableOfContents;\n}","808":"private String readLineFromStream(final InputStream inputStream) throws IOException {\n    final StringBuilder sb = new StringBuilder();\n    int ch;\n    while ((ch = inputStream.read()) > -1) {\n        if (ch == '\\n') {\n            break;\n        }\n        sb.append((char) ch);\n    }\n    if (ch == -1) {\n        throw new PicardException(\"Unexpected end of file\");\n    }\n    return sb.toString();\n}","809":"public static ZCallPedFile fromFile(final File pedFile, final File mapFile) throws FileNotFoundException {\n    final String[] pedFileLines = IOUtil.slurpLines(pedFile).toArray(new String[0]);\n    if (pedFileLines.length > 1) {\n        throw new PicardException(\"Only single-sample .ped files are supported.\");\n    }\n    final String[] pedFileFields = IOUtil.slurp(pedFile).split(\"\\\\s\");\n    final String[] mapFileLines = IOUtil.slurpLines(mapFile).toArray(new String[0]);\n    final ZCallPedFile zCallPedFile = new ZCallPedFile();\n    for (int i = 0; i < mapFileLines.length; i++) {\n        final int index = (i * 2) + OFFSET;\n        if (pedFileFields[index].length() != 1 || pedFileFields[index + 1].length() != 1) {\n            throw new PicardException(\"Malformed file: each allele should be a single character.\");\n        }\n        final String alleles = pedFileFields[index] + pedFileFields[index + 1];\n        zCallPedFile.addAllele(mapFileLines[i].split(\"\\\\s\")[1], alleles);\n    }\n    return zCallPedFile;\n}","810":"\/**\n * Get the next read pair (where both have the same read name).\n * If we encounter an unpaired read, the second read in the pair will be set to null.\n *\n * @param iterator iterator of reads\n * @return ReadPair object holding the reads, or null if there are no more reads in the iterator\n *\/\npublic static ReadPair getNextReadPair(final PeekableIterator<SAMRecord> iterator) {\n    final ReadPair readPair = new ReadPair();\n    readPair.read1 = getNextUsableRead(iterator, false);\n    if (readPair.read1 == null) {\n        return null;\n    }\n    final SAMRecord peekedNextRead = getNextUsableRead(iterator, true);\n    if (peekedNextRead != null && peekedNextRead.getReadName().equals(readPair.read1.getReadName())) {\n        readPair.read2 = getNextUsableRead(iterator, false);\n    }\n    return readPair;\n}","811":"public static double median(final double... in) {\n    if (in.length == 0) {\n        throw new IllegalArgumentException(\"Attempting to find the median of an empty array\");\n    }\n    final double[] data = Arrays.copyOf(in, in.length);\n    Arrays.sort(data);\n    final int middle = data.length \/ 2;\n    return data.length % 2 == 1 ? data[middle] : (data[middle - 1] + data[middle]) \/ 2.0;\n}","812":"public static int indexOfMax(final double[] nums) {\n    double max = nums[0];\n    int index = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] > max) {\n            max = nums[i];\n            index = i;\n        }\n    }\n    return index;\n}","813":"public static int indexOfMax(final long[] nums) {\n    long max = nums[0];\n    int index = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] > max) {\n            max = nums[i];\n            index = i;\n        }\n    }\n    return index;\n}","814":"public static short min(final short[] nums) {\n    short min = nums[0];\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] < min) {\n            min = nums[i];\n        }\n    }\n    return min;\n}","815":"public static byte min(final byte[] nums) {\n    byte min = nums[0];\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] < min) {\n            min = nums[i];\n        }\n    }\n    return min;\n}","816":"public static int indexOfMin(final int[] nums) {\n    long min = nums[0];\n    int index = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] < min) {\n            min = nums[i];\n            index = i;\n        }\n    }\n    return index;\n}","817":"public static int indexOfMin(final double[] nums) {\n    double min = nums[0];\n    int index = 0;\n    for (int i = 1; i < nums.length; ++i) {\n        if (nums[i] < min) {\n            min = nums[i];\n            index = i;\n        }\n    }\n    return index;\n}","818":"public static double[] getLogFromProbability(final double[] likelihood) {\n    final double[] tmp = new double[likelihood.length];\n    for (int i = 0; i < likelihood.length; ++i) {\n        tmp[i] = Math.log10(likelihood[i]);\n    }\n    return tmp;\n}","819":"public static double[] divide(final double[] numerators, final double[] denominators) {\n    if (numerators.length != denominators.length) {\n        throw new IllegalArgumentException(\"Arrays must be of same length.\");\n    }\n    final int len = numerators.length;\n    final double[] result = new double[len];\n    for (int i = 0; i < len; ++i) {\n        result[i] = numerators[i] \/ denominators[i];\n    }\n    return result;\n}","820":"public static double[] multiply(final double[] lhs, final double[] rhs) {\n    if (lhs.length != rhs.length) {\n        throw new IllegalArgumentException(\"Arrays must be of same length.\");\n    }\n    final int len = lhs.length;\n    final double[] result = new double[len];\n    for (int i = 0; i < len; ++i) {\n        result[i] = lhs[i] * rhs[i];\n    }\n    return result;\n}","821":"public static double[] sum(final double[] lhs, final double[] rhs) {\n    if (lhs.length != rhs.length) {\n        throw new IllegalArgumentException(\"Arrays must be of same length.\");\n    }\n    final int len = lhs.length;\n    final double[] result = new double[len];\n    for (int i = 0; i < len; ++i) {\n        result[i] = lhs[i] + rhs[i];\n    }\n    return result;\n}","822":"public static double[] sum(final double[] lhs, final double rhs) {\n    final int len = lhs.length;\n    final double[] result = new double[len];\n    for (int i = 0; i < len; ++i) {\n        result[i] = lhs[i] + rhs;\n    }\n    return result;\n}","823":"public static DbSnpBitSets createSnpAndIndelBitSets(final PicardHtsPath dbSnpFile, final SAMSequenceDictionary sequenceDictionary, final IntervalList intervals, final Optional<Log> log) {\n    final DbSnpBitSets sets = new DbSnpBitSets();\n    sets.snps = new DbSnpBitSetUtil();\n    sets.indels = new DbSnpBitSetUtil();\n    final Map<DbSnpBitSetUtil, Set<VariantType>> map = new HashMap<>();\n    map.put(sets.snps, EnumSet.of(VariantType.SNP));\n    map.put(sets.indels, EnumSet.of(VariantType.insertion, VariantType.deletion));\n    loadVcf(dbSnpFile, sequenceDictionary, map, intervals, log);\n    return sets;\n}","824":"private static byte[] getReadBases(final SAMRecord read) {\n    if (!read.getReadNegativeStrandFlag()) {\n        return read.getReadBases();\n    } else {\n        final byte[] reverseComplementedBases = new byte[read.getReadBases().length];\n        System.arraycopy(read.getReadBases(), 0, reverseComplementedBases, 0, reverseComplementedBases.length);\n        SequenceUtil.reverseComplement(reverseComplementedBases);\n        return reverseComplementedBases;\n    }\n}","825":"public static int[] subsettedPLIndices(final List<Allele> originalAlleles, final List<Allele> newAlleles) {\n    final int[] result = new int[GenotypeLikelihoods.numLikelihoods(newAlleles.size(), 2)];\n    for (int oldPLIndex = 0; oldPLIndex < GenotypeLikelihoods.numLikelihoods(originalAlleles.size(), 2); oldPLIndex++) {\n        final GenotypeLikelihoods.GenotypeLikelihoodsAllelePair allelePairFromPLIndex = GenotypeLikelihoods.getAllelePair(oldPLIndex);\n        final Allele allele1 = originalAlleles.get(allelePairFromPLIndex.alleleIndex1);\n        final Allele allele2 = originalAlleles.get(allelePairFromPLIndex.alleleIndex2);\n        final boolean containsOnlyNewAlleles = newAlleles.contains(allele1) && newAlleles.contains(allele2);\n        if (containsOnlyNewAlleles) {\n            final int newPLIndex = GenotypeLikelihoods.calculatePLindex(newAlleles.indexOf(allele1), newAlleles.indexOf(allele2));\n            result[newPLIndex] = oldPLIndex;\n        }\n    }\n    return result;\n}","826":"public int lenientHammingDistance() {\n    int numMismatches = 0;\n    for (int i = 0; i < barcodeBases.length && i < maskedBases.length && numMismatches <= maximalInterestingDistance; ++i) {\n        if (SequenceUtil.isNoCall(maskedBases[i])) {\n            continue;\n        }\n        if (!SequenceUtil.basesEqual(barcodeBases[i], maskedBases[i])) {\n            ++numMismatches;\n        }\n    }\n    return numMismatches;\n}","827":"\/**\n * Parse the tile # from the read name.\n * If we find that there are other elements needed from the read name, it might be a good idea to put\n * makeReadName() and various get..() methods into a new class.\n *\n * @param readName As produced by IlluminaUtil.makeReadName()\n * @return tile number, or null if read name is not in correct format.\n *\/\npublic static Integer getTileFromReadName(final String readName) {\n    final int first = readName.indexOf(':');\n    if (first > 0) {\n        final int second = readName.indexOf(':', first + 1);\n        if (second > 0) {\n            final int third = readName.indexOf(':', second + 1);\n            if (third > 0) {\n                return Integer.parseInt(readName.substring(second + 1, third));\n            }\n        }\n    }\n    return null;\n}","828":"public static byte getSolexaQualityCharFromFourQualities(final String[] qualities, final int cycleNumber, final FormatUtil formatter) {\n    int bestQuality = Integer.MIN_VALUE;\n    final int startOffset = (cycleNumber - 1) * 4;\n    for (int i = startOffset; i < startOffset + 4; ++i) {\n        final int quality = formatter.parseInt(qualities[i]);\n        if (quality > bestQuality) {\n            bestQuality = quality;\n        }\n    }\n    final int qualityAsCharacter = bestQuality + SolexaQualityConverter.SOLEXA_ADDEND;\n    if (qualityAsCharacter > 255) {\n        throw new PicardException(\"Quality too large: \" + bestQuality);\n    }\n    return (byte) (qualityAsCharacter & 0xff);\n}","829":"@Override\nprotected final Map<String, String> getGroupMap(final DocWorkUnit docWorkUnit) {\n    final Map<String, String> root = super.getGroupMap(docWorkUnit);\n    root.put(\"supercat\", HelpConstants.getSuperCategoryProperty(docWorkUnit.getGroupName()));\n    return root;\n}","830":"synchronized public int read(final byte[] bytes, final int start, final int size) {\n    try {\n        if (this.bytesAvailableToRead == 0 && !closed)\n            wait();\n    } catch (final InterruptedException ie) {\n        throw new PicardException(\"Interrupted while waiting to read from fifo.\", ie);\n    }\n    final int readPos = this.nextReadPos;\n    final int distanceToEnd = this.capacity - readPos;\n    final int available = distanceToEnd < this.bytesAvailableToRead ? distanceToEnd : this.bytesAvailableToRead;\n    final int length = available < size ? available : size;\n    System.arraycopy(this.bytes, readPos, bytes, start, length);\n    this.bytesAvailableToRead -= length;\n    this.bytesAvailableToWrite += length;\n    this.nextReadPos = (readPos + length) % this.capacity;\n    notify();\n    return length;\n}","831":"public Tuple<AdapterPair, Integer> findAdapterPairAndIndexForSingleRead(final byte[] read, final int minMatchBases, final double maxErrorRate, int templateIndex) {\n    final Tuple<AdapterPair, Integer> ret = ClippingUtility.findAdapterPairAndIndexForSingleRead(read, minMatchBases, maxErrorRate, templateIndex, adapters.get());\n    if (ret != null && !thresholdReached) {\n        tallyFoundAdapter(ret.a, false);\n    }\n    return ret;\n}","832":"\/**\n * Attempt to load a Properties object from an on-disk properties file.\n * @param propertyFilePath name of the properties file to load. Must have a .properties extension\n * @param clazz class used to obtain a class loader to use to locate the properties file\n * @return null if the files doesn't exist or isn't readable, otherwise a Properties object\n *\/\npublic static Properties loadPropertiesFile(final String propertyFilePath, final Class<?> clazz) {\n    Utils.nonNull(propertyFilePath);\n    try (final InputStream inputStream = clazz.getClassLoader().getResourceAsStream(propertyFilePath)) {\n        if (inputStream != null) {\n            final Properties properties = new Properties();\n            properties.load(inputStream);\n            return properties;\n        } else {\n            return null;\n        }\n    } catch (IOException ex) {\n        throw new RuntimeException(String.format(\"IOException loading properties file %s\", propertyFilePath), ex);\n    }\n}","833":"private boolean areAllBlockCompressed(final List<Path> input) {\n    for (final Path path : input) {\n        if (VCFFileReader.isBCF(path) || !IOUtil.hasBlockCompressedExtension(path)) {\n            return false;\n        }\n    }\n    return true;\n}","834":"public long getSum(final Set<TruthState> truthStateSet, final Set<CallState> callStateSet) {\n    long count = 0;\n    for (final TruthState truthState : truthStateSet) {\n        for (final CallState callState : callStateSet) {\n            count += getCount(truthState, callState);\n        }\n    }\n    return count;\n}","835":"public void validateScheme() throws PicardException {\n    if (!isValidated) {\n        for (final TruthState truthState : TruthState.values()) {\n            for (final CallState callState : CallState.values()) {\n                if (!scheme.containsKey(new TruthAndCallStates(truthState, callState))) {\n                    throw new PicardException(String.format(\"Missing scheme tuple: [%s, %s]\", truthState.name(), callState.name()));\n                }\n            }\n        }\n    }\n    isValidated = true;\n}","836":"private DetailPair getWorstMetrics(final List<DetailPair> metrics) {\n    PreAdapterDetailMetrics worstPreAdapterMetrics = null;\n    BaitBiasDetailMetrics worstBaitBiasMetrics = null;\n    for (final DetailPair m : metrics) {\n        if (worstPreAdapterMetrics == null || m.preAdapterMetrics.compareTo(worstPreAdapterMetrics) < 0)\n            worstPreAdapterMetrics = m.preAdapterMetrics;\n        if (worstBaitBiasMetrics == null || m.baitBiasMetrics.compareTo(worstBaitBiasMetrics) < 0)\n            worstBaitBiasMetrics = m.baitBiasMetrics;\n    }\n    return new DetailPair(worstPreAdapterMetrics, worstBaitBiasMetrics);\n}","837":"static double[] trimDistribution(final double[] distribution) {\n    int endOfDistribution = distribution.length;\n    if (distribution.length == 0) {\n        return distribution;\n    }\n    while (distribution[endOfDistribution - 1] == 0) {\n        endOfDistribution--;\n        if (endOfDistribution == 0)\n            break;\n    }\n    return Arrays.copyOfRange(distribution, 0, endOfDistribution);\n}","838":"private void rebase(int locusPosition) {\n    if (locusPosition < offset) {\n        throw new IllegalArgumentException(\"Position in the reference sequence is lesser than offset.\");\n    }\n    for (Counter counter : arrays) {\n        final int[] array = counter.array;\n        final int skipLength = locusPosition - offset;\n        System.arraycopy(array, skipLength, array, 0, arrayLength - skipLength);\n        Arrays.fill(array, arrayLength - skipLength, arrayLength, 0);\n    }\n    offset = locusPosition;\n}","839":"public double shiftedLogEvidenceProbabilityGivenOtherEvidence(final HaplotypeProbabilities otherHp) {\n    if (!this.haplotypeBlock.equals(otherHp.getHaplotype())) {\n        throw new IllegalArgumentException(\"Haplotypes are from different HaplotypeBlocks!\");\n    }\n    return shiftedLogEvidenceProbabilityUsingGenotypeFrequencies(otherHp.getPosteriorLikelihoods());\n}","840":"public HaplotypeMap withoutChromosomes(final Set<String> chroms) {\n    final HaplotypeMap out = new HaplotypeMap(getHeader());\n    for (final HaplotypeBlock block : this.haplotypeBlocks) {\n        if (!chroms.contains(block.getFirstSnp().getChrom())) {\n            out.addHaplotype(block);\n        }\n    }\n    return out;\n}","841":"@VisibleForTesting\nstatic VCFFileReader getVCFReader(final Path vcfPath, final Path indexPath, final boolean forceIndex) {\n    VCFFileReader reader = indexPath != null ? new VCFFileReader(vcfPath, indexPath) : new VCFFileReader(vcfPath, forceIndex);\n    if (forceIndex && !reader.isQueryable()) {\n        throw new PicardException(\"Input VCF file \" + vcfPath + \" has no index while user required index to proceed.\");\n    }\n    return reader;\n}","842":"public Map<String, Fingerprint> loadFingerprints(final Path fingerprintFile, final Path indexPath, final boolean forceIndex, final String specificSample) {\n    final VCFFileReader reader = getVCFReader(fingerprintFile, indexPath, forceIndex);\n    checkDictionaryGoodForFingerprinting(reader.getFileHeader().getSequenceDictionary());\n    final Map<String, Fingerprint> fingerprints;\n    if (reader.isQueryable()) {\n        fingerprints = loadFingerprintsFromQueriableReader(reader, specificSample, fingerprintFile);\n    } else {\n        log.warn(\"Couldn't find index for file \" + fingerprintFile + \" going to read through it all.\");\n        fingerprints = loadFingerprintsFromVariantContexts(reader, specificSample, fingerprintFile);\n    }\n    reader.getFileHeader().getGenotypeSamples().forEach(sample -> fingerprints.computeIfAbsent(sample, s -> new Fingerprint(s, fingerprintFile, null)));\n    return fingerprints;\n}","843":"public Map<String, Fingerprint> loadFingerprintsFromQueriableReader(final VCFFileReader reader, final String specificSample, final Path source) {\n    checkDictionaryGoodForFingerprinting(reader.getFileHeader().getSequenceDictionary());\n    final SortedSet<Snp> snps = new TreeSet<>(haplotypes.getAllSnps());\n    return loadFingerprintsFromVariantContexts(() -> snps.stream().map(snp -> {\n        try {\n            return reader.query(snp.getChrom(), snp.getPos(), snp.getPos()).next();\n        } catch (NoSuchElementException e) {\n            return null;\n        }\n    }).iterator(), specificSample, source);\n}","844":"public IntervalList getLociToGenotype(final Collection<Fingerprint> fingerprints) {\n    final IntervalList intervals = new IntervalList(this.haplotypes.getHeader());\n    for (final Fingerprint fp : fingerprints) {\n        for (final HaplotypeProbabilities genotype : fp.values()) {\n            final HaplotypeBlock h = genotype.getHaplotype();\n            for (final Snp snp : h.getSnps()) {\n                intervals.add(new Interval(snp.getChrom(), snp.getPos(), snp.getPos(), false, snp.getName()));\n            }\n        }\n    }\n    return intervals.uniqued();\n}","845":"public Map<String, Fingerprint> identifyContaminant(final Path samFile, final double contamination) {\n    final Map<FingerprintIdDetails, Fingerprint> fpIdDetailsMap = this.fingerprintSamFile(samFile, h -> new HaplotypeProbabilitiesFromContaminatorSequence(h, contamination));\n    final Map<FingerprintIdDetails, Fingerprint> fpIdDetailsBySample = Fingerprint.mergeFingerprintsBy(fpIdDetailsMap, Fingerprint.getFingerprintIdDetailsStringFunction(CrosscheckMetric.DataType.SAMPLE));\n    return fpIdDetailsBySample.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().sample, Map.Entry::getValue));\n}","846":"@Override\npublic HaplotypeProbabilitiesUsingLogLikelihoods merge(final HaplotypeProbabilities other) {\n    if (!this.getHaplotype().equals(other.getHaplotype())) {\n        throw new IllegalArgumentException(\"Mismatched haplotypes in call to HaplotypeProbabilities.merge(): \" + getHaplotype() + \", \" + other.getHaplotype());\n    }\n    if (!(other instanceof HaplotypeProbabilitiesUsingLogLikelihoods)) {\n        throw new IllegalArgumentException(String.format(\"Can only merge HaplotypeProbabilities of same class. Found %s and %s\", this.getClass().toString(), other.getClass().toString()));\n    }\n    final HaplotypeProbabilitiesUsingLogLikelihoods o = (HaplotypeProbabilitiesUsingLogLikelihoods) other;\n    setLogLikelihoods(MathUtil.sum(getLogLikelihoods(), o.getLogLikelihoods()));\n    return this;\n}","847":"public PedFile removeIncompleteTrios() {\n    final Iterator<Map.Entry<String, PedTrio>> iterator = entrySet().iterator();\n    while (iterator.hasNext()) {\n        if (!iterator.next().getValue().hasBothParents())\n            iterator.remove();\n    }\n    return this;\n}","848":"private NumPrimaryAlignmentState tallyPrimaryAlignments(final List<SAMRecord> records) {\n    boolean seenPrimary = false;\n    for (int i = 0; i < records.size(); ++i) {\n        if (records.get(i) != null && !records.get(i).isSecondaryOrSupplementary()) {\n            if (seenPrimary)\n                return NumPrimaryAlignmentState.MORE_THAN_ONE;\n            else\n                seenPrimary = true;\n        }\n    }\n    if (seenPrimary)\n        return NumPrimaryAlignmentState.ONE;\n    else\n        return NumPrimaryAlignmentState.NONE;\n}","849":"@Override\npublic boolean equals(final Object o) {\n    if (this == o)\n        return true;\n    if (!(o instanceof Pair))\n        return false;\n    final Pair other = (Pair) o;\n    return Objects.equals(left, other.left) && Objects.equals(right, other.right);\n}","850":"private void consumeUnmatchedRights(final SecondaryOrSupplementarySkippingIterator rightIt, final Map<PrimaryAlignmentKey, SAMRecord> leftUnmatched) {\n    consumeAll(rightIt, (alignmentRecord, primaryKey) -> {\n        final SAMRecord left = leftUnmatched.remove(primaryKey);\n        if (left != null) {\n            tallyAlignmentRecords(left, alignmentRecord);\n        } else {\n            ++comparisonMetric.MISSING_LEFT;\n        }\n    });\n}","851":"private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) {\n    if (!s1.getReadName().equals(s2.getReadName())) {\n        throw new PicardException(\"Read names do not match: \" + s1.getReadName() + \" : \" + s2.getReadName());\n    }\n    catalogDuplicateDifferences(s1, s2);\n    final AlignmentComparison comp = compareAlignmentRecords(s1, s2);\n    comparisonMetric.updateMetric(comp);\n    if (samComparisonArgumentCollection.COMPARE_MQ) {\n        compareAndUpdateMappingQualityConcordance(s1, s2);\n    }\n}","852":"private void writeReadsFile(final File samOrBamFile) throws IOException {\n    final File readsFile = new File(OUTPUT.getParentFile(), IOUtil.basename(samOrBamFile) + \".reads\");\n    IOUtil.assertFileIsWritable(readsFile);\n    try (final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(samOrBamFile);\n        final BufferedWriter bw = IOUtil.openFileForBufferedWriting(readsFile, false)) {\n        for (final SAMRecord rec : reader) {\n            bw.write(rec.toString() + \"\\n\");\n        }\n    }\n    IOUtil.assertFileIsReadable(readsFile);\n}","853":"\/**\n * Read all the sequences from the given reference file, and convert into SAMSequenceRecords\n *\n * @param referenceFile fasta or fasta.gz\n * @return SAMSequenceRecords containing info from the fasta, plus from cmd-line arguments.\n *\/\npublic SAMSequenceDictionary makeSequenceDictionary(final File referenceFile) {\n    final Iterable<SAMSequenceRecord> samSequenceRecordsIterable = getSamSequenceRecordsIterable();\n    final List<SAMSequenceRecord> ret = new ArrayList<>();\n    final Set<String> sequenceNames = new HashSet<>();\n    for (SAMSequenceRecord rec : samSequenceRecordsIterable) {\n        if (sequenceNames.contains(rec.getSequenceName())) {\n            throw new PicardException(\"Sequence name appears more than once in reference: \" + rec.getSequenceName());\n        }\n        sequenceNames.add(rec.getSequenceName());\n        ret.add(rec);\n    }\n    return new SAMSequenceDictionary(ret);\n}","854":"protected String[] customCommandLineValidation() {\n    if (URI == null) {\n        URI = \"file:\" + referenceSequence.getReferenceFile().getAbsolutePath();\n    }\n    if (OUTPUT == null) {\n        OUTPUT = ReferenceSequenceFileFactory.getDefaultDictionaryForReferenceSequence(referenceSequence.getReferenceFile());\n        logger.info(\"Output dictionary will be written in \", OUTPUT);\n    }\n    return super.customCommandLineValidation();\n}","855":"private int newOrderIndex(SAMRecord read, int oldIndex, Map<Integer, Integer> newOrder) {\n    if (oldIndex == NO_ALIGNMENT_REFERENCE_INDEX) {\n        return NO_ALIGNMENT_REFERENCE_INDEX;\n    } else {\n        final Integer n = newOrder.get(oldIndex);\n        if (n == null) {\n            throw new PicardException(\"BUG: no mapping found for read \" + read.getSAMString());\n        } else {\n            return n;\n        }\n    }\n}","856":"public static void convert(final File input, final File output, final File referenceSequence, final Boolean createIndex) {\n    IOUtil.assertFileIsReadable(input);\n    IOUtil.assertFileIsWritable(output);\n    final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceSequence).open(input);\n    final SAMFileWriter writer = new SAMFileWriterFactory().makeWriter(reader.getFileHeader(), true, output, referenceSequence);\n    if (createIndex && writer.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.coordinate) {\n        throw new PicardException(\"Can't CREATE_INDEX unless sort order is coordinate\");\n    }\n    final ProgressLogger progress = new ProgressLogger(Log.getInstance(SamFormatConverter.class));\n    for (final SAMRecord rec : reader) {\n        writer.addAlignment(rec);\n        progress.record(rec);\n    }\n    CloserUtil.close(reader);\n    writer.close();\n}","857":"private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, final SAMRecord secondUnaligned, final SAMRecord firstAligned, final SAMRecord secondAligned, final boolean isContaminant, final boolean needsSafeReverseComplement) {\n    if (firstAligned != null) {\n        transferAlignmentInfoToFragment(firstUnaligned, firstAligned, isContaminant, needsSafeReverseComplement);\n    }\n    if (secondAligned != null) {\n        transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n    }\n    if (isClipOverlappingReads()) {\n        clipForOverlappingReads(firstUnaligned, secondUnaligned, hardClipOverlappingReads);\n    }\n    SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n    if (!keepAlignerProperPairFlags) {\n        SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n    }\n}","858":"protected boolean ignoreAlignment(final SAMRecord sam) {\n    if (maxGaps == -1)\n        return false;\n    int gaps = 0;\n    for (final CigarElement el : sam.getCigar().getCigarElements()) {\n        if (el.getOperator() == CigarOperator.I || el.getOperator() == CigarOperator.D) {\n            gaps++;\n        }\n    }\n    return gaps > maxGaps;\n}","859":"protected boolean isContaminant(final HitsForInsert hits) {\n    boolean isContaminant = false;\n    if (hits.numHits() > 0) {\n        final int primaryIndex = hits.getIndexOfEarliestPrimary();\n        if (primaryIndex < 0)\n            throw new IllegalStateException(\"No primary alignment was found, despite having nonzero hits.\");\n        final SAMRecord primaryRead1 = hits.getFirstOfPair(primaryIndex);\n        final SAMRecord primaryRead2 = hits.getSecondOfPair(primaryIndex);\n        if (primaryRead1 != null && primaryRead2 != null)\n            isContaminant = contaminationFilter.filterOut(primaryRead1, primaryRead2);\n        else if (primaryRead1 != null)\n            isContaminant = contaminationFilter.filterOut(primaryRead1);\n        else if (primaryRead2 != null)\n            isContaminant = contaminationFilter.filterOut(primaryRead2);\n        else\n            throw new IllegalStateException(\"Neither read1 or read2 exist for chosen primary alignment\");\n    }\n    return isContaminant;\n}","860":"private List<SAMRecord> fetchByReadName(final PeekableIterator<SAMRecord> iterator) {\n    final List<SAMRecord> out = new ArrayList<>();\n    if (iterator.hasNext()) {\n        final SAMRecord first = iterator.next();\n        out.add(first);\n        while (iterator.hasNext() && iterator.peek().getReadName().equals(first.getReadName())) {\n            out.add(iterator.next());\n        }\n    }\n    return out;\n}","861":"private void randomlySelectPrimaryFromBest(List<SAMRecord> recs) {\n    if (recs.isEmpty())\n        return;\n    final int bestMapq = recs.get(0).getMappingQuality();\n    int i;\n    for (i = 1; i < recs.size() && recs.get(i).getMappingQuality() == bestMapq; ++i) {\n    }\n    final int bestIndex = random.nextInt(i);\n    if (bestIndex == 0)\n        return;\n    final SAMRecord tmp = recs.get(0);\n    recs.set(0, recs.get(bestIndex));\n    recs.set(bestIndex, tmp);\n}","862":"private static int stratifyCycle(final RecordAndOffset recordAndOffset) {\n    final SAMRecord rec = recordAndOffset.getRecord();\n    final int offset = recordAndOffset.getOffset();\n    int retval = rec.getReadNegativeStrandFlag() ? (rec.getReadLength() - offset - 1) : offset;\n    retval += 1;\n    return retval;\n}","863":"private void initializeVcfDataSource() throws IOException {\n    if (INTERVAL_ITERATOR) {\n        vcfFileReader = new VCFFileReader(IOUtil.getPath(VCF), false);\n        if (!vcfFileReader.isQueryable()) {\n            throw new PicardException(\"Cannot query VCF File!  VCF Files must be queryable!  Please index input VCF and re-run.\");\n        }\n    } else {\n        vcfIterator = new PeekableIterator<>(VCF == null ? Collections.emptyIterator() : new VCFFileReader(IOUtil.getPath(VCF), false).iterator());\n    }\n}","864":"private static boolean checkLocus(final VCFFileReader vcfFileReader, final SamLocusIterator.LocusInfo locusInfo) {\n    boolean overlaps = false;\n    if (locusInfo != null) {\n        try (final CloseableIterator<VariantContext> vcfIterator = vcfFileReader.query(locusInfo)) {\n            while (vcfIterator.hasNext()) {\n                if (vcfIterator.next().isFiltered()) {\n                    continue;\n                }\n                overlaps = true;\n                break;\n            }\n        }\n    }\n    return overlaps;\n}","865":"\/**\n * The function by which new loci are \"shown\" to the calculator\n *\/\n@Override\npublic void addBase(final SamLocusIterator.RecordAndOffset recordAndOffset, final SamLocusAndReferenceIterator.SAMLocusAndReference locusAndRef) {\n    super.addBase(recordAndOffset, locusAndRef);\n    if (recordAndOffset.getAlignmentType() == AbstractRecordAndOffset.AlignmentType.Match) {\n        final byte readBase = recordAndOffset.getReadBase();\n        if (!SequenceUtil.isNoCall(readBase) && (readBase != locusAndRef.getReferenceBase())) {\n            nMismatchingBases++;\n        }\n    }\n}","866":"\/**\n * Fills in the ESTIMATED_LIBRARY_SIZE based on the paired read data examined where\n * possible and the PERCENT_DUPLICATION.\n *\/\n@Override\npublic void calculateDerivedFields() {\n    this.ESTIMATED_LIBRARY_SIZE = estimateLibrarySize(this.READ_PAIRS_EXAMINED - this.READ_PAIR_OPTICAL_DUPLICATES, this.READ_PAIRS_EXAMINED - this.READ_PAIR_DUPLICATES);\n    if (UNPAIRED_READS_EXAMINED + READ_PAIRS_EXAMINED != 0) {\n        PERCENT_DUPLICATION = (UNPAIRED_READ_DUPLICATES + READ_PAIR_DUPLICATES * 2) \/ (double) (UNPAIRED_READS_EXAMINED + READ_PAIRS_EXAMINED * 2);\n    } else {\n        PERCENT_DUPLICATION = (double) 0;\n    }\n}","867":"public void addDuplicateReadToMetrics(final SAMRecord rec) {\n    if (!rec.isSecondaryOrSupplementary() && !rec.getReadUnmappedFlag()) {\n        if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {\n            ++UNPAIRED_READ_DUPLICATES;\n        } else {\n            ++READ_PAIR_DUPLICATES;\n        }\n    }\n}","868":"public void addReadToLibraryMetrics(final SAMRecord rec) {\n    if (rec.getReadUnmappedFlag()) {\n        ++UNMAPPED_READS;\n    } else if (rec.isSecondaryOrSupplementary()) {\n        ++SECONDARY_OR_SUPPLEMENTARY_RDS;\n    } else if (!rec.getReadPairedFlag() || rec.getMateUnmappedFlag()) {\n        ++UNPAIRED_READS_EXAMINED;\n    } else {\n        ++READ_PAIRS_EXAMINED;\n    }\n}","869":"boolean passesQualityCheck(final byte[] bases, final byte[] quals, final int seedLength, final int minQuality) {\n    if (bases.length < seedLength)\n        return false;\n    for (int i = 0; i < seedLength; ++i) {\n        if (SequenceUtil.isNoCall(bases[i]))\n            return false;\n    }\n    final int maxReadLength = (MAX_READ_LENGTH <= 0) ? Integer.MAX_VALUE : MAX_READ_LENGTH;\n    final int readLength = Math.min(bases.length, maxReadLength);\n    int total = 0;\n    for (int i = 0; i < readLength; i++) total += quals[i];\n    return total \/ readLength >= minQuality;\n}","870":"public static String getLibraryName(final SAMFileHeader header, final SAMRecord rec) {\n    final String readGroupId = (String) rec.getAttribute(ReservedTagConstants.READ_GROUP_ID);\n    if (readGroupId != null) {\n        final SAMReadGroupRecord rg = header.getReadGroup(readGroupId);\n        if (rg != null) {\n            final String libraryName = rg.getLibrary();\n            if (null != libraryName)\n                return libraryName;\n        }\n    }\n    return UNKNOWN_LIBRARY;\n}","871":"public static byte getOrientationByte(final boolean read1NegativeStrand, final boolean read2NegativeStrand) {\n    if (read1NegativeStrand) {\n        if (read2NegativeStrand)\n            return ReadEnds.RR;\n        else\n            return ReadEnds.RF;\n    } else {\n        if (read2NegativeStrand)\n            return ReadEnds.FR;\n        else\n            return ReadEnds.FF;\n    }\n}","872":"private int compareHashes(byte[] read1, byte[] read2, int hashNumber) {\n    int errors = 0;\n    int position = minIdenticalBases + hashNumber;\n    while (position < minReadLenInGroup) {\n        if (read1[position] != read2[position]) {\n            errors++;\n        }\n        position += numberOfHashesInGroup;\n    }\n    return errors;\n}","873":"private boolean areComparableForDuplicatesWithEndSignificance(final ReadEndsForMarkDuplicates lhs, final ReadEndsForMarkDuplicates rhs, final boolean useBarcodes, final int lhsRead1Coordinate2Min, final int lhsRead1Coordinate2Max) {\n    boolean areComparable = md.areComparableForDuplicates(lhs, rhs, false, useBarcodes);\n    if (areComparable) {\n        areComparable = (!endCoorSignificant(lhs.read2Coordinate, rhs.read2Coordinate) || endCoorInRangeWithUncertainty(lhsRead1Coordinate2Min, lhsRead1Coordinate2Max, rhs.read2Coordinate, md.flowBasedArguments.UNPAIRED_END_UNCERTAINTY));\n    }\n    return areComparable;\n}","874":"private SAMRecord flush() {\n    while (!outputBuffer.isEmpty() && outputBuffer.canEmit()) {\n        final SAMRecord record = outputBuffer.next().getRecord();\n        if (!removeDuplicates || !record.getDuplicateReadFlag()) {\n            return record;\n        }\n    }\n    return null;\n}","875":"private void addRecordToTheOutputBuffer(final SamRecordWithOrdinal samRecordWithOrdinal) throws PicardException {\n    final int recordReferenceIndex = samRecordWithOrdinal.getRecord().getReferenceIndex();\n    if (recordReferenceIndex < referenceIndex) {\n        throw new PicardException(\"Records out of order: \" + recordReferenceIndex + \" < \" + referenceIndex);\n    } else if (referenceIndex < recordReferenceIndex) {\n        tryPollingTheToMarkQueue(true, null);\n        referenceIndex = recordReferenceIndex;\n    }\n    outputBuffer.add(samRecordWithOrdinal);\n}","876":"public CommandLineParser getCommandLineParser() {\n    if (commandLineParser == null) {\n        commandLineParser = useLegacyParser() ? new LegacyCommandLineArgumentParser(this) : new CommandLineArgumentParser(this, Collections.EMPTY_LIST, Collections.singleton(CommandLineParserOptions.APPEND_TO_COLLECTIONS));\n    }\n    return commandLineParser;\n}","877":"public static void processAllCommandLinePrograms(final List<String> packageList, final BiConsumer<Class<CommandLineProgram>, CommandLineProgramProperties> clpClassProcessor) {\n    final ClassFinder classFinder = new ClassFinder();\n    packageList.forEach(pkg -> classFinder.find(pkg, CommandLineProgram.class));\n    for (final Class clazz : classFinder.getClasses()) {\n        if (!clazz.isInterface() && !clazz.isSynthetic() && !clazz.isPrimitive() && !clazz.isLocalClass() && !Modifier.isAbstract(clazz.getModifiers())) {\n            clpClassProcessor.accept(clazz, PicardCommandLine.getProgramProperty(clazz));\n        }\n    }\n}","878":"public static String encodeLines(byte[] in, int iOff, int iLen, int lineLen, String lineSeparator) {\n    int blockLen = (lineLen * 3) \/ 4;\n    if (blockLen <= 0)\n        throw new IllegalArgumentException();\n    int lines = (iLen + blockLen - 1) \/ blockLen;\n    int bufLen = ((iLen + 2) \/ 3) * 4 + lines * lineSeparator.length();\n    StringBuilder buf = new StringBuilder(bufLen);\n    int ip = 0;\n    while (ip < iLen) {\n        int l = Math.min(iLen - ip, blockLen);\n        buf.append(encode(in, iOff + ip, l));\n        buf.append(lineSeparator);\n        ip += l;\n    }\n    return buf.toString();\n}","879":"private ImageIcon createImageIcon(String url, String description) {\n    java.net.URL imgURL = getClass().getResource(url);\n    if (imgURL != null) {\n        return new ImageIcon(imgURL, description);\n    } else {\n        System.err.println(\"Couldn't find file: \" + url);\n        return null;\n    }\n}","880":"public void fireProgressChange(int value) {\n    if (isReady) {\n        final int newValue = oldValue + value;\n        PropertyChangeEvent event = new PropertyChangeEvent(this, PROGRESS_PROPERTY, oldValue, newValue);\n        propertyChangeSupport.firePropertyChange(event);\n        oldValue = newValue;\n    }\n}","881":"public void fireProgress(final int newValue) {\n    if (isReady) {\n        PropertyChangeEvent event = new PropertyChangeEvent(this, PROGRESS_PROPERTY, oldValue, newValue);\n        propertyChangeSupport.firePropertyChange(event);\n        oldValue = newValue;\n    }\n}","882":"public static void invokeAndWaitOnEventThread(Runnable runnable) {\n    if (SwingUtilities.isEventDispatchThread()) {\n        runnable.run();\n    } else {\n        try {\n            SwingUtilities.invokeAndWait(runnable);\n        } catch (InterruptedException e) {\n            log.error(\"Error invoking runnable\", e);\n            UIUtilities.invokeOnEventThread(runnable);\n        } catch (InvocationTargetException e) {\n            log.error(\"Error invoking runnable\", e);\n            UIUtilities.invokeOnEventThread(runnable);\n        }\n    }\n}","883":"private static File fixFileExt(File selectedFile, String[] allowedExts, String defExtension) {\n    boolean hasExt = false;\n    if (selectedFile != null) {\n        for (String ext : allowedExts) {\n            if (selectedFile.getName().toLowerCase().endsWith(ext)) {\n                hasExt = true;\n                break;\n            }\n        }\n        if (!hasExt) {\n            String addExt = defExtension.startsWith(\".\") ? defExtension : \".\" + defExtension;\n            String correctedFilename = selectedFile.getAbsolutePath() + addExt;\n            selectedFile = new File(correctedFilename);\n        }\n    }\n    return selectedFile;\n}","884":"public void save() {\n    filterElement.setSelectedItem(getItem());\n    Operator operator = getOperatorForText(getComparisonOperator());\n    filterElement.setComparisonOperator(operator);\n    filterElement.setExpectedValue(getExpectedValue());\n}","885":"\/**\n * @param idx\n * @return\n * @see #randomColor(int, float)\n *\/\nprivate static int[] quasiRandomColor(int idx) {\n    int BASE_COL = 40;\n    int RAND_COL = 255 - BASE_COL;\n    \/\/ avoid 0\n    idx += 1;\n    int r = Math.abs(BASE_COL + (idx * 33) % RAND_COL);\n    int g = Math.abs(BASE_COL + (idx * 55) % RAND_COL);\n    int b = Math.abs(BASE_COL + (idx * 77) % RAND_COL);\n    return new int[] { r, g, b };\n}","886":"\/**\n * <p>This creates the Transferable object. In our case, RandomDragAndDropPanel implements Transferable, so this requires only a type cast.<\/p>\n *\n * @param c\n * @return\n *\/\n@Override()\npublic Transferable createTransferable(JComponent c) {\n    \/\/ TaskInstancePanel implements Transferable\n    if (c instanceof HeaderPanel) {\n        Transferable tip = (HeaderPanel) c;\n        return tip;\n    }\n    \/\/ Not found\n    return null;\n}","887":"\/**\n * Run the batch script.  This is PURPOSELY run on the event dispatch thread to maintain absolute synchronization\n * @param e\n *\/\npublic void actionPerformed(ActionEvent e) {\n    if (e.getActionCommand().equalsIgnoreCase(\"run batch script...\")) {\n        File[] script = chooseScriptFile();\n        if (script != null && script.length > 0) {\n            for (File f : script) {\n                final BatchRunner bRun = new BatchRunner(f.getPath(), igv);\n                bRun.run();\n            }\n        }\n    }\n}","888":"default boolean contains(IGVFeature feature) {\n    if (feature == null) {\n        return false;\n    }\n    if (!this.getChr().equals(feature.getChr()) || this.getStrand() != feature.getStrand()) {\n        return false;\n    }\n    if ((feature.getStart() >= this.getStart()) && (feature.getEnd() <= this.getEnd())) {\n        return true;\n    } else {\n        return false;\n    }\n}","889":"public CodonTable getCodonTableForChromosome(String genomeID, String chr) {\n    if (currentCodonTable != null) {\n        return currentCodonTable;\n    } else {\n        CodonTableMap map = genomeChromoTable.get(genomeID);\n        if (map == null) {\n            return defaultCodonTable;\n        } else {\n            Integer tableID = map.getTableIdForChr(chr);\n            return allCodonTables.get(tableID);\n        }\n    }\n}","890":"public static Set<String> getAllSNPs(String sequence) {\n    Set<String> SNPs = new HashSet<String>();\n    char[] bps = \"ATGC\".toCharArray();\n    char[] orig = sequence.toCharArray();\n    char[] mod;\n    for (int loc = 0; loc < orig.length; loc++) {\n        mod = orig.clone();\n        for (char bp : bps) {\n            if (bp == orig[loc]) {\n                continue;\n            }\n            mod[loc] = bp;\n            SNPs.add(new String(mod));\n        }\n    }\n    return SNPs;\n}","891":"private int[] findDigitRange(String chr) {\n    int[] locs = null;\n    int loc = 0;\n    for (char c : chr.toCharArray()) {\n        if (Character.isDigit(c)) {\n            if (locs == null) {\n                locs = new int[] { loc, chr.length() };\n            }\n        } else if (locs != null) {\n            locs[1] = loc;\n            break;\n        }\n        loc++;\n    }\n    return locs;\n}","892":"public static FeatureTrack createGeneTrack(Genome genome, List<htsjdk.tribble.Feature> features) {\n    FeatureDB.clearFeatures();\n    FeatureTrack geneFeatureTrack = null;\n    String name = \"Annotations\";\n    String id = genome.getId() + \"_genes\";\n    geneFeatureTrack = new FeatureTrack(id, name, new FeatureCollectionSource(features, genome));\n    geneFeatureTrack.setMinimumHeight(5);\n    geneFeatureTrack.setHeight(35);\n    geneFeatureTrack.setColor(Color.BLUE.darker());\n    return geneFeatureTrack;\n}","893":"public void sortExons() {\n    if (exons != null) {\n        Collections.sort(exons, new Comparator<IGVFeature>() {\n\n            public int compare(IGVFeature arg0, IGVFeature arg1) {\n                return arg0.getStart() - arg1.getStart();\n            }\n        });\n    }\n}","894":"public static Feature getFeatureStartsAfter(double position, List<? extends Feature> features) {\n    if (features.size() == 0 || features.get(features.size() - 1).getStart() <= position) {\n        return null;\n    }\n    int idxBefore = getIndexBefore(position, features);\n    if (idxBefore >= features.size() - 1) {\n        return null;\n    } else {\n        for (Feature f : features) {\n            if (f.getStart() > position)\n                return f;\n        }\n    }\n    return null;\n}","895":"public static Feature getFeatureCenteredAfter(double position, List<? extends Feature> features) {\n    if (features.size() == 0 || center(features.get(features.size() - 1)) <= position) {\n        return null;\n    }\n    int idx = getIndexCenterAfter(position, features);\n    if (idx < 0 || idx > features.size() - 1) {\n        return null;\n    } else {\n        return features.get(idx);\n    }\n}","896":"public CloseableIterator<T> iterator() {\n    if (this.cleanedUp) {\n        throw new IllegalStateException(\"Cannot call iterator() after cleanup() was called.\");\n    }\n    doneAdding();\n    this.iterationStarted = true;\n    if (this.files.isEmpty()) {\n        return new InMemoryIterator();\n    } else {\n        return new MergingIterator();\n    }\n}","897":"public static boolean deleteDir(File dir) {\n    if (dir.isDirectory()) {\n        String[] children = dir.list();\n        for (int i = 0; i < children.length; i++) {\n            boolean success = deleteDir(new File(dir, children[i]));\n            if (!success) {\n                return false;\n            }\n        }\n    }\n    return dir.delete();\n}","898":"static String getClaim(String jwt, String claim) {\n    try {\n        final JsonObject payload = getPayload(jwt);\n        final Object claimValue = payload.get(claim);\n        if (claimValue != null) {\n            return claimValue.toString();\n        }\n    } catch (final Exception e) {\n        throw new InvalidParameterException(\"invalid token\");\n    }\n    return null;\n}","899":"public static String capWords(String text) {\n    String res = \"\";\n    boolean capNext = true;\n    String s;\n    for (char c : text.toLowerCase().toCharArray()) {\n        s = Character.toString(c);\n        if (capNext) {\n            s = s.toUpperCase();\n        }\n        res += s;\n        capNext = \" \".equals(s);\n    }\n    return res;\n}","900":"\/**\n * Attempts to open the default web browser to the given URL.\n *\n * @param url The URL to open\n * @throws IOException If the web browser could not be located or does not run\n *\/\npublic static void openURL(String url) throws IOException {\n    if (!(Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE))) {\n        openURL_old(url);\n    } else {\n        try {\n            Desktop.getDesktop().browse(new URI(url));\n        } catch (URISyntaxException e) {\n            log.error(\"Error opening url \" + url, e);\n        }\n    }\n}","901":"public static void openURL(URL url) throws IOException {\n    if (!(Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE))) {\n        openURL_old(url.toExternalForm());\n    } else {\n        try {\n            Desktop.getDesktop().browse(url.toURI());\n        } catch (URISyntaxException e) {\n            log.error(\"Error opening url \" + url, e);\n        }\n    }\n}","902":"private static String preprocessUrlStr(final String str, final boolean encode) {\n    if (encode) {\n        try {\n            return (URLEncoder.encode(str, \"UTF-8\").replace(\"%3A\", \":\").replace(\"%2F\", \"\/\").replace(\"+\", \"%20\"));\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    return str;\n}","903":"private static String decode(final String str) {\n    if (str == null) {\n        return null;\n    }\n    for (int i = 0; i < str.length(); ++i) {\n        if (str.charAt(i) == '%') {\n            return decode(str, i);\n        }\n    }\n    return str;\n}","904":"private static void appendDecoded(final StringBuilder builder, final String str, final int index) {\n    if (index > str.length() - 3) {\n        throw new IllegalStateException(\"Invalid percent-encoded string:\" + \"\\\"\" + str + \"\\\".\");\n    }\n    char first = str.charAt(index + 1);\n    char second = str.charAt(index + 2);\n    char decoded = (char) ((fromHex(first) << 4) | fromHex(second));\n    builder.append(decoded);\n}","905":"public String detectIndexPath(String inputPath) {\n    log.debug(\"detectIndexPath() input S3 path is: \" + inputPath);\n    String indexPath = \"\";\n    if (inputPath.contains(\".bam\")) {\n        indexPath = inputPath + \".bai\";\n    } else if (inputPath.endsWith(\".gz\")) {\n        indexPath = inputPath + \".tbi\";\n    } else {\n        log.debug(\"S3 index object filetype could not be determined from S3 url\");\n    }\n    return indexPath;\n}","906":"public static String indexFile(ResourceLocator locator) {\n    if (locator.getIndexPath() != null) {\n        return locator.getIndexPath();\n    } else {\n        if (isCloudOrDropbox(locator.getPath())) {\n            return null;\n        } else {\n            String indexExtension = (locator.getURLPath().toLowerCase().endsWith(\".gz\") || locator.getPath().toLowerCase().endsWith(\".bgz\")) ? \".tbi\" : Tribble.STANDARD_INDEX_EXTENSION;\n            return appendToPath(locator, indexExtension);\n        }\n    }\n}","907":"private OAuthProvider parseProviderJson(String json) throws IOException {\n    JsonParser parser = new JsonParser();\n    JsonObject obj = parser.parse(json).getAsJsonObject();\n    OAuthProvider p = new OAuthProvider(obj);\n    providerCache.put(p.getState(), p);\n    if (obj.has(\"auth_provider\") && obj.get(\"auth_provider\").getAsString().equals(\"Amazon\")) {\n        awsProvider = p;\n        AmazonUtils.setCognitoConfig(obj);\n    }\n    if (p.isGoogle()) {\n        defaultProvider = p;\n    }\n    return p;\n}","908":"public String asString() {\n    StringBuffer buf = new StringBuffer();\n    buf.append(serializationClassId);\n    for (Map.Entry<String, Color> mapEntry : colorMap.entrySet()) {\n        buf.append(\";\");\n        buf.append(mapEntry.getKey() + \" \");\n        buf.append(ColorUtilities.colorToString(mapEntry.getValue()));\n    }\n    return buf.toString();\n}","909":"public boolean isSame(MappedColorScale anotherCS) {\n    if (this.getSize() != anotherCS.getSize()) {\n        return false;\n    }\n    for (String key : colorMap.keySet()) {\n        if (!this.getColor(key).equals(anotherCS.getColor(key))) {\n            return false;\n        }\n    }\n    return true;\n}","910":"synchronized public ZoomLevelIterator getZoomLevelIterator(int zoomLevel) {\n    if (zoomLevel < 1 || zoomLevel > zoomLevelCount)\n        throw new RuntimeException(\"Error: ZoomLevelIterator zoom level is out of range\\n\");\n    RPTree zoomDataTree = zoomLevels.getZoomLevelRPTree(zoomLevel);\n    RPChromosomeRegion selectionRegion = zoomDataTree.getChromosomeBounds();\n    boolean contained = true;\n    ZoomLevelIterator zoomIterator = new ZoomLevelIterator(fis, chromosomeIDTree, zoomDataTree, zoomLevel, selectionRegion, contained);\n    return zoomIterator;\n}","911":"private Range getAlignmentListRange(List<Alignment> alignmentsList) {\n    if (alignmentsList == null || alignmentsList.size() == 0)\n        return null;\n    Alignment firstAlignment = alignmentsList.get(0);\n    int minStart = firstAlignment.getStart();\n    int maxEnd = firstAlignment.getEnd();\n    for (Alignment alignment : alignmentsList) {\n        maxEnd = Math.max(maxEnd, alignment.getEnd());\n    }\n    return new Range(firstAlignment.getChr(), minStart, maxEnd);\n}","912":"@Override\npublic Alignment getSpecificAlignment(final double location) {\n    Alignment sa = null;\n    for (Alignment a : alignments) {\n        if (a.contains(location)) {\n            if (sa == null || (a.getLengthOnReference() < sa.getLengthOnReference())) {\n                sa = a;\n            }\n        }\n    }\n    return sa;\n}","913":"public String getAlignmentValueString(double position, int mouseX, AlignmentTrack.RenderOptions renderOptions) {\n    StringBuffer buf = new StringBuffer();\n    if (secondAlignment != null) {\n        buf.append(\"<table><tr><td valign=\\\"top\\\">\");\n    }\n    buf.append(\"<b>Left alignment<\/b><br\/>\");\n    buf.append(firstAlignment.getAlignmentValueString(position, mouseX, renderOptions));\n    if (secondAlignment != null) {\n        buf.append(\"<\/td><td valign=\\\"top\\\">\");\n        buf.append(\"<b>Right alignment<\/b><br\/>\");\n        buf.append(secondAlignment.getAlignmentValueString(position, mouseX, renderOptions));\n        buf.append(\"<\/td><\/tr><\/table>\");\n    }\n    return buf.toString();\n}","914":"@Override\npublic Alignment getSpecificAlignment(final double location) {\n    Alignment first = getFirstAlignment();\n    Alignment second = getSecondAlignment();\n    if (first.contains(location)) {\n        return first;\n    } else if (second.contains(location)) {\n        return second;\n    } else {\n        return null;\n    }\n}","915":"static boolean isMisMatch(byte[] reference, ByteSubarray read, boolean isSoftClipped, int idx) {\n    if (reference == null)\n        return false;\n    boolean misMatch = false;\n    if (isSoftClipped) {\n        final byte readbase = read.getByte(idx);\n        misMatch = readbase != '=';\n    } else {\n        final int referenceLength = reference.length;\n        final byte refbase = idx < referenceLength ? reference[idx] : 0;\n        final byte readbase = read.getByte(idx);\n        misMatch = readbase != '=' && idx < referenceLength && refbase != 0 && !AlignmentUtils.compareBases(refbase, readbase);\n    }\n    return misMatch;\n}","916":"public static byte[] reverseComplementCopy(final byte[] bases) {\n    final int lastIndex = bases.length - 1;\n    byte[] out = new byte[bases.length];\n    int i;\n    for (i = 0; i <= lastIndex; i++) {\n        out[lastIndex - i] = complement(bases[i]);\n    }\n    return out;\n}","917":"public static ByteSubarray reverseComplementCopy(ByteSubarray bases) {\n    final int lastIndex = bases.length - 1;\n    byte[] out = new byte[bases.length];\n    int i;\n    for (i = 0; i <= lastIndex; i++) {\n        out[lastIndex - i] = complement(bases.getByte(i));\n    }\n    return new ByteSubarray(out, 0, out.length, bases.fillByte);\n}","918":"public TileDef getTileDef(String chr, int tile) {\n    ChromosomeIndex chrIdx = chrIndeces.get(chr);\n    if (chrIdx == null) {\n        return null;\n    } else {\n        return chrIdx.getTileDefinition(tile);\n    }\n}","919":"private static void addRawCounts(SparseAlignmentCounts result, SparseAlignmentCounts input) {\n    IntArrayList[] inputArrs = getCountArrs(input);\n    IntArrayList[] destArrs = getCountArrs(result);\n    IntArrayList destArr;\n    for (int arrayPos = 0; arrayPos < input.getNumberOfPoints(); arrayPos++) {\n        int genomePos = input.indices.get(arrayPos);\n        if (!result.indexMap.containsKey(genomePos)) {\n            for (int arnum = 0; arnum < destArrs.length; arnum++) {\n                destArr = destArrs[arnum];\n                destArr.add(inputArrs[arnum].get(arrayPos));\n            }\n            result.getIndex(genomePos);\n        }\n    }\n}","920":"public void dump() {\n    for (Map.Entry<Key, Map<Integer, Integer>> entry : counts.entrySet()) {\n        String modification = entry.getKey().toString();\n        Map<Integer, Integer> modCounts = entry.getValue();\n        System.out.println(\"Modification: \" + modification);\n        for (Map.Entry<Integer, Integer> modKey : modCounts.entrySet()) {\n            System.out.println(modKey.getKey() + \"  \" + modKey.getValue());\n        }\n    }\n}","921":"static String convertMotifToRegex(String motif) {\n    String output = motif;\n    int outloc = 0;\n    for (int inloc = 0; inloc < motif.length(); inloc++) {\n        String inchar = motif.substring(inloc, inloc + 1);\n        String rep = letterToRegex.get(inchar);\n        output = output.substring(0, outloc) + rep + motif.substring(inloc + 1);\n        outloc += rep.length();\n    }\n    return output;\n}","922":"public static void main(String[] args) {\n    try {\n        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n    } catch (Exception ex) {\n        ex.printStackTrace();\n    }\n    SwingUtilities.invokeLater(new Runnable() {\n\n        public void run() {\n            new RangeSliderDemo().display();\n        }\n    });\n}","923":"public void scrollByUnit(int direction) {\n    synchronized (slider) {\n        int delta = 1 * ((direction > 0) ? POSITIVE_SCROLL : NEGATIVE_SCROLL);\n        if (upperThumbSelected) {\n            int oldValue = ((RangeSlider) slider).getUpperValue();\n            ((RangeSlider) slider).setUpperValue(oldValue + delta);\n        } else {\n            int oldValue = slider.getValue();\n            slider.setValue(oldValue + delta);\n        }\n    }\n}","924":"public final <T> Collection<T> getOptionValues(Option<T> option) {\n    Collection<T> result = new ArrayList<T>();\n    while (true) {\n        T o = getOptionValue(option, null);\n        if (o == null) {\n            return result;\n        } else {\n            result.add(o);\n        }\n    }\n}","925":"\/**\n * Add a codec to the registry. If a codec that supports the same (format, version) (determined\n * by {@link HtsCodec#getFileFormat()} and {@link HtsCodec#getVersion()} methods) is already\n * registered, the new registry is updated to contain the new codec, and the previously registered\n * codec is returned.\n *\n * @param codec the codec to be added\n * @return a previously registered codec with the same (format, version), or null if no codec\n * was previously registered\n *\/\npublic synchronized HtsCodec<?, ?> registerCodec(final HtsCodec<?, ?> codec) {\n    switch(codec.getContentType()) {\n        case HAPLOID_REFERENCE:\n            return htsHaploidReferenceResolver.registerCodec((HaploidReferenceCodec) codec);\n        case ALIGNED_READS:\n            return htsReadsResolver.registerCodec((ReadsCodec) codec);\n        case VARIANT_CONTEXTS:\n            return htsVariantsResolver.registerCodec((VariantsCodec) codec);\n        case FEATURES:\n            throw new HtsjdkUnsupportedOperationException(\"Features codec type not yet implemented\");\n        default:\n            throw new HtsjdkPluginException(String.format(\"Unknown codec content type %s\", codec.getContentType()));\n    }\n}","926":"\/**\n * Add the primary resource to the bundle. The content type of resource will be the bundle's primary key.\n *\n * @param resource the resource which will be the primary resource for the bundle\n * @return this {@link BundleBuilder}\n *\/\npublic BundleBuilder addPrimary(final BundleResource resource) {\n    ValidationUtils.nonNull(resource, \"resource\");\n    if (primaryResource != null) {\n        throw new IllegalStateException(String.format(\"Can't add primary resource %s to a bundle that already has primary resource %s\", resource.getContentType(), primaryResource));\n    }\n    primaryResource = resource.getContentType();\n    addSecondary(resource);\n    return this;\n}","927":"protected void scanJar(final File file, final String packagePath) throws IOException {\n    final ZipFile zip = new ZipFile(file);\n    final Enumeration<? extends ZipEntry> entries = zip.entries();\n    while (entries.hasMoreElements()) {\n        final ZipEntry entry = entries.nextElement();\n        final String name = entry.getName();\n        if (name.startsWith(packagePath)) {\n            handleItem(name);\n        }\n    }\n}","928":"protected void scanDir(final File file, final String path) {\n    for (final File child : file.listFiles()) {\n        final String newPath = (path == null ? child.getName() : path + '\/' + child.getName());\n        if (child.isDirectory()) {\n            scanDir(child, newPath);\n        } else {\n            handleItem(newPath);\n        }\n    }\n}","929":"public static void printUsage() {\n    System.err.println(\"Usage: java -jar CountRecords.jar <inputFile>\");\n    System.err.println(\"    Where input can be of type: VCF (ends in .vcf or .VCF\");\n    System.err.println(\"                                Bed (ends in .bed or .bed\");\n    System.exit(1);\n}","930":"\/**\n * @param args 2 parameters, the paths of the two index files to compare\n *\/\npublic static void main(String[] args) {\n    if (args.length != 2)\n        printUsage();\n    else {\n        Index index1 = loadIndex(args[0]);\n        Index index2 = loadIndex(args[1]);\n        System.out.printf(\"%n\");\n        System.out.printf(\"index1: %s%n\", args[0]);\n        System.out.printf(\"index2: %s%n\", args[1]);\n        boolean eq = index1.equals(index2);\n        System.out.printf(\"  equals() = %b%n\", eq);\n    }\n}","931":"public static Index loadIndex(String filename) {\n    File file = new File(filename);\n    if (file.canRead()) {\n        return IndexFactory.loadIndex(file.getAbsolutePath());\n    } else {\n        printUsage();\n        return null;\n    }\n}","932":"public static <FEATURE_TYPE extends Feature> void convertToBinaryTest(final FeatureReader<FEATURE_TYPE> reader, final OutputStream out) throws IOException {\n    DataOutputStream dos = new DataOutputStream(out);\n    dos.writeBytes(HEADER_LINE + \"\\n\");\n    Iterator<FEATURE_TYPE> it = reader.iterator();\n    while (it.hasNext()) {\n        final Feature f = it.next();\n        dos.writeUTF(f.getContig());\n        dos.writeInt(f.getStart());\n        dos.writeInt(f.getEnd());\n    }\n    dos.close();\n    reader.close();\n}","933":"public static String appendToPath(String filepath, String indexExtension) {\n    String tabxIndex = null;\n    URL url = null;\n    try {\n        url = new URL(filepath);\n    } catch (MalformedURLException e) {\n    }\n    if (url != null) {\n        String path = url.getPath();\n        String indexPath = path + indexExtension;\n        tabxIndex = filepath.replace(path, indexPath);\n    } else {\n        tabxIndex = filepath + indexExtension;\n    }\n    return tabxIndex;\n}","934":"private void readFully(byte[] b) throws IOException {\n    int len = b.length;\n    if (len < 0)\n        throw new IndexOutOfBoundsException();\n    int n = 0;\n    while (n < len) {\n        int count = read(b, n, len - n);\n        if (count < 0)\n            throw new EOFException();\n        n += count;\n    }\n}","935":"public List<Interval> findOverlapping(Interval interval) {\n    if (root().isNull()) {\n        return Collections.emptyList();\n    }\n    List<Interval> results = new ArrayList<Interval>();\n    searchAll(interval, root(), results);\n    return results;\n}","936":"\/**\n * read the header\n *\n * @return a Object, representing the file header, if available\n * @throws IOException throws an IOException if we can't open the file\n *\/\nprivate void readHeader() throws IOException {\n    SOURCE source = null;\n    try {\n        source = codec.makeSourceFromStream(new PositionalBufferedStream(new BlockCompressedInputStream(SeekableStreamFactory.getInstance().getStreamFor(path, wrapper))));\n        header = codec.readHeader(source);\n    } catch (Exception e) {\n        throw new TribbleException.MalformedFeatureFile(\"Unable to parse header with error: \" + e.getMessage(), path, e);\n    } finally {\n        if (source != null) {\n            codec.close(source);\n        }\n    }\n}","937":"@Override\npublic void reset() throws IOException {\n    synchronized (lock) {\n        ensureOpen();\n        if (markedChar < 0)\n            throw new IOException((markedChar == INVALIDATED) ? \"Mark invalid\" : \"Stream not marked\");\n        nextChar = markedChar;\n        skipLF = markedSkipLF;\n    }\n}","938":"@Override\npublic Set<Gff3FeatureImpl> getDescendents() {\n    final List<Gff3FeatureImpl> descendants = new ArrayList<>(children);\n    final Set<String> idsInLineage = new HashSet<>(Collections.singleton(baseData.getId()));\n    idsInLineage.addAll(children.stream().map(Gff3Feature::getID).collect(Collectors.toSet()));\n    for (final Gff3FeatureImpl child : children) {\n        descendants.addAll(child.getDescendents(idsInLineage));\n    }\n    return new LinkedHashSet<>(descendants);\n}","939":"public void addCoFeature(final Gff3FeatureImpl coFeature) {\n    if (!parents.equals(coFeature.getParents())) {\n        throw new TribbleException(\"Co-features \" + baseData.getId() + \" do not have same parents\");\n    }\n    for (final Gff3FeatureImpl feature : coFeatures) {\n        feature.addCoFeatureShallow(coFeature);\n        coFeature.addCoFeatureShallow(feature);\n    }\n    addCoFeatureShallow(coFeature);\n    coFeature.addCoFeatureShallow(this);\n}","940":"public SAMSequenceDictionary getSequenceDictionary() {\n    final List<VCFContigHeaderLine> contigHeaderLines = this.getContigLines();\n    if (contigHeaderLines.isEmpty())\n        return null;\n    final List<SAMSequenceRecord> sequenceRecords = new ArrayList<SAMSequenceRecord>(contigHeaderLines.size());\n    for (final VCFContigHeaderLine contigHeaderLine : contigHeaderLines) {\n        final SAMSequenceRecord samSequenceRecord = contigHeaderLine.getSAMSequenceRecord();\n        sequenceRecords.add(samSequenceRecord);\n    }\n    return new SAMSequenceDictionary(sequenceRecords);\n}","941":"public List<VCFFilterHeaderLine> getFilterLines() {\n    final List<VCFFilterHeaderLine> filters = new ArrayList<VCFFilterHeaderLine>();\n    for (final VCFHeaderLine line : mMetaData) {\n        if (line instanceof VCFFilterHeaderLine) {\n            filters.add((VCFFilterHeaderLine) line);\n        }\n    }\n    return filters;\n}","942":"public List<VCFIDHeaderLine> getIDHeaderLines() {\n    final List<VCFIDHeaderLine> lines = new ArrayList<VCFIDHeaderLine>();\n    for (final VCFHeaderLine line : mMetaData) {\n        if (line instanceof VCFIDHeaderLine) {\n            lines.add((VCFIDHeaderLine) line);\n        }\n    }\n    return lines;\n}","943":"private void removeVCFVersionLines(final Set<VCFHeaderLine> headerLines) {\n    final List<VCFHeaderLine> toRemove = new ArrayList<VCFHeaderLine>();\n    for (final VCFHeaderLine line : headerLines) {\n        if (VCFHeaderVersion.isFormatString(line.getKey())) {\n            toRemove.add(line);\n        }\n    }\n    headerLines.removeAll(toRemove);\n}","944":"\/**\n * Returns a string of the form elt1.toString() [sep elt2.toString() ... sep elt.toString()] for a collection of\n * elti objects (note there's no actual space between sep and the elti elements).  Returns\n * \"\" if collection is empty.  If collection contains just elt, then returns elt.toString()\n *\n * @param separator the string to use to separate objects\n * @param objects a collection of objects.  the element order is defined by the iterator over objects\n * @param <T> the type of the objects\n * @return a non-null string\n *\/\npublic static <T> String join(final String separator, final Collection<T> objects) {\n    if (objects.isEmpty()) {\n        \/\/ fast path for empty collection\n        return \"\";\n    } else {\n        final Iterator<T> iter = objects.iterator();\n        final T first = iter.next();\n        if (\/\/ fast path for singleton collections\n        !iter.hasNext())\n            return first.toString();\n        else {\n            \/\/ full path for 2+ collection that actually need a join\n            final StringBuilder ret = new StringBuilder(first.toString());\n            while (iter.hasNext()) {\n                ret.append(separator);\n                ret.append(iter.next().toString());\n            }\n            return ret.toString();\n        }\n    }\n}","945":"public static <T> List<List<T>> makePermutations(final List<T> objects, final int n, final boolean withReplacement) {\n    final List<List<T>> combinations = new ArrayList<List<T>>();\n    if (n <= 0)\n        ;\n    else if (n == 1) {\n        for (final T o : objects) combinations.add(Collections.singletonList(o));\n    } else {\n        final List<List<T>> sub = makePermutations(objects, n - 1, withReplacement);\n        for (List<T> subI : sub) {\n            for (final T a : objects) {\n                if (withReplacement || !subI.contains(a))\n                    combinations.add(cons(a, subI));\n            }\n        }\n    }\n    return combinations;\n}","946":"public static synchronized List<Integer> getAlleles(final int PLindex, final int ploidy) {\n    if (PLindex < 0) {\n        throw new IllegalStateException(\"The PL index \" + PLindex + \" cannot be negative\");\n    }\n    if (ploidy <= 0) {\n        throw new IllegalStateException(\"The ploidy \" + ploidy + \" must be greater than zero\");\n    }\n    if (ploidy == 2) {\n        final GenotypeLikelihoodsAllelePair pair = getAllelePair(PLindex);\n        return Arrays.asList(pair.alleleIndex1, pair.alleleIndex2);\n    } else {\n        final PLIndexAllelesList plIndexAllelesList = anyploidPloidyToPLIndexAllelesList.computeIfAbsent(ploidy, k -> new PLIndexAllelesList(ploidy));\n        return plIndexAllelesList.getAlleles(PLindex);\n    }\n}","947":"@Deprecated\nstatic boolean wouldBeSymbolicAllele(byte[] bases) {\n    if (bases.length <= 1)\n        return false;\n    else {\n        return bases[0] == Allele.SYMBOLIC_ALLELE_START || bases[bases.length - 1] == Allele.SYMBOLIC_ALLELE_END || wouldBeBreakpoint(bases) || wouldBeSingleBreakend(bases);\n    }\n}","948":"@Deprecated\nstatic boolean wouldBeBreakpoint(byte[] bases) {\n    if (bases.length <= 1) {\n        return false;\n    }\n    for (final byte base : bases) {\n        if (base == Allele.BREAKEND_EXTENDING_LEFT || base == Allele.BREAKEND_EXTENDING_RIGHT) {\n            return true;\n        }\n    }\n    return false;\n}","949":"protected static <T extends Comparable<T>, V> String sortedString(Map<T, V> c) {\n    final List<T> t = new ArrayList<T>(c.keySet());\n    Collections.sort(t);\n    final List<String> pairs = new ArrayList<String>();\n    for (final T k : t) {\n        pairs.add(k + \"=\" + c.get(k));\n    }\n    return pairs.isEmpty() ? \"\" : \" {\" + ParsingUtils.join(\", \", pairs.toArray(new String[pairs.size()])) + \"}\";\n}","950":"protected final static String toStringIfExists(final String name, final int[] vs) {\n    if (vs == null)\n        return \"\";\n    else {\n        StringBuilder b = new StringBuilder();\n        b.append(' ').append(name).append(' ');\n        for (int i = 0; i < vs.length; i++) {\n            if (i != 0)\n                b.append(',');\n            b.append(vs[i]);\n        }\n        return b.toString();\n    }\n}","951":"private boolean evaluateExpression(final JexlVCMatchExp exp) {\n    if (this.jContext == null) {\n        jContext = createContext();\n    }\n    try {\n        final Boolean value = (Boolean) exp.exp.evaluate(jContext);\n        return value == null ? howToTreatMissingValues.getMissingValueOrExplode() : value;\n    } catch (final JexlException.Variable e) {\n        return howToTreatMissingValues.getMissingValueOrExplode();\n    } catch (final JexlException e) {\n        throw new IllegalArgumentException(String.format(\"Invalid JEXL expression detected for %s\", exp.name), e);\n    }\n}","952":"public final void reset(final boolean keepSampleName) {\n    if (!keepSampleName)\n        sampleName = null;\n    alleles = Collections.emptyList();\n    isPhased = false;\n    GQ = -1;\n    DP = -1;\n    AD = null;\n    PL = null;\n    filters = null;\n    extendedAttributes = null;\n}","953":"\/**\n * @return true if variantContext is to be kept, otherwise false\n * Assumes that this.sample is a sample in the variantContext, if not null,\n * otherwise looks for the first genotype (and assumes it exists).\n * @param variantContext the record to examine for GQ\n *\/\n@Override\npublic boolean test(final VariantContext variantContext) {\n    final Genotype gt = (sample == null) ? variantContext.getGenotype(0) : variantContext.getGenotype(sample);\n    if (gt == null) {\n        throw new IllegalArgumentException((sample == null) ? \"Cannot find any genotypes in VariantContext: \" + variantContext : \"Cannot find sample requested: \" + sample);\n    }\n    return gt.getGQ() >= gqThreshold;\n}","954":"private VariantContext getNextVC() {\n    while (iterator.hasNext()) {\n        final VariantContext record = iterator.next();\n        if (filter.test(record)) {\n            return record;\n        }\n    }\n    return null;\n}","955":"\/**\n * @return true if variantContext is to be kept, otherwise false\n * Assumes that this.sample is a sample in the variantContext, if not null,\n * otherwise looks for the first genotype (and assumes it exists).\n * @param variantContext the record to examine for heterozygosity\n *\/\n@Override\npublic boolean test(final VariantContext variantContext) {\n    final Genotype gt = (sample == null) ? variantContext.getGenotype(0) : variantContext.getGenotype(sample);\n    if (gt == null) {\n        throw new IllegalArgumentException((sample == null) ? \"Cannot find any genotypes in VariantContext: \" + variantContext : \"Cannot find sample requested: \" + sample);\n    }\n    \/\/XOR operator to reverse behaviour if keepHets is true.\n    return gt.isHet() ^ !keepHets;\n}","956":"\/**\n * Custom serialization routine. Needed to ensure that we decode any lazily-decoded data\n * before serialization.\n *\n * @param out stream to which to serialize this object\n *\/\nprivate void writeObject(ObjectOutputStream out) throws IOException {\n    \/\/ If we're a LazyGenotypesContext, decode the genotype data before serialization.\n    \/\/\n    \/\/ Ugly, but we can't do this in LazyGenotypesContext.writeObject(), since\n    \/\/ by the time that's called we'll already have serialized the superclass\n    \/\/ data in GenotypesContext, and we need to make sure that we decode any lazy\n    \/\/ data BEFORE serializing the fields in GenotypesContext.\n    if (getClass() == LazyGenotypesContext.class) {\n        ((LazyGenotypesContext) this).decode();\n    }\n    out.defaultWriteObject();\n}","957":"@Override\npublic boolean addAll(final Collection<? extends Genotype> genotypes) {\n    checkImmutability();\n    invalidateSampleOrdering();\n    if (sampleNameToOffset != null) {\n        int pos = size();\n        for (final Genotype g : genotypes) {\n            sampleNameToOffset.put(g.getSampleName(), pos++);\n        }\n    }\n    return getGenotypes().addAll(genotypes);\n}","958":"public int getMaxPloidy(final int defaultPloidy) {\n    if (defaultPloidy < 0)\n        throw new IllegalArgumentException(\"defaultPloidy must be greater than or equal to 0\");\n    if (maxPloidy == -1) {\n        maxPloidy = 0;\n        for (final Genotype g : getGenotypes()) {\n            maxPloidy = Math.max(g.getPloidy(), maxPloidy);\n        }\n        if (maxPloidy == 0)\n            maxPloidy = defaultPloidy;\n    }\n    return maxPloidy;\n}","959":"public GenotypesContext subsetToSamples(final Set<String> samples) {\n    final int nSamples = samples.size();\n    if (nSamples == 0)\n        return NO_GENOTYPES;\n    else {\n        final GenotypesContext subset = create(samples.size());\n        for (final String sample : samples) {\n            final Genotype g = get(sample);\n            if (g != null)\n                subset.add(g);\n        }\n        return subset;\n    }\n}","960":"public Type getType(final boolean ignoreNonRef) {\n    if (ignoreNonRef) {\n        if (typeIgnoringNonRef == null) {\n            typeIgnoringNonRef = determineType(ignoreNonRef);\n        }\n        return typeIgnoringNonRef;\n    } else {\n        if (type == null) {\n            type = determineType(ignoreNonRef);\n        }\n        return type;\n    }\n}","961":"public List<Integer> getIndelLengths() {\n    if (getType() != Type.INDEL && getType() != Type.MIXED) {\n        return null;\n    }\n    List<Integer> lengths = new ArrayList<>();\n    for (Allele a : getAlternateAlleles()) {\n        lengths.add(a.length() - getReference().length());\n    }\n    return lengths;\n}","962":"public void extraStrictValidation(final Allele reportedReference, final Allele observedReference, final Set<String> rsIDs) {\n    validateReferenceBases(reportedReference, observedReference);\n    validateRSIDs(rsIDs);\n    validateAlternateAlleles();\n    validateChromosomeCounts();\n}","963":"private void makeAttributesModifiable() {\n    if (!attributesCanBeModified) {\n        this.attributesCanBeModified = true;\n        final Map<String, Object> tempAttributes = attributes;\n        if (tempAttributes != null) {\n            this.attributes = new HashMap<>(tempAttributes);\n        } else {\n            this.attributes = new HashMap<>();\n        }\n    }\n}","964":"private void makeFiltersModifiable() {\n    if (!filtersCanBeModified) {\n        this.filtersCanBeModified = true;\n        final Set<String> tempFilters = filters;\n        this.filters = new LinkedHashSet<>();\n        if (tempFilters != null) {\n            this.filters.addAll(tempFilters);\n        }\n    }\n}","965":"@SuppressWarnings(\"unchecked\")\npublic List<Object> getAttributeAsList(String key) {\n    Object o = getAttribute(key);\n    if (o == null)\n        return Collections.emptyList();\n    if (o instanceof List)\n        return (List<Object>) o;\n    if (o.getClass().isArray()) {\n        if (o instanceof int[]) {\n            return Arrays.stream((int[]) o).boxed().collect(Collectors.toList());\n        } else if (o instanceof double[]) {\n            return Arrays.stream((double[]) o).boxed().collect(Collectors.toList());\n        }\n        return Arrays.asList((Object[]) o);\n    }\n    return Collections.singletonList(o);\n}","966":"\/**\n * Create a strings dictionary from the VCF header\n *\n * The dictionary is an ordered list of common VCF identifers (FILTER, INFO, and FORMAT)\n * fields.\n *\n * Note that its critical that the list be dedupped and sorted in a consistent manner each time,\n * as the BCF2 offsets are encoded relative to this dictionary, and if it isn't determined exactly\n * the same way as in the header each time it's very bad\n *\n * @param header the VCFHeader from which to build the dictionary\n * @return a non-null dictionary of elements, may be empty\n *\/\npublic static ArrayList<String> makeDictionary(final VCFHeader header) {\n    final Set<String> seen = new HashSet<String>();\n    final ArrayList<String> dict = new ArrayList<String>();\n    \/\/ special case the special PASS field which doesn't show up in the FILTER field definitions\n    seen.add(VCFConstants.PASSES_FILTERS_v4);\n    dict.add(VCFConstants.PASSES_FILTERS_v4);\n    \/\/ set up the strings dictionary\n    for (VCFHeaderLine line : header.getMetaDataInInputOrder()) {\n        if (line.shouldBeAddedToDictionary()) {\n            final VCFIDHeaderLine idLine = (VCFIDHeaderLine) line;\n            if (!seen.contains(idLine.getID())) {\n                dict.add(idLine.getID());\n                seen.add(idLine.getID());\n            }\n        }\n    }\n    return dict;\n}","967":"public static String collapseStringList(final List<String> strings) {\n    if (strings.isEmpty())\n        return \"\";\n    else if (strings.size() == 1)\n        return strings.get(0);\n    else {\n        final StringBuilder b = new StringBuilder();\n        for (final String s : strings) {\n            if (s != null) {\n                assert s.indexOf(\",\") == -1;\n                b.append(',').append(s);\n            }\n        }\n        return b.toString();\n    }\n}","968":"@Override\npublic int compareTo(final Bin other) {\n    if (other == null)\n        throw new ClassCastException(\"Cannot compare to a null object\");\n    if (this.referenceSequence != other.referenceSequence)\n        return referenceSequence - other.referenceSequence;\n    return binNumber - other.binNumber;\n}","969":"@Override\npublic void finish(final long dataFileLength) {\n    final SBIIndex.Header header = new SBIIndex.Header(dataFileLength, SBIIndexWriter.EMPTY_MD5, SBIIndexWriter.EMPTY_UUID, recordCount, granularity);\n    indexWriter.finish(header, finalVirtualOffset);\n}","970":"public List<Chunk> split(final long splitSize) {\n    if (splitSize <= 0) {\n        throw new IllegalArgumentException(String.format(\"Split size must be positive: %s\", splitSize));\n    }\n    final long fileSize = dataFileLength();\n    final List<Chunk> chunks = new ArrayList<>();\n    for (long splitStart = 0; splitStart < fileSize; splitStart += splitSize) {\n        final Chunk chunk = getChunk(splitStart, splitStart + splitSize);\n        if (chunk != null) {\n            chunks.add(chunk);\n        }\n    }\n    return chunks;\n}","971":"\/**\n * Ensure that the requested sequence is loaded.  Throws an exception if out-of-order\n * request is made, or if there is a mismatch between the requested name and the name\n * found in the ReferenceSequenceFile\n *\/\npublic ReferenceSequence get(final int sequenceIndex, final String sequenceName, final int length) {\n    \/\/ Has the side-effect of setting referenceSequence member\n    get(sequenceIndex);\n    if (!referenceSequence.getName().equals(sequenceName)) {\n        \/\/ Sanity check the sequence names against the sequence dictionary while scanning through.\n        throw new SAMException(\"Sequence name mismatch at sequence index (\" + referenceSequence.getContigIndex() + \", \" + referenceSequence.getName() + \") != \" + sequenceName);\n    }\n    if (referenceSequence.getBases().length != length) {\n        throw new SAMException(\"Sequence length mismatch for (\" + sequenceIndex + \", \" + sequenceName + \").  expected \" + length + \" but found \" + referenceSequence.getBases().length);\n    }\n    return referenceSequence;\n}","972":"@Override\npublic void close() throws IOException {\n    if (!closed) {\n        try {\n            closeSequence();\n            if (sequenceNames.isEmpty()) {\n                throw new IllegalStateException(\"no sequences were added to the reference\");\n            }\n        } finally {\n            closed = true;\n            fastaStream.close();\n            faiIndexWriter.close();\n            dictWriter.close();\n        }\n    }\n}","973":"\/**\n * Convert from a byte array containing =AaCcGgTtNnMmRrSsVvWwYyHhKkDdBb represented as ASCII, to a byte array half as long,\n * with for example, =, A, C, G, T converted to 0, 1, 2, 4, 8, 15.\n *\n * @param readBases Bases as ASCII bytes.\n * @return New byte array with bases represented as nybbles, in BAM binary format.\n *\/\nstatic byte[] bytesToCompressedBases(final byte[] readBases) {\n    final byte[] compressedBases = new byte[(readBases.length + 1) \/ 2];\n    int i;\n    for (i = 1; i < readBases.length; i += 2) {\n        compressedBases[i \/ 2] = (byte) (charToCompressedBaseHigh(readBases[i - 1]) | charToCompressedBaseLow(readBases[i]));\n    }\n    \/\/ Last nybble\n    if (i == readBases.length) {\n        compressedBases[i \/ 2] = charToCompressedBaseHigh(readBases[i - 1]);\n    }\n    return compressedBases;\n}","974":"public static void processValidationErrors(final List<SAMValidationError> validationErrors, final long samRecordIndex, final ValidationStringency validationStringency) {\n    if (validationErrors != null && !validationErrors.isEmpty()) {\n        for (final SAMValidationError validationError : validationErrors) {\n            validationError.setRecordNumber(samRecordIndex);\n        }\n        if (validationStringency == ValidationStringency.STRICT) {\n            throw new SAMFormatException(\"SAM validation error: \" + validationErrors.get(0));\n        } else if (validationStringency == ValidationStringency.LENIENT) {\n            for (final SAMValidationError error : validationErrors) {\n                System.err.println(\"Ignoring SAM validation error: \" + error);\n            }\n        }\n    }\n}","975":"public static int combineMapqs(int m1, int m2) {\n    if (m1 == 255) {\n        m1 = 1;\n    } else {\n        m1 *= 100;\n    }\n    if (m2 == 255) {\n        m2 = 1;\n    } else {\n        m2 *= 100;\n    }\n    return m1 + m2;\n}","976":"public Long getNoCoordinateCount() {\n    seek(4);\n    final int sequenceCount = readInteger();\n    skipToSequence(sequenceCount);\n    try {\n        return readLong();\n    } catch (final Exception e) {\n        return null;\n    }\n}","977":"public boolean isSameDictionary(final SAMSequenceDictionary that) {\n    if (that == null || that.mSequences == null)\n        return false;\n    if (this == that)\n        return true;\n    final Iterator<SAMSequenceRecord> thatSequences = that.mSequences.iterator();\n    for (final SAMSequenceRecord thisSequence : mSequences) {\n        if (!thatSequences.hasNext()) {\n            return false;\n        } else {\n            final SAMSequenceRecord thatSequence = thatSequences.next();\n            if (!thatSequence.isSameSequence(thisSequence)) {\n                return false;\n            }\n        }\n    }\n    return !thatSequences.hasNext();\n}","978":"public SAMSequenceRecord addSequenceAlias(final String originalName, final String altName) {\n    if (originalName == null)\n        throw new IllegalArgumentException(\"original name cannot be null\");\n    if (altName == null)\n        throw new IllegalArgumentException(\"alt name cannot be null\");\n    final SAMSequenceRecord originalSeqRecord = getSequence(originalName);\n    if (originalSeqRecord == null)\n        throw new IllegalArgumentException(\"Sequence \" + originalName + \" doesn't exist in dictionary.\");\n    if (originalName.equals(altName))\n        return originalSeqRecord;\n    final SAMSequenceRecord altSeqRecord = getSequence(altName);\n    if (altSeqRecord != null) {\n        if (altSeqRecord.equals(originalSeqRecord))\n            return originalSeqRecord;\n        throw new IllegalArgumentException(\"Alias \" + altName + \" for \" + originalSeqRecord + \" was already set to \" + altSeqRecord.getSequenceName());\n    }\n    mSequenceMap.put(altName, originalSeqRecord);\n    return originalSeqRecord;\n}","979":"public SamReader maybeOpen(URL url) {\n    if (urlPrefix.isEmpty() || !url.toString().toLowerCase().startsWith(urlPrefix)) {\n        return null;\n    }\n    LOG.info(\"Attempting to open \" + url + \" with custom factory\");\n    final ICustomReaderFactory factory = getFactory();\n    if (factory == null) {\n        return null;\n    }\n    return factory.open(url);\n}","980":"@Override\npublic int read(final byte[] buffer, int offset, int length) throws IOException {\n    final int originalLength = length;\n    while (length > 0) {\n        final int available = available();\n        if (available == 0) {\n            if (originalLength == length) {\n                return -1;\n            }\n            break;\n        }\n        final int copyLength = Math.min(length, available);\n        System.arraycopy(mCurrentBlock.mBlock, mCurrentOffset, buffer, offset, copyLength);\n        mCurrentOffset += copyLength;\n        offset += copyLength;\n        length -= copyLength;\n    }\n    return originalLength - length;\n}","981":"public long getFilePointer() {\n    if (mCurrentBlock == null) {\n        return BlockCompressedFilePointerUtil.makeFilePointer(0, 0);\n    }\n    if (mCurrentOffset > 0 && mCurrentOffset == mCurrentBlock.mBlock.length) {\n        return BlockCompressedFilePointerUtil.makeFilePointer(mCurrentBlock.mBlockAddress + mCurrentBlock.mBlockCompressedSize, 0);\n    }\n    return BlockCompressedFilePointerUtil.makeFilePointer(mCurrentBlock.mBlockAddress, mCurrentOffset);\n}","982":"public static boolean isValidFile(final InputStream stream) throws IOException {\n    if (!stream.markSupported()) {\n        throw new RuntimeException(\"Cannot test non-buffered stream\");\n    }\n    stream.mark(BlockCompressedStreamConstants.BLOCK_HEADER_LENGTH);\n    final byte[] buffer = new byte[BlockCompressedStreamConstants.BLOCK_HEADER_LENGTH];\n    final int count = readBytes(stream, buffer, 0, BlockCompressedStreamConstants.BLOCK_HEADER_LENGTH);\n    stream.reset();\n    return count == BlockCompressedStreamConstants.BLOCK_HEADER_LENGTH && isValidBlockHeader(buffer);\n}","983":"private void checkAndRethrowDecompressionException() throws IOException {\n    if (mCurrentBlock.mException != null) {\n        if (mCurrentBlock.mException instanceof IOException) {\n            throw (IOException) mCurrentBlock.mException;\n        } else if (mCurrentBlock.mException instanceof RuntimeException) {\n            throw (RuntimeException) mCurrentBlock.mException;\n        } else {\n            throw new RuntimeException(mCurrentBlock.mException);\n        }\n    }\n}","984":"static void readFully(SeekableByteChannel channel, ByteBuffer dst) throws IOException {\n    int totalBytesRead = 0;\n    final int capacity = dst.capacity();\n    while (totalBytesRead < capacity) {\n        final int bytesRead = channel.read(dst);\n        if (bytesRead == -1) {\n            throw new EOFException();\n        }\n        totalBytesRead += bytesRead;\n    }\n}","985":"public static void assertFileIsReadable(final Path path) {\n    if (path == null) {\n        throw new IllegalArgumentException(\"Cannot check readability of null file.\");\n    } else if (!Files.exists(path)) {\n        throw new SAMException(\"Cannot read non-existent file: \" + path.toUri().toString());\n    } else if (Files.isDirectory(path)) {\n        throw new SAMException(\"Cannot read file because it is a directory: \" + path.toUri().toString());\n    } else if (!Files.isReadable(path)) {\n        throw new SAMException(\"File exists but is not readable: \" + path.toUri().toString());\n    }\n}","986":"public static void assertDirectoryIsWritable(final Path dir) {\n    if (dir == null) {\n        throw new IllegalArgumentException(\"Cannot check readability of null file.\");\n    } else if (!Files.exists(dir)) {\n        throw new SAMException(\"Directory does not exist: \" + dir.toUri().toString());\n    } else if (!Files.isDirectory(dir)) {\n        throw new SAMException(\"Cannot write to directory because it is not a directory: \" + dir.toUri().toString());\n    } else if (!Files.isWritable(dir)) {\n        throw new SAMException(\"Directory exists but is not writable: \" + dir.toUri().toString());\n    }\n}","987":"public static void assertDirectoryIsReadable(final File dir) {\n    if (dir == null) {\n        throw new IllegalArgumentException(\"Cannot check readability of null file.\");\n    } else if (!dir.exists()) {\n        throw new SAMException(\"Directory does not exist: \" + dir.getAbsolutePath());\n    } else if (!dir.isDirectory()) {\n        throw new SAMException(\"Cannot read from directory because it is not a directory: \" + dir.getAbsolutePath());\n    } else if (!dir.canRead()) {\n        throw new SAMException(\"Directory exists but is not readable: \" + dir.getAbsolutePath());\n    }\n}","988":"public static InputStream openFileForReading(final Path path) {\n    try {\n        if (hasGzipFileExtension(path)) {\n            return openGzipFileForReading(path);\n        } else {\n            return Files.newInputStream(path);\n        }\n    } catch (IOException ioe) {\n        throw new SAMException(\"Error opening file: \" + path, ioe);\n    }\n}","989":"public static void copyFile(final File input, final File output) {\n    try {\n        final InputStream is = new FileInputStream(input);\n        final OutputStream os = new FileOutputStream(output);\n        copyStream(is, os);\n        os.close();\n        is.close();\n    } catch (IOException e) {\n        throw new SAMException(\"Error copying \" + input + \" to \" + output, e);\n    }\n}","990":"public static boolean deleteDirectoryTree(final File fileOrDirectory) {\n    boolean success = true;\n    if (fileOrDirectory.isDirectory()) {\n        for (final File child : fileOrDirectory.listFiles()) {\n            success = success && deleteDirectoryTree(child);\n        }\n    }\n    success = success && fileOrDirectory.delete();\n    return success;\n}","991":"public static long sizeOfTree(final File fileOrDirectory) {\n    long total = fileOrDirectory.length();\n    if (fileOrDirectory.isDirectory()) {\n        for (final File f : fileOrDirectory.listFiles()) {\n            total += sizeOfTree(f);\n        }\n    }\n    return total;\n}","992":"private static <T> BiFunction<Set<T>, Set<T>, Set<T>> mergeSetsAccountingForSingletons() {\n    return (newValue, oldValue) -> {\n        final Set<T> mutableSet = oldValue.size() == 1 ? new HashSet<>() : oldValue;\n        mutableSet.addAll(oldValue);\n        mutableSet.addAll(newValue);\n        return mutableSet;\n    };\n}","993":"public void addAll(final List<T> objects, final List<? extends Locatable> intervals) {\n    if (objects == null) {\n        throw new IllegalArgumentException(\"null objects\");\n    }\n    if (intervals == null) {\n        throw new IllegalArgumentException(\"null intervals\");\n    }\n    if (objects.size() != intervals.size()) {\n        throw new IllegalArgumentException(\"Objects and intervals must be the same size but were \" + objects.size() + \" and \" + intervals.size());\n    }\n    for (int i = 0; i < objects.size(); ++i) {\n        addLhs(objects.get(i), intervals.get(i));\n    }\n}","994":"public Set<T> getAll() {\n    final Set<T> all = new HashSet<>();\n    for (final IntervalTree<Set<T>> tree : this.cache.values()) {\n        for (IntervalTree.Node<Set<T>> node : tree) {\n            all.addAll(node.getValue());\n        }\n    }\n    return all;\n}","995":"public boolean containsContained(final Locatable key) {\n    final IntervalTree<T> tree = mSequenceMap.get(key.getContig());\n    if (tree == null)\n        return false;\n    final Iterator<IntervalTree.Node<T>> iterator = tree.overlappers(key.getStart(), key.getEnd());\n    while (iterator.hasNext()) {\n        final IntervalTree.Node<T> node = iterator.next();\n        if (node.getStart() >= key.getStart() && node.getEnd() <= key.getEnd()) {\n            return true;\n        }\n    }\n    return false;\n}","996":"private boolean ensureBufferNotEmpty() {\n    try {\n        if (nextByte < numBytes) {\n            return true;\n        }\n        nextByte = 0;\n        numBytes = in.read(fileBuffer);\n        atEof = (numBytes < 1);\n        return !atEof;\n    } catch (IOException e) {\n        throw new SAMException(\"Exception reading InputStream\", e);\n    }\n}","997":"public Node<V> min() {\n    Node<V> result = null;\n    Node<V> node = mRoot;\n    while (node != null) {\n        result = node;\n        node = node.getLeft();\n    }\n    return result;\n}","998":"public Node<V> max() {\n    Node<V> result = null;\n    Node<V> node = mRoot;\n    while (node != null) {\n        result = node;\n        node = node.getRight();\n    }\n    return result;\n}","999":"public Object parseObject(String value, Class<?> returnType) {\n    if (returnType == Short.class || returnType == Short.TYPE)\n        return parseShort(value);\n    if (returnType == Integer.class || returnType == Integer.TYPE)\n        return parseInt(value);\n    if (returnType == Long.class || returnType == Long.TYPE)\n        return parseLong(value);\n    if (returnType == Float.class || returnType == Float.TYPE)\n        return parseFloat(value);\n    if (returnType == Double.class || returnType == Double.TYPE)\n        return parseDouble(value);\n    if (returnType == Boolean.class || returnType == Boolean.TYPE)\n        return parseBoolean(value);\n    if (returnType == Byte.class || returnType == Byte.TYPE)\n        return parseInt(value);\n    if (returnType == Character.class || returnType == Character.TYPE)\n        return parseChar(value);\n    if (returnType == Iso8601Date.class)\n        return parseIso8601Date(value);\n    if (returnType == Date.class)\n        return parseDate(value);\n    if (returnType == File.class)\n        return new File(value);\n    if (Enum.class.isAssignableFrom(returnType))\n        return parseEnum(value, (Class<? extends Enum>) returnType);\n    if (returnType == String.class)\n        return value;\n    throw new InvalidParameterException(\"Don't know how to convert a String to a \" + returnType.getName());\n}","1000":"private void raiseBackgroundThreadException() throws Error {\n    Throwable t = currentBlock.getException();\n    if (t != null) {\n        if (t instanceof Error) {\n            throw (Error) t;\n        } else if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n        } else {\n            throw new RuntimeException(t);\n        }\n    }\n}","1001":"\/**\n * This function updates currentInterval according to the position of the record that it is\n * presented and determines if the current read is fully contained in the currentInterval.\n * @param rec The record we want to consider\n * @return True, if rec is fully contained in the current interval, otherwise false\n *\/\nprotected boolean advanceCurrentIntervalAndCheckIfIntervalContainsRead(final SAMRecord rec) {\n    \/\/ currentInterval should never be null when calling this method, but we have to check it just to make sure,\n    \/\/ so that we don't get a NullPointerException in the return statement.\n    if (currentInterval == null) {\n        return false;\n    }\n    \/\/ Here we need to update the currentInterval. We have to do this using an\n    \/\/ IntervalCoordinateComparator to take factor in the order in the sequence dictionary.\n    while (intervalListIterator.peek() != null && intervalCoordinateComparator.compare(new Interval(rec), intervalListIterator.peek()) > 0) {\n        currentInterval = intervalListIterator.next();\n    }\n    return currentInterval.contains(rec);\n}","1002":"public InputStream getDataStream() {\n    return new SequenceInputStream(new Enumeration<InputStream>() {\n\n        private final Iterator<Block> iterator = HtsgetResponse.this.blocks.iterator();\n\n        @Override\n        public boolean hasMoreElements() {\n            return this.iterator.hasNext();\n        }\n\n        @Override\n        public InputStream nextElement() {\n            return this.iterator.next().getData();\n        }\n    });\n}","1003":"public boolean hasNext() {\n    if (!doneAdding || cleanedUp) {\n        throw new IllegalStateException();\n    }\n    if (this.ramValues != null) {\n        return this.iterationIndex < numValuesInRam;\n    } else {\n        return !priorityQueue.isEmpty();\n    }\n}","1004":"public double getCumulativeProbability(final double v) {\n    double count = 0;\n    double total = 0;\n    for (final Bin<K> bin : values()) {\n        final double binValue = bin.getIdValue();\n        if (binValue <= v)\n            count += bin.getValue();\n        total += bin.getValue();\n    }\n    return count \/ total;\n}","1005":"public void trimByWidth(final int width) {\n    final Iterator<K> it = map.descendingKeySet().iterator();\n    while (it.hasNext()) {\n        if (((Number) it.next()).doubleValue() > width) {\n            it.remove();\n        } else\n            break;\n    }\n}","1006":"\/**\n * @return true if the mask is set for the given sequence and position\n *\/\n@Override\npublic boolean get(final int sequenceIndex, final int position) {\n    if (sequenceIndex < 0) {\n        throw new IllegalArgumentException(\"Negative sequence index \" + sequenceIndex);\n    }\n    if (sequenceIndex >= header.getSequenceDictionary().size()) {\n        return false;\n    }\n    final SAMSequenceRecord sequenceRecord = header.getSequence(sequenceIndex);\n    return position <= sequenceRecord.getSequenceLength();\n}","1007":"public InputStream wrapTempInputStream(final InputStream inputStream, final int bufferSize) {\n    InputStream is = IOUtil.maybeBufferInputStream(inputStream, bufferSize);\n    if (getSnappyLoader().isSnappyAvailable()) {\n        try {\n            return getSnappyLoader().wrapInputStream(is);\n        } catch (Exception e) {\n            throw new SAMException(\"Error creating SnappyInputStream\", e);\n        }\n    } else {\n        return is;\n    }\n}","1008":"public OutputStream wrapTempOutputStream(final OutputStream outputStream, final int bufferSize) {\n    OutputStream os = outputStream;\n    if (bufferSize > 0)\n        os = new BufferedOutputStream(os, bufferSize);\n    if (getSnappyLoader().isSnappyAvailable()) {\n        try {\n            os = getSnappyLoader().wrapOutputStream(os);\n        } catch (Exception e) {\n            throw new SAMException(\"Error creating SnappyOutputStream\", e);\n        }\n    }\n    return os;\n}","1009":"\/**\n * On the first call returns this object which is also an iterator.  On subsequent calls throws\n * an exception since new iterators cannot be generated.\n *\/\n@Override\npublic Iterator<T> iterator() {\n    if (iterated) {\n        throw new IllegalStateException(\"May not call iterator() more than once on IterableOnceIterator.\");\n    } else {\n        iterated = true;\n        return this;\n    }\n}","1010":"@Override\npublic int peek() {\n    try {\n        mark(2);\n        final int ret = read();\n        reset();\n        return ret;\n    } catch (IOException e) {\n        throw new RuntimeIOException(e);\n    }\n}","1011":"public static double sumOfErrorProbabilities(final SAMRecord rec) {\n    final byte[] bases = rec.getReadBases();\n    final byte[] quals = rec.getBaseQualities();\n    double sum = 0;\n    for (int i = 0; i < bases.length; ++i) {\n        if (SequenceUtil.isNoCall(bases[i]))\n            ++sum;\n        else\n            sum += QualityUtil.getErrorProbabilityFromPhredScore(quals[i]);\n    }\n    return sum;\n}","1012":"@Override\npublic void write(final byte[] bytes, int startIndex, int numBytes) throws IOException {\n    assert (numUncompressedBytes < uncompressedBuffer.length);\n    while (numBytes > 0) {\n        final int bytesToWrite = Math.min(uncompressedBuffer.length - numUncompressedBytes, numBytes);\n        System.arraycopy(bytes, startIndex, uncompressedBuffer, numUncompressedBytes, bytesToWrite);\n        numUncompressedBytes += bytesToWrite;\n        startIndex += bytesToWrite;\n        numBytes -= bytesToWrite;\n        assert (numBytes >= 0);\n        if (numUncompressedBytes == uncompressedBuffer.length) {\n            deflateBlock();\n        }\n    }\n}","1013":"\/**\n * Writes a single interval list.\n * @param interval the interval to write.\n *\/\npublic void write(final Interval interval) throws IOException {\n    out.write(interval.getContig());\n    out.write(TAB);\n    out.write(Integer.toString(interval.getStart()));\n    out.write(TAB);\n    out.write(Integer.toString(interval.getEnd()));\n    out.write(TAB);\n    out.write(interval.getStrand().encode());\n    out.write(TAB);\n    out.write(interval.getName() != null ? interval.getName() : \".\");\n    out.newLine();\n}","1014":"public void writeString(final String value, final boolean writeLength, final boolean appendNull) {\n    if (writeLength) {\n        int lengthToWrite = value.length();\n        if (appendNull)\n            lengthToWrite++;\n        writeInt(lengthToWrite);\n    }\n    writeString(value);\n    if (appendNull)\n        writeBytes(NULL_BYTE);\n}","1015":"public void writeUByte(final short val) {\n    if (val < 0) {\n        throw new IllegalArgumentException(\"Negative value (\" + val + \") passed to unsigned writing method.\");\n    }\n    if (val > MAX_UBYTE) {\n        throw new IllegalArgumentException(\"Value (\" + val + \") to large to be written as ubyte.\");\n    }\n    byteBuffer.clear();\n    byteBuffer.putShort(val);\n    writeByteBuffer(1);\n}","1016":"public void writeUShort(final int val) {\n    if (val < 0) {\n        throw new IllegalArgumentException(\"Negative value (\" + val + \") passed to unsigned writing method.\");\n    }\n    if (val > MAX_USHORT) {\n        throw new IllegalArgumentException(\"Value (\" + val + \") too large to be written as ushort.\");\n    }\n    byteBuffer.clear();\n    byteBuffer.putInt(val);\n    writeByteBuffer(2);\n}","1017":"public void writeUInt(final long val) {\n    if (val < 0) {\n        throw new IllegalArgumentException(\"Negative value (\" + val + \") passed to unsigned writing method.\");\n    }\n    if (val > MAX_UINT) {\n        throw new IllegalArgumentException(\"Value (\" + val + \") to large to be written as uint.\");\n    }\n    byteBuffer.clear();\n    byteBuffer.putLong(val);\n    writeByteBuffer(4);\n}","1018":"public String readString(final int length) {\n    final byte[] buffer;\n    if (length <= scratchBuffer.length) {\n        buffer = scratchBuffer;\n    } else {\n        buffer = new byte[length];\n    }\n    readBytes(buffer, 0, length);\n    return StringUtil.bytesToString(buffer, 0, length);\n}","1019":"public String readLengthAndString(final boolean devourNull) {\n    int length = readInt();\n    if (devourNull) {\n        --length;\n    }\n    final String ret = readString(length);\n    if (devourNull) {\n        readByte();\n    }\n    return ret;\n}","1020":"public boolean equalsWithStrandAndName(final Object other) {\n    if (!this.equals(other)) {\n        return false;\n    }\n    final Interval that = (Interval) other;\n    if (this.negativeStrand != that.negativeStrand) {\n        return false;\n    }\n    return this.name.equals(that.name);\n}","1021":"private DecompressedBlock nextBlockSync() {\n    ensureReadAhead();\n    DecompressedBlock nextBlock;\n    try {\n        nextBlock = mResult.take();\n    } catch (InterruptedException e) {\n        return new DecompressedBlock(0, 0, e);\n    }\n    ensureReadAhead();\n    return nextBlock;\n}","1022":"@Override\npublic void encode(final Interval interval) {\n    final String name = interval.getName();\n    binaryCodec.writeInt(dict.getSequenceIndex(interval.getContig()));\n    binaryCodec.writeInt(interval.getStart());\n    binaryCodec.writeInt(interval.getEnd());\n    binaryCodec.writeBoolean(interval.isNegativeStrand());\n    binaryCodec.writeBoolean(name != null);\n    if (name != null) {\n        binaryCodec.writeString(name, false, true);\n    }\n}","1023":"public static String wordWrap(final String s, final int maxLineLength) {\n    final String[] lines = s.split(\"\\n\");\n    final StringBuilder sb = new StringBuilder();\n    for (final String line : lines) {\n        if (sb.length() > 0) {\n            sb.append('\\n');\n        }\n        sb.append(wordWrapSingleLine(line, maxLineLength));\n    }\n    if (s.endsWith(\"\\n\")) {\n        sb.append('\\n');\n    }\n    return sb.toString();\n}","1024":"public static int regionToBin(final int beg, int end, final int minShift, final int binDepth) {\n    final int maxShift = minShift + 3 * (binDepth - 1);\n    int binWidth = minShift;\n    --end;\n    while (binWidth < maxShift) {\n        if (beg >> binWidth == end >> binWidth) {\n            return ((1 << (maxShift - binWidth)) - 1) \/ 7 + (beg >> binWidth);\n        }\n        binWidth += 3;\n    }\n    return 0;\n}","1025":"\/**\n * Return the {@link HuffmanTree} for the given alphabet symbol frequencies\n * @param symbolFrequencies\n * @param <T> type param of symbols int he alphabet\n * @return the {@link HuffmanTree} for the given alphabet symbol frequencies\n *\/\npublic static <T> HuffmanTree<T> buildTree(final HashMap<T, MutableInt> symbolFrequencies) {\n    ValidationUtils.nonNull(symbolFrequencies, \"non-null symbol frequencies required\");\n    ValidationUtils.nonNull(symbolFrequencies.size() > 0, \"non-zero symbol frequencies required\");\n    final LinkedList<HuffmanTree> list = new LinkedList<>();\n    symbolFrequencies.forEach((s, f) -> list.add(new HuffmanLeaf(s, f.value)));\n    while (list.size() > 1) {\n        Collections.sort(list);\n        final HuffmanTree left = list.remove();\n        final HuffmanTree right = list.remove();\n        list.add(new HuffmanNode(left, right));\n    }\n    return list.isEmpty() ? null : list.remove();\n}","1026":"public String getBitCodeWithPrefix() {\n    final String codeWordBinaryString = Integer.toBinaryString(codeWord);\n    final StringBuffer binaryWordBuffer = new StringBuffer();\n    for (int i = codeWordBinaryString.length(); i < codeWordBitLength; i++) {\n        binaryWordBuffer.append('0');\n    }\n    binaryWordBuffer.append(codeWordBinaryString);\n    return binaryWordBuffer.toString();\n}","1027":"public final long write(final BitOutputStream bitOutputStream, final T symbol) {\n    final HuffmanBitCode<T> code = huffmanBitCodesBySymbol.get(symbol);\n    if (code == null) {\n        throw new RuntimeException(String.format(\"Attempt to write a symbol (%d) that is not in the symbol alphabet for this huffman encoder (found code word %s).\", symbol, code == null ? \"null\" : code.toString()));\n    }\n    bitOutputStream.write(code.getCodeWord(), code.getCodeWordBitLength());\n    return code.getCodeWordBitLength();\n}","1028":"\/**\n * Populate a map with the HuffmanBitCode<T> for each symbol in the alphabet\n *\/\n@Override\npublic void getCodeWords(int codeWord, int codeWordLength, final Map<T, HuffmanBitCode<T>> symbolsToCodes) {\n    \/\/ traverse left\n    codeWord <<= 1;\n    codeWordLength++;\n    left.getCodeWords(codeWord, codeWordLength, symbolsToCodes);\n    \/\/ traverse right\n    codeWord = codeWord | 1;\n    right.getCodeWords(codeWord, codeWordLength, symbolsToCodes);\n}","1029":"public static CRAIEntry getLeftmost(final List<CRAIEntry> list) {\n    if (list == null || list.isEmpty()) {\n        return null;\n    }\n    return list.stream().sorted().findFirst().get();\n}","1030":"public final void write(final CRAMVersion cramVersion, final OutputStream outputStream) {\n    try {\n        if (cramVersion.getMajor() >= CramVersions.CRAM_v3.getMajor()) {\n            final CRC32OutputStream crc32OutputStream = new CRC32OutputStream(outputStream);\n            doWrite(crc32OutputStream);\n            outputStream.write(crc32OutputStream.getCrc32_LittleEndian());\n        } else {\n            doWrite(outputStream);\n        }\n    } catch (final IOException e) {\n        throw new RuntimeIOException(e);\n    }\n}","1031":"\/**\n * Create a ContainerHeader for a SAMFileHeader container.\n * @param containerBlocksByteSize size of the SAMFileHeader block to be embedded in this container\n *\/\npublic static ContainerHeader makeSAMFileHeaderContainer(final int containerBlocksByteSize) {\n    return new ContainerHeader(\/\/ we need to assign SOME alignment context for this bogus\/special header container...\n    AlignmentContext.UNMAPPED_UNPLACED_CONTEXT, \/\/ block count\n    1, containerBlocksByteSize, \/\/ record count\n    0, \/\/ global record count\n    0, \/\/ base count\n    0, \/\/ landmarks\n    Collections.emptyList(), \/\/ checksum\n    0);\n}","1032":"public void writeBlocks(final CRAMVersion cramVersion, final OutputStream outputStream) {\n    if (coreBlock == null) {\n        throw new IllegalArgumentException(\"A core block must be provided before slice blocks can be written to a CRAM stream\");\n    }\n    coreBlock.write(cramVersion, outputStream);\n    for (final Block block : externalBlocks.values()) {\n        block.write(cramVersion, outputStream);\n    }\n}","1033":"private void addExternalBlock(final Block externalBlock) {\n    ValidationUtils.validateArg(externalBlock.getContentType() == BlockContentType.EXTERNAL, \"Invalid external block\");\n    if (externalBlocks.containsKey(externalBlock.getContentId())) {\n        throw new CRAMException(String.format(\"Attempt to add a duplicate block (id %d of type %s) to compression header encoding map. \" + \"Existing block is of type %s.\", externalBlock.getContentId(), externalBlock.getContentType(), externalBlocks.get(externalBlock.getContentId()).getContentType()));\n    }\n    externalBlocks.put(externalBlock.getContentId(), externalBlock);\n}","1034":"public byte base(final byte refBase, final byte code) {\n    if (refBase <= 0) {\n        throw new IllegalArgumentException(String.format(\"CRAM: Attempt to generate a substitution code for invalid reference base '%c'\", (char) refBase));\n    }\n    final byte base = baseByCode[refBase][code];\n    if (base == NO_BASE) {\n        throw new IllegalArgumentException(String.format(\"CRAM: Attempt to retrieve a substitution base for invalid base '%c'\", (char) refBase));\n    }\n    return base;\n}","1035":"\/**\n * Creates a compression header for the provided list of {@link CRAMCompressionRecord} objects. Resets any internal\n * state (i.e. the tag encoding map state) as preparation for starting the next compression header.\n *\n * @param containerCRAMCompressionRecords all CRAMRecords that will be stored in the container\n * @param coordinateSorted\n *            if true the records are assumed to be sorted by alignment\n *            position\n * @return {@link htsjdk.samtools.cram.structure.CompressionHeader} for the container for {@code containerCRAMRecords}\n *\/\npublic CompressionHeader createCompressionHeader(final List<CRAMCompressionRecord> containerCRAMCompressionRecords, final boolean coordinateSorted) {\n    final CompressionHeader compressionHeader = new CompressionHeader(encodingMap, coordinateSorted, true, true);\n    compressionHeader.setTagIdDictionary(buildTagIdDictionary(containerCRAMCompressionRecords));\n    buildTagEncodings(containerCRAMCompressionRecords, compressionHeader);\n    final SubstitutionMatrix substitutionMatrix = new SubstitutionMatrix(containerCRAMCompressionRecords);\n    updateSubstitutionCodes(containerCRAMCompressionRecords, substitutionMatrix);\n    compressionHeader.setSubstitutionMatrix(substitutionMatrix);\n    \/\/reset the bestTagEncodings map state since there is no guarantee that the tag encodings accumulated\n    \/\/ for the current container will be appropriate for the tag value distributions in subsequent containers\n    bestTagEncodings.clear();\n    return compressionHeader;\n}","1036":"static void updateSubstitutionCodes(final List<CRAMCompressionRecord> cramCompressionRecords, final SubstitutionMatrix substitutionMatrix) {\n    for (final CRAMCompressionRecord record : cramCompressionRecords) {\n        if (record.getReadFeatures() != null) {\n            for (final ReadFeature recordFeature : record.getReadFeatures()) {\n                if (recordFeature.getOperator() == Substitution.operator) {\n                    final Substitution substitution = ((Substitution) recordFeature);\n                    if (substitution.getCode() == Substitution.NO_CODE) {\n                        final byte refBase = substitution.getReferenceBase();\n                        final byte base = substitution.getBase();\n                        substitution.setCode(substitutionMatrix.code(refBase, base));\n                    }\n                }\n            }\n        }\n    }\n}","1037":"static int getUnusedByte(final byte[] array) {\n    final byte[] usage = new byte[BYTE_SPACE_SIZE];\n    for (final byte b : array) {\n        usage[0xFF & b] = 1;\n    }\n    for (int i = 0; i < usage.length; i++) {\n        if (usage[i] == 0) {\n            return i;\n        }\n    }\n    return ALL_BYTES_USED;\n}","1038":"\/**\n * Write an end-of-file marker to the {@link OutputStream}. The specific EOF marker is chosen based on\n * the CRAM version. On read, this is interpreted as a special container sentinel indicating no more containers.\n *\n * The treatment of these EOF markers is asymmetric in that on read, the EOF marker is read in as a special\n * container with sentinel values indicating it is an EOF container (as defined by the spec).\n *\n * @param cramVersion      the CRAM version to assume\n * @param outputStream the stream to write to\n * @return the number of bytes written out\n *\/\npublic static long writeCramEOF(final CRAMVersion cramVersion, final OutputStream outputStream) {\n    try {\n        if (cramVersion.compatibleWith(CramVersions.CRAM_v3)) {\n            outputStream.write(ZERO_F_EOF_MARKER);\n            return ZERO_F_EOF_MARKER.length;\n        }\n        if (cramVersion.compatibleWith(CramVersions.CRAM_v2_1)) {\n            outputStream.write(ZERO_B_EOF_MARKER);\n            return ZERO_B_EOF_MARKER.length;\n        }\n    } catch (final IOException e) {\n        throw new RuntimeIOException(e);\n    }\n    throw new IllegalArgumentException(String.format(\"Unrecognized CRAM version %s\", cramVersion));\n}","1039":"public static long writeCramHeader(final CramHeader cramHeader, final OutputStream outputStream) {\n    try {\n        outputStream.write(CramHeader.MAGIC);\n        outputStream.write(cramHeader.getCRAMVersion().getMajor());\n        outputStream.write(cramHeader.getCRAMVersion().getMinor());\n        outputStream.write(cramHeader.getId());\n        for (int i = cramHeader.getId().length; i < CramHeader.CRAM_ID_LENGTH; i++) {\n            outputStream.write(0);\n        }\n        return CramHeader.CRAM_HEADER_LENGTH;\n    } catch (final IOException e) {\n        throw new RuntimeIOException(e);\n    }\n}","1040":"public void fetchReferenceBases(final int referenceIndex) {\n    ValidationUtils.validateArg(referenceIndex >= 0, \"reference index must be >= 0\");\n    if ((referenceIndex != this.referenceIndex) || regionStart != 0 || (regionLength < referenceBases.length)) {\n        setCurrentSequence(referenceIndex);\n        referenceBases = referenceSource.getReferenceBases(sequenceRecord, true);\n        if (referenceBases == null) {\n            throw new IllegalArgumentException(String.format(\"A reference must be supplied (reference sequence %s not found).\", sequenceRecord));\n        }\n        regionStart = 0;\n        regionLength = sequenceRecord.getSequenceLength();\n    }\n}","1041":"@Override\npublic void finish() {\n    try {\n        craiIndex.writeIndex(os);\n        os.flush();\n        os.close();\n    } catch (IOException e) {\n        throw new RuntimeIOException(\"Error writing CRAI index to output stream\");\n    }\n}","1042":"public void readFully(byte[] b) throws IOException {\n    int len = b.length;\n    if (len < 0) {\n        throw new IndexOutOfBoundsException();\n    }\n    int n = 0;\n    while (n < len) {\n        int count = read(b, n, len - n);\n        if (count < 0) {\n            throw new EOFException();\n        }\n        n += count;\n    }\n}","1043":"\/**\n * This method returns Reference objects by reference indexes in SAM header\n * Those objects do not maintain thread safety\n *\n * @param referenceIndex reference index in\n * @return a Reference object\n *\/\npublic Reference get(int referenceIndex) {\n    String contig = virtualHeader.getSequence(referenceIndex).getSequenceName();\n    try {\n        if (cachedReference == null || !cachedReference.getCanonicalName().equals(contig)) {\n            cachedReference = run.getReference(contig);\n        }\n    } catch (ErrorMsg e) {\n        throw new RuntimeException(e);\n    }\n    return cachedReference;\n}","1044":"@Override\npublic boolean equals(final Object o) {\n    if (o instanceof SRALazyRecord) {\n        SRALazyRecord otherRecord = (SRALazyRecord) o;\n        otherRecord.getReferenceIndex();\n        otherRecord.getAlignmentStart();\n    }\n    getReferenceIndex();\n    getAlignmentStart();\n    return super.equals(o);\n}","1045":"public static String positiveFourDigitBase36Str(int leftOver) {\n    if (leftOver == 0) {\n        return \"0\";\n    }\n    final StringBuilder builder = new StringBuilder(10);\n    while (leftOver > 0) {\n        final int valueIndex = leftOver % 36;\n        builder.append(INT_TO_BASE36[valueIndex]);\n        leftOver \/= 36;\n    }\n    return builder.reverse().toString();\n}","1046":"private SAMSequenceDictionary getSequenceDictionary(final Collection<SAMFileHeader> headers) {\n    SAMSequenceDictionary sequences = null;\n    for (final SAMFileHeader header : headers) {\n        if (sequences == null) {\n            sequences = header.getSequenceDictionary();\n        } else {\n            final SAMSequenceDictionary currentSequences = header.getSequenceDictionary();\n            SequenceUtil.assertSequenceDictionariesEqual(sequences, currentSequences);\n        }\n    }\n    return sequences;\n}","1047":"\/**\n * Basic sanity check for a pair of SAMRecords.\n * @throws SanityCheckFailedException if the sanity check failed\n *\/\npublic void assertPairValid(final SAMRecord firstEnd, final SAMRecord secondEnd) throws SanityCheckFailedException {\n    assertEquals(firstEnd.getReadName(), secondEnd.getReadName());\n    assertTrue(firstEnd.getFirstOfPairFlag());\n    assertTrue(secondEnd.getSecondOfPairFlag());\n    assertFalse(secondEnd.getFirstOfPairFlag());\n    assertFalse(firstEnd.getSecondOfPairFlag());\n    if (!firstEnd.getReadUnmappedFlag() && !secondEnd.getReadUnmappedFlag()) {\n        assertNotSame(firstEnd.getReadNegativeStrandFlag(), secondEnd.getReadNegativeStrandFlag());\n    }\n}","1048":"public SAMProgramRecord createProgramRecord() {\n    for (int i = 0; i < Integer.MAX_VALUE; ++i) {\n        final String s = Integer.toString(i);\n        if (!this.mProgramRecordMap.containsKey(s)) {\n            final SAMProgramRecord ret = new SAMProgramRecord(s);\n            addProgramRecord(ret);\n            return ret;\n        }\n    }\n    throw new IllegalStateException(\"Surprising number of SAMProgramRecords\");\n}","1049":"@Override\npublic void setAttribute(final String key, final String value) {\n    String tempVal = value;\n    if (key.equals(SORT_ORDER_TAG)) {\n        this.sortOrder = null;\n        try {\n            tempVal = SortOrder.valueOf(value).toString();\n        } catch (IllegalArgumentException e) {\n            tempVal = SortOrder.unknown.toString();\n        }\n    } else if (key.equals(GROUP_ORDER_TAG)) {\n        this.groupOrder = null;\n    }\n    super.setAttribute(key, tempVal);\n}","1050":"private static SAMSequenceRecord readSequenceRecord(final BinaryCodec stream, final String source) {\n    final int nameLength = stream.readInt();\n    if (nameLength <= 1) {\n        throw new SAMFormatException(\"Invalid BAM file header: missing sequence name in file \" + source);\n    }\n    final String sequenceName = stream.readString(nameLength - 1);\n    stream.readByte();\n    final int sequenceLength = stream.readInt();\n    return new SAMSequenceRecord(SAMSequenceRecord.truncateSequenceName(sequenceName), sequenceLength);\n}","1051":"public static BAMFileSpan getFileSpan(QueryInterval[] intervals, BAMIndex fileIndex) {\n    final BAMFileSpan[] inputSpans = new BAMFileSpan[intervals.length];\n    for (int i = 0; i < intervals.length; ++i) {\n        final QueryInterval interval = intervals[i];\n        final BAMFileSpan span = fileIndex.getSpanOverlapping(interval.referenceIndex, interval.start, interval.end);\n        inputSpans[i] = span;\n    }\n    final BAMFileSpan span;\n    if (inputSpans.length > 0) {\n        span = BAMFileSpan.merge(inputSpans);\n    } else {\n        span = null;\n    }\n    return span;\n}","1052":"\/**\n * Determines whether a SAMRecord matches this filter\n *\n * @param record the SAMRecord to evaluate\n *\n * @return true if the SAMRecord matches the filter, otherwise false\n *\/\n@Override\npublic boolean filterOut(final SAMRecord record) {\n    if (includeAligned) {\n        if (!record.getReadUnmappedFlag()) {\n            return false;\n        }\n    } else {\n        \/\/ exclude aligned\n        if (record.getReadUnmappedFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","1053":"@Override\npublic boolean filterOut(final SAMRecord first, final SAMRecord second) {\n    if (includeAligned) {\n        if (!first.getReadUnmappedFlag() && !second.getReadUnmappedFlag()) {\n            return false;\n        }\n    } else {\n        if (first.getReadUnmappedFlag() || second.getReadUnmappedFlag()) {\n            return false;\n        }\n    }\n    return true;\n}","1054":"\/**\n * Check if given SAMRecord violates sort order relative to previous SAMRecord.\n * @return True if sort order is unsorted, if this is the first record, or if previous <= rec.\n *\/\npublic boolean isSorted(final SAMRecord rec) {\n    if (comparator == null) {\n        return true;\n    }\n    boolean ret = true;\n    if (prev != null) {\n        ret = comparator.fileOrderCompare(prev, rec) <= 0;\n    }\n    prev = rec;\n    return ret;\n}","1055":"public String getSortKey(final SAMRecord rec) {\n    switch(sortOrder) {\n        case coordinate:\n            return rec.getReferenceName() + \":\" + rec.getAlignmentStart();\n        case queryname:\n            return rec.getReadName();\n        default:\n            return rec.getSAMString().trim();\n    }\n}","1056":"public static void reverseComplementSqArray(final byte[] sqArray) {\n    final int lastIndex = sqArray.length - 1;\n    int i, j;\n    for (i = 0, j = lastIndex; i < j; ++i, --j) {\n        final byte tmp = complementSqValue(sqArray[i]);\n        sqArray[i] = complementSqValue(sqArray[j]);\n        sqArray[j] = tmp;\n    }\n    if (sqArray.length % 2 == 1) {\n        sqArray[i] = complementSqValue(sqArray[i]);\n    }\n}","1057":"\/**\n * Convert from Cigar class representation to String.\n * @param cigar in Cigar class format\n * @return CIGAR in String form ala SAM text file.  \"*\" means empty CIGAR.\n *\/\npublic static String encode(final Cigar cigar) {\n    if (cigar.isEmpty()) {\n        return SAMRecord.NO_ALIGNMENT_CIGAR;\n    }\n    final StringBuilder ret = new StringBuilder();\n    for (final CigarElement cigarElement : cigar.getCigarElements()) {\n        ret.append(cigarElement.getLength());\n        ret.append(cigarElement.getOperator());\n    }\n    return ret.toString();\n}","1058":"@Override\npublic Long getNoCoordinateCount() {\n    if (metaDataPos > 0 && position() != metaDataPos) {\n        seek(metaDataPos);\n    }\n    skipToSequence(getNumberOfReferences());\n    try {\n        return readLong();\n    } catch (final Exception e) {\n        return null;\n    }\n}","1059":"public static int getReadLength(final List<CigarElement> cigarElements) {\n    int length = 0;\n    for (final CigarElement element : cigarElements) {\n        if (element.getOperator().consumesReadBases()) {\n            length += element.getLength();\n        }\n    }\n    return length;\n}","1060":"private static byte getPairedOrientationByte(final boolean read1NegativeStrand, final boolean read2NegativeStrand) {\n    if (read1NegativeStrand) {\n        if (read2NegativeStrand)\n            return SAMRecordDuplicateComparator.RR;\n        else\n            return SAMRecordDuplicateComparator.RF;\n    } else {\n        if (read2NegativeStrand)\n            return SAMRecordDuplicateComparator.FR;\n        else\n            return SAMRecordDuplicateComparator.FF;\n    }\n}","1061":"\/**\n * Force all the lazily-initialized attributes to be decoded.\n *\/\n@Override\nprotected void eagerDecode() {\n    getReadName();\n    getCigar();\n    getReadBases();\n    getBaseQualities();\n    getBinaryAttributes();\n    super.eagerDecode();\n    mRestOfBinaryData = null;\n}","1062":"@Override\npublic void clearAttributes() {\n    if (!mAttributesDecoded) {\n        getCigar();\n    }\n    mAttributesDecoded = true;\n    mBinaryDataStale = true;\n    super.clearAttributes();\n}","1063":"public SAMSequenceRecord setAlternativeSequenceName(final Collection<String> alternativeSequences) {\n    if (alternativeSequences == null) {\n        setAttribute(ALTERNATIVE_SEQUENCE_NAME_TAG, null);\n    } else {\n        encodeAltSequences(alternativeSequences);\n    }\n    return this;\n}","1064":"public List<String> getBarcodes() {\n    final String barcodeString = getAttribute(BARCODE_TAG);\n    if (barcodeString == null) {\n        return null;\n    } else if (barcodeString.isEmpty()) {\n        return Collections.emptyList();\n    } else {\n        return Arrays.asList(barcodeString.split(SamConstants.BARCODE_SEQUENCE_DELIMITER));\n    }\n}","1065":"public long[] toCoordinateArray() {\n    final int count = chunks.size() * 2;\n    if (count == 0) {\n        return null;\n    }\n    int index = 0;\n    final long[] result = new long[count];\n    for (final Chunk chunk : chunks) {\n        result[index++] = chunk.getChunkStart();\n        result[index++] = chunk.getChunkEnd();\n    }\n    return result;\n}","1066":"public long getFirstOffset() {\n    final long result = 0;\n    if (chunks == null) {\n        return result;\n    }\n    for (final Chunk chunk : chunks) {\n        return chunk.getChunkStart();\n    }\n    return result;\n}","1067":"\/**\n * @param val mapping quality value (ranged 0-250)\n * @return a score (as is performed by DRAGEN) corresponding to the phred likelihood of mipmapping event given that mapping quality.\n *\/\n@VisibleForTesting\npublic static double mapMappingQualityToPhredLikelihoodScore(final int val) {\n    for (int i = 1; i < mQTableX.length; i++) {\n        if (val <= mQTableX[i]) {\n            final double xfactor = 1.0 * (val - mQTableX[i - 1]) \/ (mQTableX[i] - mQTableX[i - 1]);\n            return mQTableY[i - 1] + (xfactor * (mQTableY[i] - mQTableY[i - 1]));\n        }\n    }\n    \/\/This is technically a failure state because the MQ is invalid if somehow it exceeds 256 by the SAMSpec....\n    throw new GATKException(\"Something went wrong trying to map an an invalid XQ tag '\" + val + \"' val must fall between 0 and 250\");\n}","1068":"public int getRightClipPoint(final byte[] quals) {\n    int clipSum = 0, lastMax = -1, clipPoint = -1;\n    final int readLength = quals.length;\n    for (int i = readLength - 1; i >= 0; i--) {\n        clipSum += (qTrimmingThreshold - quals[i]);\n        if (clipSum >= 0 && (clipSum >= lastMax)) {\n            lastMax = clipSum;\n            clipPoint = i;\n        }\n    }\n    return clipPoint;\n}","1069":"public int getLeftClipPoint(final byte[] quals) {\n    int clipSum = 0, lastMax = -1, clipPoint = -1;\n    final int readLength = quals.length;\n    for (int i = 0; i < readLength; i++) {\n        clipSum += (qTrimmingThreshold - quals[i]);\n        if (clipSum >= 0 && (clipSum >= lastMax)) {\n            lastMax = clipSum;\n            clipPoint = i;\n        }\n    }\n    return clipPoint;\n}","1070":"private static void setMinLogLoggingLevel(Log.LogLevel verbosity) {\n    switch(verbosity) {\n        case DEBUG:\n            com.esotericsoftware.minlog.Log.DEBUG();\n            break;\n        case INFO:\n            com.esotericsoftware.minlog.Log.INFO();\n            break;\n        case WARNING:\n            com.esotericsoftware.minlog.Log.WARN();\n            break;\n        case ERROR:\n            com.esotericsoftware.minlog.Log.ERROR();\n            break;\n        default:\n            throw new GATKException(\"This log level is not implemented properly: \" + verbosity);\n    }\n}","1071":"@Override\npublic boolean equals(final Object other) {\n    if (other == null) {\n        return false;\n    }\n    if (other instanceof GenomeLoc) {\n        final GenomeLoc otherGenomeLoc = (GenomeLoc) other;\n        return this.contigIndex == otherGenomeLoc.contigIndex && this.start == otherGenomeLoc.start && this.stop == otherGenomeLoc.stop;\n    }\n    return false;\n}","1072":"public static int secondSmallestMinusSmallest(final int[] values, final int defaultValue) {\n    Utils.nonNull(values);\n    if (values.length <= 1) {\n        return defaultValue;\n    } else {\n        int smallest = values[0];\n        int secondSmallest = Integer.MAX_VALUE;\n        for (int i = 1; i < values.length; i++) {\n            if (values[i] < smallest) {\n                secondSmallest = smallest;\n                smallest = values[i];\n            } else if (values[i] < secondSmallest) {\n                secondSmallest = values[i];\n            }\n        }\n        return secondSmallest - smallest;\n    }\n}","1073":"public static double approximateLog10SumLog10(final double[] vals, final int fromIndex, final int toIndex) {\n    Utils.nonNull(vals);\n    if (fromIndex == toIndex)\n        return Double.NEGATIVE_INFINITY;\n    final int maxElementIndex = MathUtils.maxElementIndex(vals, fromIndex, toIndex);\n    double approxSum = vals[maxElementIndex];\n    for (int i = fromIndex; i < toIndex; i++) {\n        final double val;\n        if (i == maxElementIndex || (val = vals[i]) == Double.NEGATIVE_INFINITY)\n            continue;\n        final double diff = approxSum - val;\n        if (diff < JacobianLogTable.MAX_TOLERANCE)\n            approxSum += JacobianLogTable.get(diff);\n    }\n    return approxSum;\n}","1074":"public static double log10BinomialProbability(final int n, final int k, final double log10p) {\n    Utils.validateArg(log10p < 1.0e-18, \"log10p: Log10-probability must be 0 or less\");\n    if (log10p == Double.NEGATIVE_INFINITY) {\n        return k == 0 ? 0 : Double.NEGATIVE_INFINITY;\n    } else if (log10p == 0) {\n        return k == n ? 0 : Double.NEGATIVE_INFINITY;\n    }\n    double log10OneMinusP = Math.log10(1 - Math.pow(10.0, log10p));\n    return log10BinomialCoefficient(n, k) + log10p * k + log10OneMinusP * (n - k);\n}","1075":"public static boolean allMatch(final double[] array, final DoublePredicate pred) {\n    Utils.nonNull(array);\n    Utils.nonNull(pred);\n    for (final double x : array) {\n        if (!pred.test(x)) {\n            return false;\n        }\n    }\n    return true;\n}","1076":"public static boolean allMatch(final int[] array, final IntPredicate pred) {\n    Utils.nonNull(array, \"array may not be null\");\n    Utils.nonNull(pred, \"predicate may not be null\");\n    for (final int x : array) {\n        if (!pred.test(x)) {\n            return false;\n        }\n    }\n    return true;\n}","1077":"public static int maxElementIndex(final int[] array) {\n    int maxIndex = 0;\n    int currentMax = Integer.MIN_VALUE;\n    for (int i = 0; i < array.length; i++) {\n        if (array[i] > currentMax) {\n            maxIndex = i;\n            currentMax = array[i];\n        }\n    }\n    return maxIndex;\n}","1078":"@Override\npublic boolean equals(final Object o) {\n    if (o == this) {\n        return true;\n    }\n    if (!(o instanceof IndexedSet<?>)) {\n        return false;\n    }\n    final IndexedSet<?> other = (IndexedSet<?>) o;\n    return equals(other);\n}","1079":"public static int getLegalSizeBelow(final long maxElements, final double loadFactor) {\n    final long augmentedSize = (long) (maxElements \/ loadFactor);\n    if (augmentedSize <= legalSizes[0]) {\n        throw new IllegalArgumentException(\"No legal sizes small enough for size \" + maxElements);\n    }\n    for (int i = 1; i < legalSizes.length; i++) {\n        if (augmentedSize <= legalSizes[i]) {\n            return legalSizes[i - 1];\n        }\n    }\n    return legalSizes[legalSizes.length - 1];\n}","1080":"private int findBestCutSite(final int endOfActiveRegion, final int minRegionSize) {\n    Utils.validateArg(endOfActiveRegion >= minRegionSize, \"endOfActiveRegion must be >= minRegionSize\");\n    Utils.validateArg(minRegionSize >= 0, \"minRegionSize must be >= 0\");\n    int minI = endOfActiveRegion - 1;\n    double minP = Double.MAX_VALUE;\n    for (int i = minI; i >= minRegionSize - 1; i--) {\n        double cur = getProb(i);\n        if (cur < minP && isMinimum(i)) {\n            minP = cur;\n            minI = i;\n        }\n    }\n    return minI + 1;\n}","1081":"private boolean isMinimum(final int index) {\n    Utils.validIndex(index, stateList.size());\n    if (index == stateList.size() - 1) {\n        return false;\n    } else if (index < 1) {\n        return false;\n    } else {\n        final double indexP = getProb(index);\n        return indexP <= getProb(index + 1) && indexP < getProb(index - 1);\n    }\n}","1082":"public static SAMSequenceDictionary loadFastaDictionary(final GATKPath fastaDictionaryFile) {\n    try (final InputStream fastaDictionaryStream = fastaDictionaryFile.getInputStream()) {\n        return loadFastaDictionary(fastaDictionaryStream);\n    } catch (IOException e) {\n        throw new UserException.CouldNotReadInputFile(\"Error loading fasta dictionary file \" + fastaDictionaryFile, e);\n    } catch (UserException.MalformedFile e) {\n        throw new UserException.MalformedFile(\"Could not read sequence dictionary from given fasta file \" + fastaDictionaryFile);\n    }\n}","1083":"public static SAMSequenceDictionary loadFastaDictionary(final InputStream fastaDictionaryStream) {\n    final BufferedLineReader reader = new BufferedLineReader(fastaDictionaryStream);\n    final SAMTextHeaderCodec codec = new SAMTextHeaderCodec();\n    final SAMFileHeader header = codec.decode(reader, fastaDictionaryStream.toString());\n    if (header.getSequenceDictionary() == null || header.getSequenceDictionary().isEmpty()) {\n        throw new UserException.MalformedFile(\"Could not read sequence dictionary from given fasta stream \" + fastaDictionaryStream);\n    }\n    return header.getSequenceDictionary();\n}","1084":"public SimpleInterval mergeWithContiguous(final Locatable that) {\n    Utils.nonNull(that);\n    if (!this.contiguous(that)) {\n        throw new GATKException(\"The two intervals need to be contiguous: \" + this + \" \" + that);\n    }\n    return new SimpleInterval(getContig(), Math.min(getStart(), that.getStart()), Math.max(getEnd(), that.getEnd()));\n}","1085":"public static Index loadIndex(final Path featureFile) {\n    Utils.nonNull(featureFile);\n    final Index tribbleIndex = loadTribbleIndex(featureFile);\n    if (tribbleIndex != null) {\n        return tribbleIndex;\n    }\n    final Index tabixIndex = loadTabixIndex(featureFile);\n    if (tabixIndex != null) {\n        return tabixIndex;\n    }\n    return null;\n}","1086":"public NioFileCopierWithProgressMeter setChecksumAlgorithmAndExpectedChecksum(final String algorithm, final String expectedChecksum) {\n    try {\n        this.messageDigest = MessageDigest.getInstance(algorithm);\n    } catch (final NoSuchAlgorithmException ex) {\n        throw new IllegalArgumentException(\"Provided checksum algorithm does not exist: \" + algorithm, ex);\n    }\n    this.expectedChecksum = expectedChecksum;\n    return this;\n}","1087":"public boolean equals(GATKReport report) {\n    if (!version.equals(report.version)) {\n        return false;\n    }\n    if (!tables.keySet().equals(report.tables.keySet())) {\n        return false;\n    }\n    for (String tableName : tables.keySet()) {\n        if (!getTable(tableName).equals(report.getTable(tableName)))\n            return false;\n    }\n    return true;\n}","1088":"private void expandTo(final int rowIndex, final boolean updateRowIdMap) {\n    int currentSize = underlyingData.size();\n    if (rowIndex >= currentSize) {\n        final int numNewRows = rowIndex - currentSize + 1;\n        for (int i = 0; i < numNewRows; i++) {\n            if (updateRowIdMap)\n                rowIdToIndex.put(currentSize, currentSize);\n            underlyingData.add(new Object[getNumColumns()]);\n            currentSize++;\n        }\n    }\n}","1089":"public void increment(final Object rowID, final String columnName) {\n    int prevValue;\n    if (!rowIdToIndex.containsKey(rowID)) {\n        rowIdToIndex.put(rowID, underlyingData.size());\n        underlyingData.add(new Object[getNumColumns()]);\n        prevValue = 0;\n    } else {\n        Object obj = get(rowID, columnName);\n        if (!(obj instanceof Integer))\n            throw new GATKException(\"Attempting to increment a value in a cell that is not an integer\");\n        prevValue = (Integer) obj;\n    }\n    set(rowIdToIndex.get(rowID), columnNameToIndex.get(columnName), prevValue + 1);\n}","1090":"public void concat(final GATKReportTable table) {\n    if (!isSameFormat(table))\n        throw new GATKException(\"Error trying to concatenate tables with different formats\");\n    underlyingData.addAll(table.underlyingData);\n    final int currentNumRows = getNumRows();\n    for (Map.Entry<Object, Integer> entry : table.rowIdToIndex.entrySet()) rowIdToIndex.put(entry.getKey(), entry.getValue() + currentNumRows);\n}","1091":"public boolean isSameFormat(final GATKReportTable table) {\n    if (!tableName.equals(table.tableName) || !tableDescription.equals(table.tableDescription) || columnInfo.size() != table.columnInfo.size())\n        return false;\n    for (int i = 0; i < columnInfo.size(); i++) {\n        if (!columnInfo.get(i).getFormat().equals(table.columnInfo.get(i).getFormat()) || !columnInfo.get(i).getColumnName().equals(table.columnInfo.get(i).getColumnName()))\n            return false;\n    }\n    return true;\n}","1092":"static public int extendedBaseToBaseIndex(byte base) {\n    switch(base) {\n        case 'd':\n        case 'D':\n            return Base.D.ordinal();\n        case 'n':\n        case 'N':\n            return Base.N.ordinal();\n        default:\n            return simpleBaseToBaseIndex(base);\n    }\n}","1093":"public static byte baseIndexToSimpleBase(final int baseIndex) {\n    switch(baseIndex) {\n        case 0:\n            return 'A';\n        case 1:\n            return 'C';\n        case 2:\n            return 'G';\n        case 3:\n            return 'T';\n        default:\n            return '.';\n    }\n}","1094":"public List<GATKRead> getArtificialReadsBasedOnSATag(SAMFileHeader header) {\n    List<GATKRead> output = new ArrayList<>(supplementaryReads.size());\n    GATKRead readCopy = read.copy();\n    readCopy.setAttribute(\"SA\", getTag());\n    SAMRecord record = readCopy.convertToSAMRecord(header);\n    List<SAMRecord> readRecords = SAMUtils.getOtherCanonicalAlignments(record);\n    for (SAMRecord artificialRead : readRecords) {\n        output.add(new SAMRecordToGATKReadAdapter(artificialRead));\n    }\n    return output;\n}","1095":"public List<Sample> getParents(final Sample offSpring) {\n    final List<Sample> parents = new ArrayList<>(2);\n    Sample parent = getMother(offSpring);\n    if (parent != null) {\n        parents.add(parent);\n    }\n    parent = getFather(offSpring);\n    if (parent != null) {\n        parents.add(parent);\n    }\n    return parents;\n}","1096":"public int countFamilyViolations(SampleDB sampleDB, Set<String> sampleIDs, VariantContext vc) {\n    resetCounts();\n    Map<String, Set<Sample>> families = sampleDB.getFamilies(sampleIDs);\n    for (final Set<Sample> family : families.values()) {\n        final Iterator<Sample> sampleIterator = family.iterator();\n        Sample sample;\n        while (sampleIterator.hasNext()) {\n            sample = sampleIterator.next();\n            if (!sampleDB.getParents(sample).isEmpty()) {\n                updateViolations(sample.getFamilyID(), sample.getMaternalID(), sample.getPaternalID(), sample.getID(), vc);\n            }\n        }\n    }\n    return violations_total;\n}","1097":"public SampleDBBuilder addSamplesFromSampleNames(final Collection<String> sampleNames) {\n    Utils.nonNull(sampleNames);\n    for (final String sampleName : sampleNames) {\n        if (sampleDB.getSample(sampleName) == null) {\n            final Sample newSample = new Sample(sampleName, null, null, null, Sex.UNKNOWN);\n            sampleDB.addSample(newSample);\n            samplesFromDataSources.add(newSample);\n        }\n    }\n    return this;\n}","1098":"\/**\n * Add a value to be stored in the histogram\n * @param d Data to be added to the histogram\n *\/\npublic void add(final Double d) {\n    if (d.isNaN()) {\n        return;\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","1099":"public void add(final Double d, final int count) {\n    if (count < 1) {\n        throw new GATKException(\"Cannot add non-positive counts to Histogram.\");\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey, count);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","1100":"\/**\n * Returns true iff we can make instances of this class.\n * Note that this will return false if the class does not have any public constructors.\n *\/\npublic static boolean canMakeInstances(final Class<?> clazz) {\n    return clazz != null && !clazz.isPrimitive() && !clazz.isSynthetic() && !clazz.isInterface() && !clazz.isLocalClass() && !Modifier.isPrivate(clazz.getModifiers()) && !Modifier.isAbstract(clazz.getModifiers()) && clazz.getConstructors().length != 0;\n}","1101":"public static List<Class<?>> getClassesOfType(final Class<?> targetClass, final List<Class<?>> classesToSearch) {\n    final List<Class<?>> classList = new ArrayList<>();\n    for (final Class<?> clazz : classesToSearch) {\n        if (targetClass.isAssignableFrom(clazz)) {\n            classList.add(clazz);\n        }\n    }\n    return classList;\n}","1102":"public static boolean equals(final SampleList first, final SampleList second) {\n    Utils.nonNull(first, \"first list is null\");\n    Utils.nonNull(second, \"second list is null\");\n    final int sampleCount = first.numberOfSamples();\n    if (sampleCount != second.numberOfSamples()) {\n        return false;\n    }\n    for (int i = 0; i < sampleCount; i++) {\n        final String firstSample = first.getSample(i);\n        final String secondSample = second.getSample(i);\n        if (!firstSample.equals(secondSample)) {\n            return false;\n        }\n    }\n    return true;\n}","1103":"default public List<String> asListOfSamples() {\n    return new AbstractList<String>() {\n\n        @Override\n        public String get(final int index) {\n            return SampleList.this.getSample(index);\n        }\n\n        @Override\n        public int size() {\n            return SampleList.this.numberOfSamples();\n        }\n    };\n}","1104":"default List<A> asListOfAlleles() {\n    return new AbstractList<A>() {\n\n        @Override\n        public A get(final int index) {\n            return AlleleList.this.getAllele(index);\n        }\n\n        @Override\n        public int size() {\n            return AlleleList.this.numberOfAlleles();\n        }\n    };\n}","1105":"public V remove(final SVInterval interval) {\n    V result = sentinel;\n    Node<V> node = root;\n    while (node != null) {\n        final int cmpVal = interval.compareTo(node.getInterval());\n        if (cmpVal == 0) {\n            result = node.getValue();\n            root = node.remove(root);\n            break;\n        }\n        node = cmpVal < 0 ? node.getLeft() : node.getRight();\n    }\n    return result;\n}","1106":"public Entry<V> find(final SVInterval interval) {\n    Node<V> node = root;\n    while (node != null) {\n        final int cmpVal = interval.compareTo(node.getInterval());\n        if (cmpVal == 0) {\n            break;\n        }\n        node = cmpVal < 0 ? node.getLeft() : node.getRight();\n    }\n    return node;\n}","1107":"public Entry<V> min() {\n    Node<V> result = null;\n    Node<V> node = root;\n    while (node != null) {\n        result = node;\n        node = node.getLeft();\n    }\n    return result;\n}","1108":"public Entry<V> max() {\n    Node<V> result = null;\n    Node<V> node = root;\n    while (node != null) {\n        result = node;\n        node = node.getRight();\n    }\n    return result;\n}","1109":"public synchronized void expandCache(final int newCapacity) {\n    if (newCapacity < cache.length) {\n        return;\n    }\n    final double[] newCache = new double[newCapacity + 1];\n    System.arraycopy(cache, 0, newCache, 0, cache.length);\n    for (int i = cache.length; i < newCache.length; i++) {\n        newCache[i] = compute(i);\n    }\n    cache = newCache;\n}","1110":"private static void prettyPrintWarningMessage(final List<String> results, final String message) {\n    for (final String line : message.split(\"\\\\r?\\\\n\")) {\n        final StringBuilder builder = new StringBuilder(line);\n        while (builder.length() > TEXT_WARNING_WIDTH) {\n            int space = getLastSpace(builder, TEXT_WARNING_WIDTH);\n            if (space <= 0) {\n                space = TEXT_WARNING_WIDTH;\n            }\n            results.add(String.format(\"%s%s\", TEXT_WARNING_PREFIX, builder.substring(0, space)));\n            builder.delete(0, space + 1);\n        }\n        results.add(String.format(\"%s%s\", TEXT_WARNING_PREFIX, builder));\n    }\n}","1111":"public static String join(final CharSequence separator, final Object... objects) {\n    Utils.nonNull(separator, \"the separator cannot be null\");\n    Utils.nonNull(objects, \"the value array cannot be null\");\n    if (objects.length == 0) {\n        return \"\";\n    } else {\n        final StringBuilder ret = new StringBuilder();\n        ret.append(objects[0]);\n        for (int i = 1; i < objects.length; i++) {\n            ret.append(separator).append(objects[i]);\n        }\n        return ret.toString();\n    }\n}","1112":"public static String join(final String separator, final int[] ints) {\n    Utils.nonNull(separator, \"the separator cannot be null\");\n    Utils.nonNull(ints, \"the ints cannot be null\");\n    if (ints.length == 0) {\n        return \"\";\n    } else {\n        final StringBuilder ret = new StringBuilder();\n        ret.append(ints[0]);\n        for (int i = 1; i < ints.length; ++i) {\n            ret.append(separator);\n            ret.append(ints[i]);\n        }\n        return ret.toString();\n    }\n}","1113":"public static String join(final String separator, final double[] doubles) {\n    Utils.nonNull(separator, \"the separator cannot be null\");\n    Utils.nonNull(doubles, \"the doubles cannot be null\");\n    if (doubles.length == 0) {\n        return \"\";\n    } else {\n        final StringBuilder ret = new StringBuilder();\n        ret.append(doubles[0]);\n        for (int i = 1; i < doubles.length; ++i) {\n            ret.append(separator);\n            ret.append(doubles[i]);\n        }\n        return ret.toString();\n    }\n}","1114":"public static List<Integer> asList(final int... values) {\n    Utils.nonNull(values, \"the input array cannot be null\");\n    return new AbstractList<Integer>() {\n\n        @Override\n        public Integer get(final int index) {\n            return values[index];\n        }\n\n        @Override\n        public int size() {\n            return values.length;\n        }\n    };\n}","1115":"public static List<Double> asList(final double... values) {\n    Utils.nonNull(values, \"the input array cannot be null\");\n    return new AbstractList<Double>() {\n\n        @Override\n        public Double get(final int index) {\n            return values[index];\n        }\n\n        @Override\n        public int size() {\n            return values.length;\n        }\n    };\n}","1116":"public static String[] escapeExpressions(final String args) {\n    Utils.nonNull(args);\n    if (args.indexOf('\\'') != -1) {\n        return escapeExpressions(args, \"'\");\n    } else if (args.indexOf('\\\"') != -1) {\n        return escapeExpressions(args, \"\\\"\");\n    } else {\n        return args.trim().split(\" +\");\n    }\n}","1117":"public static <T> List<List<T>> makePermutations(final List<T> objects, final int n, final boolean withReplacement) {\n    final List<List<T>> combinations = new ArrayList<>();\n    if (n == 1) {\n        for (final T o : objects) {\n            combinations.add(Collections.singletonList(o));\n        }\n    } else if (n > 1) {\n        final List<List<T>> sub = makePermutations(objects, n - 1, withReplacement);\n        for (final List<T> subI : sub) {\n            for (final T a : objects) {\n                if (withReplacement || !subI.contains(a)) {\n                    combinations.add(Utils.cons(a, subI));\n                }\n            }\n        }\n    }\n    return combinations;\n}","1118":"public static int lastIndexOf(final byte[] reference, final byte[] query) {\n    int queryLength = query.length;\n    for (int r = reference.length - queryLength; r >= 0; r--) {\n        int q = 0;\n        while (q < queryLength && reference[r + q] == query[q]) {\n            q++;\n        }\n        if (q == queryLength) {\n            return r;\n        }\n    }\n    return -1;\n}","1119":"public static List<String> split(final String str, final char delimiter) {\n    final List<String> tokens;\n    if (str.isEmpty()) {\n        tokens = new ArrayList<>(1);\n        tokens.add(\"\");\n    } else {\n        tokens = ParsingUtils.split(str, delimiter);\n        removeTrailingEmptyStringsFromEnd(tokens);\n    }\n    return tokens;\n}","1120":"public static <T> T runInParallel(final int threads, final Supplier<T> supplier) {\n    final ForkJoinPool threadPool = threads == 0 ? new ForkJoinPool() : new ForkJoinPool(threads);\n    try {\n        return threadPool.submit(supplier::get).get();\n    } catch (final InterruptedException e) {\n        throw new GATKException(\"task interrupted\", e);\n    } catch (final ExecutionException e) {\n        final Throwable cause = e.getCause();\n        if (cause instanceof RuntimeException) {\n            throw (RuntimeException) cause;\n        } else if (cause instanceof Error) {\n            throw (Error) cause;\n        } else {\n            throw new GATKException(\"exception when executing parallel task \", cause);\n        }\n    }\n}","1121":"public long sizeBeforeLoc(GenomeLoc loc) {\n    long s = 0;\n    for (GenomeLoc e : this) {\n        if (e.isBefore(loc))\n            s += e.size();\n        else if (e.isPast(loc))\n            break;\n        else\n            s += loc.getStart() - e.getStart();\n    }\n    return s;\n}","1122":"public double getEmpiricalErrorRate() {\n    if (numObservations == 0)\n        return 0.0;\n    else {\n        final double doubleMismatches = (numMismatches \/ MULTIPLIER) + SMOOTHING_CONSTANT;\n        final double doubleObservations = numObservations + SMOOTHING_CONSTANT + SMOOTHING_CONSTANT;\n        return doubleMismatches \/ doubleObservations;\n    }\n}","1123":"private void calcEmpiricalQuality(final double conditionalPrior) {\n    final long mismatches = (long) (getNumMismatches() + 0.5) + SMOOTHING_CONSTANT;\n    final long observations = getNumObservations() + SMOOTHING_CONSTANT + SMOOTHING_CONSTANT;\n    final double empiricalQual = RecalDatum.bayesianEstimateOfEmpiricalQuality(observations, mismatches, conditionalPrior);\n    empiricalQuality = Math.min(empiricalQual, (double) MAX_RECALIBRATED_Q_SCORE);\n}","1124":"\/**\n * Main method for computing the quantization intervals.\n *\n * Invoked in the constructor after all input variables are initialized.  Walks\n * over the inputs and builds the min. penalty forest of intervals with exactly nLevel\n * root nodes.  Finds this min. penalty forest via greedy search, so is not guarenteed\n * to find the optimal combination.\n *\n * TODO: develop a smarter algorithm\n *\n * @return the forest of intervals with size == nLevels\n *\/\nprivate TreeSet<QualInterval> quantize() {\n    \/\/ create intervals for each qual individually\n    final TreeSet<QualInterval> intervals = new TreeSet<>();\n    for (int qStart = 0; qStart < getNQualsInHistogram(); qStart++) {\n        final long nObs = nObservationsPerQual.get(qStart);\n        final double errorRate = QualityUtils.qualToErrorProb((byte) qStart);\n        final double nErrors = nObs * errorRate;\n        final QualInterval qi = new QualInterval(qStart, qStart, nObs, (int) Math.floor(nErrors), 0, (byte) qStart);\n        intervals.add(qi);\n    }\n    \/\/ greedy algorithm:\n    \/\/ while ( n intervals >= nLevels ):\n    \/\/   find intervals to merge with least penalty\n    \/\/   merge it\n    while (intervals.size() > nLevels) {\n        mergeLowestPenaltyIntervals(intervals);\n    }\n    return intervals;\n}","1125":"public static boolean loadLibraryFromClasspath(final String libraryPathInJar) {\n    Utils.nonNull(libraryPathInJar);\n    Utils.validateArg(libraryPathInJar.startsWith(\"\/\"), \"library path in jar must be absolute\");\n    try {\n        final File extractedLibrary = IOUtils.writeTempResourceFromPath(libraryPathInJar, NativeUtils.class);\n        extractedLibrary.deleteOnExit();\n        System.load(extractedLibrary.getAbsolutePath());\n    } catch (UnsatisfiedLinkError | UserException e) {\n        return false;\n    }\n    return true;\n}","1126":"@Override\nprotected final Map<String, String> getGroupMap(final DocWorkUnit docWorkUnit) {\n    final Map<String, String> root = super.getGroupMap(docWorkUnit);\n    root.put(\"supercat\", HelpConstants.getSuperCategoryProperty(docWorkUnit.getGroupName()));\n    return root;\n}","1127":"@Override\npublic DocWorkUnit createWorkUnit(final Element classElement, final Class<?> clazz, final DocumentedFeature documentedFeature) {\n    return includeInDocs(documentedFeature, clazz) ? new DocWorkUnit(new GATKWDLWorkUnitHandler(this), classElement, clazz, documentedFeature) : null;\n}","1128":"protected final void exportWorkUnitTemplate(final Configuration cfg, final DocWorkUnit workUnit, final String wdlTemplateName, final File wdlOutputPath) {\n    try {\n        final Template wdlTemplate = cfg.getTemplate(wdlTemplateName);\n        try (final Writer out = new OutputStreamWriter(new FileOutputStream(wdlOutputPath))) {\n            wdlTemplate.process(workUnit.getRootMap(), out);\n        }\n    } catch (IOException e) {\n        throw new DocException(\"IOException during documentation creation\", e);\n    } catch (TemplateException e) {\n        throw new DocException(\"TemplateException during documentation creation\", e);\n    }\n}","1129":"@Override\nprotected void addCustomBindings(final DocWorkUnit currentWorkUnit) {\n    super.addCustomBindings(currentWorkUnit);\n    Class<?> toolClass = currentWorkUnit.getClazz();\n    if (picard.cmdline.CommandLineProgram.class.isAssignableFrom(toolClass)) {\n        final CommandLineProgramProperties clpProperties = currentWorkUnit.getCommandLineProperties();\n        currentWorkUnit.setProperty(\"picardsummary\", clpProperties.summary());\n    }\n    currentWorkUnit.setProperty(\"buildDir\", ((GATKWDLDoclet) getDoclet()).getBuildDir());\n}","1130":"public double median(final double[] data) {\n    final int len = data.length;\n    final int mid = len \/ 2;\n    if (data.length % 2 == 0) {\n        return (data[mid] + data[mid - 1]) \/ 2d;\n    } else {\n        return data[mid];\n    }\n}","1131":"public static boolean sequenceRecordsAreEquivalent(final SAMSequenceRecord first, final SAMSequenceRecord second) {\n    if (first == second) {\n        return true;\n    }\n    if (first == null || second == null) {\n        return false;\n    }\n    final int length1 = first.getSequenceLength();\n    final int length2 = second.getSequenceLength();\n    if (length1 != length2 && length1 != SAMSequenceRecord.UNKNOWN_SEQUENCE_LENGTH && length2 != SAMSequenceRecord.UNKNOWN_SEQUENCE_LENGTH) {\n        return false;\n    }\n    if (!first.getSequenceName().equals(second.getSequenceName())) {\n        return false;\n    }\n    return true;\n}","1132":"public static String getDictionaryAsString(final SAMSequenceDictionary dict) {\n    Utils.nonNull(dict, \"Sequence dictionary must be non-null\");\n    StringBuilder s = new StringBuilder(\"[ \");\n    for (SAMSequenceRecord dictionaryEntry : dict.getSequences()) {\n        s.append(dictionaryEntry.getSequenceName());\n        s.append(\"(length:\");\n        s.append(dictionaryEntry.getSequenceLength());\n        s.append(\") \");\n    }\n    s.append(\"]\");\n    return s.toString();\n}","1133":"public List<Double> sample(final RandomGenerator rng, final Function<Double, Double> logPDF, final int numSamples, final int numBurnIn) {\n    Utils.nonNull(rng);\n    Utils.nonNull(logPDF);\n    ParamUtils.isPositive(numSamples, \"Number of samples must be positive.\");\n    ParamUtils.isPositiveOrZero(numBurnIn, \"Number of burn-in samples must be non-negative.\");\n    Utils.validateArg(numBurnIn < numSamples, \"Number of samples must be greater than number of burn-in samples.\");\n    final List<Double> samples = new ArrayList<>(numSamples);\n    for (int i = 0; i < numSamples; i++) {\n        xCurrent = sample(rng, logPDF);\n        if (i > numBurnIn) {\n            samples.add(xCurrent);\n        }\n    }\n    return samples;\n}","1134":"@Override\npublic void close() {\n    if (!closed) {\n        closed = true;\n        try {\n            FileUtils.deleteDirectory(dir);\n        } catch (final IOException e) {\n            throw new GATKException(\"issues closing the str-table-file at \" + dir, e);\n        }\n    }\n}","1135":"\/**\n * Provides a header line to the XSV output file. Note that this will throw an exception if all header lines\n * are not unique as it attempts to create an index for the provided header lines for convenience when building\n * rows of the XSV.\n *\n * NOTE: This can only be set once, XSV output files are expected to only have a single row as header.\n *\n * @param columns Ordered list of header lines to be built into the XSV\n *\/\npublic void setHeaderLine(List<String> columns) {\n    if (headerMap != null) {\n        throw new GATKException(\"Cannot modify header line once set\");\n    }\n    outputWriter.writeNext(columns.toArray(new String[0]), false);\n    expectedNumColumns = columns.size();\n    \/\/ Create the mapping between header and column\n    headerMap = new HashMap<>();\n    for (int i = 0; i < columns.size(); i++) {\n        Utils.nonNull(columns.get(i), \"Provided header had null column at position: \" + i);\n        if (headerMap.putIfAbsent(columns.get(i), i) != null) {\n            throw new GATKException(\"Column names must be unique, but found a duplicate name: \" + columns.get(i));\n        }\n    }\n}","1136":"\/**\n * Group the underlying readStatesByAlignmentStart into a list of list of alignment state machines,\n * where each list contains machines with a unique genome site.  The outer list is ordered\n * by alignment start.\n *\n * For example, if the flat list has alignment starts [10, 10, 11, 12, 12, 13] then\n * the resulting grouping will be [[10, 10], [11], [12, 12], [13]].\n *\n * @return a non-null list of lists\n *\/\nprivate List<LinkedList<AlignmentStateMachine>> groupByAlignmentStart() {\n    final LinkedList<LinkedList<AlignmentStateMachine>> grouped = new LinkedList<>();\n    AlignmentStateMachine last = null;\n    for (final AlignmentStateMachine stateMachine : readStatesByAlignmentStart) {\n        if (last == null || stateMachine.getGenomeOffset() != last.getGenomeOffset()) {\n            \/\/ we've advanced to a place where the state machine has a different state,\n            \/\/ so start a new list\n            grouped.add(new LinkedList<>());\n            last = stateMachine;\n        }\n        grouped.getLast().add(stateMachine);\n    }\n    return grouped;\n}","1137":"\/**\n * Converts the given {@link String} into a {@link Strand}.\n * @param s {@link String} to convert into a {@link Strand}.\n * @return The {@link Strand} corresponding to {@code s}.\n *\/\nprivate static Strand convertStringToStrand(final String s) {\n    if (s.equals(\"+\")) {\n        return Strand.POSITIVE;\n    } else if (s.equals(\"-\")) {\n        return Strand.NEGATIVE;\n    } else {\n        throw new IllegalArgumentException(\"Unexpected value: \" + s);\n    }\n}","1138":"public String serializeToString() {\n    final StringBuilder stringBuilder = new StringBuilder();\n    final List<GencodeGtfFeature> features = getAllFeatures();\n    Collections.sort(features);\n    for (final GencodeGtfFeature feature : features) {\n        stringBuilder.append(feature.serializeToStringHelper());\n        stringBuilder.append(\"\\n\");\n    }\n    return stringBuilder.toString().trim();\n}","1139":"private void setVersionNumber() {\n    try {\n        final Matcher versionMatcher = VERSION_PATTERN.matcher(header.get(0));\n        if (!versionMatcher.find()) {\n            throw new UserException.MalformedFile(\"Cannot find version number from Gencode GTF header.\");\n        }\n        versionNumber = Integer.valueOf(versionMatcher.group(1));\n    } catch (final NumberFormatException ex) {\n        throw new UserException(\"Could not read version number from header\", ex);\n    }\n}","1140":"private String[] splitGtfLine(final String line) {\n    final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n    if (splitLine.length != NUM_COLUMNS) {\n        throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \" + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n    }\n    return splitLine;\n}","1141":"boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText, final boolean throwIfInvalid) {\n    final boolean foundGoodLine = isLineCommented(header.get(lineNum), startingText);\n    if (!foundGoodLine) {\n        if (throwIfInvalid) {\n            throw new UserException.MalformedFile(getGtfFileType() + \" GTF Header line \" + (lineNum + 1) + \" does not contain expected information (\" + getDefaultLineComment() + startingText + \"): \" + header.get(lineNum));\n        } else {\n            return false;\n        }\n    }\n    return true;\n}","1142":"@Override\npublic boolean contains(Locatable that) {\n    if (exons.isEmpty()) {\n        return getLocation().contains(that);\n    }\n    for (SimpleInterval exon : exons) {\n        if (IntervalUtils.overlaps(exon, that)) {\n            return true;\n        }\n    }\n    return false;\n}","1143":"public static double phredSum(final double[] phreds) {\n    switch(phreds.length) {\n        case 0:\n            return Double.MAX_VALUE;\n        case 1:\n            return phreds[0];\n        case 2:\n            return phredSum(phreds[0], phreds[1]);\n        case 3:\n            return phredSum(phreds[0], phreds[1], phreds[2]);\n        default:\n            final double[] log10Vals = new double[phreds.length];\n            for (int i = 0; i < log10Vals.length; i++) {\n                log10Vals[i] = phreds[i] * -0.1;\n            }\n            return -10 * MathUtils.log10SumLog10(log10Vals);\n    }\n}","1144":"default <T> Optional<T> getOptionalTransientAttribute(final Object key, final Class<T> clazz) {\n    final Object value = getTransientAttribute(key);\n    if (value != null) {\n        if (clazz.isAssignableFrom(value.getClass())) {\n            return Optional.of(clazz.cast(value));\n        } else {\n            throw new IllegalArgumentException(\"transient attribute value type (\" + value.getClass().getName() + \") is not assignable to does not match the input class (\" + clazz.getName() + \")\");\n        }\n    } else {\n        return Optional.empty();\n    }\n}","1145":"public static Cigar removeClipsAndPadding(final Cigar cigar) {\n    Utils.nonNull(cigar, \"cigar is null\");\n    final List<CigarElement> elements = new ArrayList<>(cigar.numCigarElements());\n    for (final CigarElement ce : cigar.getCigarElements()) {\n        if (!isClipOrPaddingOperator(ce.getOperator())) {\n            elements.add(ce);\n        }\n    }\n    return new Cigar(elements);\n}","1146":"private static boolean hasConsecutiveIndels(final List<CigarElement> elems) {\n    boolean prevIndel = false;\n    for (final CigarElement elem : elems) {\n        final CigarOperator op = elem.getOperator();\n        final boolean isIndel = (op == CigarOperator.INSERTION || op == CigarOperator.DELETION);\n        if (prevIndel && isIndel) {\n            return true;\n        }\n        prevIndel = isIndel;\n    }\n    return false;\n}","1147":"public static Cigar revertSoftClips(final Cigar originalCigar) {\n    final CigarBuilder builder = new CigarBuilder();\n    for (final CigarElement element : originalCigar.getCigarElements()) {\n        if (element.getOperator() == CigarOperator.SOFT_CLIP) {\n            builder.add(new CigarElement(element.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n        } else {\n            builder.add(element);\n        }\n    }\n    return builder.make();\n}","1148":"private int compareCoordinates(final SAMRecord samRecord1, final SAMRecord samRecord2) {\n    final int refIndex1 = header.getSequenceIndex(samRecord1.getReferenceName());\n    final int refIndex2 = header.getSequenceIndex(samRecord2.getReferenceName());\n    if (refIndex1 == -1) {\n        return refIndex2 == -1 ? 0 : 1;\n    } else if (refIndex2 == -1) {\n        return -1;\n    }\n    final int cmp = refIndex1 - refIndex2;\n    if (cmp != 0) {\n        return cmp;\n    }\n    return samRecord1.getAlignmentStart() - samRecord2.getAlignmentStart();\n}","1149":"@VisibleForTesting\nstatic public byte[] baseArrayToKeySpace(final byte[] bases, final int keyLength, final byte[] baseSpacedArrayToConvert, final byte defaultQual, final String flowOrder) {\n    if (bases.length != baseSpacedArrayToConvert.length) {\n        throw new IllegalArgumentException(\"Read and qual arrays do not match\");\n    }\n    final byte[] result = new byte[keyLength];\n    final byte[] flowOrderBytes = flowOrder.getBytes();\n    int loc = 0;\n    int flowNumber = 0;\n    byte lastQual = defaultQual;\n    final int period = flowOrderBytes.length;\n    while (loc < bases.length) {\n        final byte flowBase = flowOrderBytes[flowNumber % period];\n        if ((bases[loc] != flowBase) && (bases[loc] != BaseUtils.Base.N.base)) {\n            result[flowNumber] = lastQual;\n        } else {\n            byte qual = Byte.MAX_VALUE;\n            while ((loc < bases.length) && ((bases[loc] == flowBase) || (bases[loc] == BaseUtils.Base.N.base))) {\n                qual = (byte) Math.min(baseSpacedArrayToConvert[loc], qual);\n                loc++;\n            }\n            result[flowNumber] = qual;\n            lastQual = qual;\n        }\n        flowNumber++;\n    }\n    return result;\n}","1150":"private NumPrimaryAlignmentState tallyPrimaryAlignments(final List<SAMRecord> records) {\n    boolean seenPrimary = false;\n    for (int i = 0; i < records.size(); ++i) {\n        if (records.get(i) != null && !records.get(i).isSecondaryOrSupplementary()) {\n            if (seenPrimary)\n                return NumPrimaryAlignmentState.MORE_THAN_ONE;\n            else\n                seenPrimary = true;\n        }\n    }\n    if (seenPrimary)\n        return NumPrimaryAlignmentState.ONE;\n    else\n        return NumPrimaryAlignmentState.NONE;\n}","1151":"@Override\nprotected boolean ignoreAlignment(final SAMRecord sam) {\n    if (maxGaps == -1)\n        return false;\n    int gaps = 0;\n    for (final CigarElement el : sam.getCigar().getCigarElements()) {\n        if (el.getOperator() == CigarOperator.I || el.getOperator() == CigarOperator.D) {\n            gaps++;\n        }\n    }\n    return gaps > maxGaps;\n}","1152":"private void randomlySelectPrimaryFromBest(List<SAMRecord> recs) {\n    if (recs.isEmpty())\n        return;\n    final int bestMapq = recs.get(0).getMappingQuality();\n    int i;\n    for (i = 1; i < recs.size() && recs.get(i).getMappingQuality() == bestMapq; ++i) {\n    }\n    final int bestIndex = random.nextInt(i);\n    if (bestIndex == 0)\n        return;\n    final SAMRecord tmp = recs.get(0);\n    recs.set(0, recs.get(bestIndex));\n    recs.set(bestIndex, tmp);\n}","1153":"public static SAMFileHeader createArtificialSamHeaderWithGroups(int numberOfChromosomes, int startingChromosome, int chromosomeSize, int groupCount) {\n    final SAMFileHeader header = createArtificialSamHeader(numberOfChromosomes, startingChromosome, chromosomeSize);\n    final List<SAMReadGroupRecord> readGroups = new ArrayList<>();\n    for (int i = 0; i < groupCount; i++) {\n        SAMReadGroupRecord rec = new SAMReadGroupRecord(DEFAULT_READ_GROUP_PREFIX + i);\n        rec.setSample(DEFAULT_SAMPLE_NAME);\n        readGroups.add(rec);\n    }\n    header.setReadGroups(readGroups);\n    for (int i = 0; i < groupCount; i++) {\n        final SAMReadGroupRecord groupRecord = header.getReadGroup(readGroups.get(i).getId());\n        groupRecord.setPlatform(DEFAULT_PLATFORM_PREFIX + ((i % 2) + 1));\n        groupRecord.setPlatformUnit(DEFAULT_PLATFORM_UNIT_PREFIX + ((i % 3) + 1));\n    }\n    return header;\n}","1154":"public static SAMFileHeader createArtificialSamHeaderWithPrograms(int numberOfChromosomes, int startingChromosome, int chromosomeSize, int programCount) {\n    final SAMFileHeader header = createArtificialSamHeader(numberOfChromosomes, startingChromosome, chromosomeSize);\n    final List<SAMProgramRecord> programRecords = new ArrayList<>();\n    for (int i = 0; i < programCount; i++) {\n        final SAMProgramRecord rec = new SAMProgramRecord(Integer.toString(i));\n        rec.setCommandLine(\"run \" + Integer.toString(i));\n        rec.setProgramVersion(\"1.0\");\n        if (i > 0) {\n            rec.setPreviousProgramGroupId(Integer.toString(i - 1));\n        }\n        rec.setProgramName(DEFAULT_PROGRAM_NAME + i);\n        programRecords.add(rec);\n    }\n    header.setProgramRecords(programRecords);\n    return header;\n}","1155":"public static String getLibraryName(final SAMFileHeader header, String readGroupId) {\n    if (readGroupId != null) {\n        final SAMReadGroupRecord rg = header.getReadGroup(readGroupId);\n        if (rg != null) {\n            final String libraryName = rg.getLibrary();\n            if (null != libraryName)\n                return libraryName;\n        }\n    }\n    return UNKNOWN_LIBRARY;\n}","1156":"public static List<Long> getAttributeAsLongList(final VariantContext variantContext, final String attribute, final Long defaultValue) {\n    Utils.nonNull(variantContext);\n    Utils.nonNull(attribute);\n    return variantContext.getAttributeAsList(attribute).stream().map(x -> {\n        if (x == null || x.equals(VCFConstants.MISSING_VALUE_v4)) {\n            return defaultValue;\n        } else if (x instanceof Number) {\n            return ((Number) x).longValue();\n        } else {\n            return Long.valueOf((String) x);\n        }\n    }).collect(Collectors.toList());\n}","1157":"public boolean isDbSnpSite(final String sequenceName, final int pos) {\n    if (sequenceToBitSet.get(sequenceName) == null) {\n        return false;\n    }\n    if (pos > sequenceToBitSet.get(sequenceName).length()) {\n        return false;\n    }\n    return sequenceToBitSet.get(sequenceName).get(pos);\n}","1158":"@Override\npublic void close() {\n    try {\n        gvcfBlockCombiner.signalEndOfInput();\n        output();\n    } finally {\n        underlyingWriter.close();\n    }\n}","1159":"public Locatable getVcfOutputEnd() {\n    final String contig = ((ReblockingGVCFBlockCombiner) gvcfBlockCombiner).getCurrentContig();\n    if (contig == null) {\n        return null;\n    }\n    final int position = ((ReblockingGVCFBlockCombiner) gvcfBlockCombiner).getVcfOutputEnd();\n    if (position == 0) {\n        return null;\n    }\n    return new SimpleInterval(contig, position, position);\n}","1160":"void initializePriors(final byte[] haplotypeBases, final byte[] readBases, final byte[] readQuals, final int startIndex) {\n    for (int i = 0; i < readBases.length; i++) {\n        final byte x = readBases[i];\n        final byte qual = readQuals[i];\n        for (int j = startIndex; j < haplotypeBases.length; j++) {\n            final byte y = haplotypeBases[j];\n            prior[i + 1][j + 1] = (x == y || x == (byte) 'N' || y == (byte) 'N' ? QualityUtils.qualToProb(qual) : (QualityUtils.qualToErrorProb(qual) \/ (doNotUseTristateCorrection ? 1.0 : TRISTATE_CORRECTION)));\n        }\n    }\n}","1161":"private void dumpMatrix(final String name, final double[][] matrix) {\n    System.out.printf(\"%s%n\", name);\n    for (int i = 0; i < matrix.length; i++) {\n        System.out.printf(\"\\t%s[%d]\", name, i);\n        for (int j = 0; j < matrix[i].length; j++) {\n            if (Double.isInfinite(matrix[i][j]))\n                System.out.printf(\" %15s\", String.format(\"%f\", matrix[i][j]));\n            else\n                System.out.printf(\" % 15.5e\", matrix[i][j]);\n        }\n        System.out.println();\n    }\n}","1162":"private void dumpMatrix(final String name, final double[][] matrix) {\n    System.out.printf(\"%s%n\", name);\n    for (int i = 0; i < matrix.length; i++) {\n        System.out.printf(\"\\t%s[%d]\", name, i);\n        for (int j = 0; j < matrix[i].length; j++) {\n            if (Double.isInfinite(matrix[i][j]))\n                System.out.printf(\" %15s\", String.format(\"%f\", matrix[i][j]));\n            else\n                System.out.printf(\" % 15.5e\", matrix[i][j]);\n        }\n        System.out.println();\n    }\n}","1163":"void initializePriors(final byte[] haplotypeBases, final byte[] haplotypePDBases, final byte[] readBases, final byte[] readQuals, final int startIndex) {\n    for (int i = 0; i < readBases.length; i++) {\n        final byte x = readBases[i];\n        final byte qual = readQuals[i];\n        for (int j = startIndex; j < haplotypeBases.length; j++) {\n            final byte y = haplotypeBases[j];\n            final byte hapPDBase = haplotypePDBases[j];\n            prior[i + 1][j + 1] = (x == y || x == (byte) 'N' || y == (byte) 'N' || isBasePDMatching(x, hapPDBase) ? QualityUtils.qualToProb(qual) : (QualityUtils.qualToErrorProb(qual) \/ (doNotUseTristateCorrection ? 1.0 : TRISTATE_CORRECTION)));\n        }\n    }\n}","1164":"@Override\npublic void initialize(final int readMaxLength, final int haplotypeMaxLength) {\n    super.initialize(readMaxLength, haplotypeMaxLength);\n    for (int i = 0; i < paddedMaxReadLength; i++) {\n        Arrays.fill(matchMatrix[i], Double.NEGATIVE_INFINITY);\n        Arrays.fill(insertionMatrix[i], Double.NEGATIVE_INFINITY);\n        Arrays.fill(deletionMatrix[i], Double.NEGATIVE_INFINITY);\n    }\n}","1165":"public void initializeLog10Priors(final byte[] haplotypeBases, final byte[] readBases, final byte[] readQuals, final int startIndex) {\n    for (int i = 0; i < readBases.length; i++) {\n        final byte x = readBases[i];\n        final byte qual = readQuals[i];\n        for (int j = startIndex; j < haplotypeBases.length; j++) {\n            final byte y = haplotypeBases[j];\n            prior[i + 1][j + 1] = (x == y || x == (byte) 'N' || y == (byte) 'N' ? QualityUtils.qualToProbLog10(qual) : (QualityUtils.qualToErrorProbLog10(qual) - (doNotUseTristateCorrection ? 0.0 : log10_3)));\n        }\n    }\n}","1166":"public String getDisplayMessage() {\n    if (isPositiveAck()) {\n        return ACK_LOG_MESSAGE;\n    } else if (hasMessage()) {\n        return String.format(\"%s: %s\", NCK_WITH_MESSAGE_LOG_MESSAGE, message);\n    } else {\n        return NCK_LOG_MESSAGE;\n    }\n}","1167":"public String getExceptionMessageFromScriptError(final ProcessOutput po) {\n    Utils.nonNull(po, \"process output cannot be null\");\n    final int exitValue = po.getExitValue();\n    final String commandLineMessage = String.format(\"\\n%s exited with %d\\nCommand Line: %s\", externalScriptExecutableName, exitValue, String.join(\" \", Utils.nonNull(commandLineArgs, \"command line args have not been set yet\")));\n    final boolean outputStdout = !logger.isDebugEnabled();\n    return commandLineMessage.concat(po.getStatusSummary(outputStdout));\n}","1168":"private void closeFIFOs() {\n    if (dataFIFOFile != null) {\n        dataFIFOFile.delete();\n    }\n    if (ackFIFOFile != null) {\n        ackFIFOFile.delete();\n    }\n    fifoTempDir.delete();\n}","1169":"@VisibleForTesting\nList<String> getConfigPathVariableNamesFromConfigClasses(final List<Class<?>> configurationClasses) {\n    final List<String> configPathVariableNames = new ArrayList<>();\n    for (final Class<?> clazz : ClassUtils.getClassesOfType(Config.class, configurationClasses)) {\n        @SuppressWarnings(\"unchecked\")\n        final Class<? extends Config> castedClass = (Class<? extends Config>) clazz;\n        configPathVariableNames.addAll(getSourcesAnnotationPathVariables(castedClass));\n    }\n    return configPathVariableNames;\n}","1170":"public synchronized <T extends Config> void initializeConfigurationsFromCommandLineArgs(final String[] argList, final String configFileOption, final Class<? extends T> configClass) {\n    Utils.nonNull(argList);\n    Utils.nonNull(configFileOption);\n    Utils.nonNull(configClass);\n    final String configFileName = getConfigFilenameFromArgs(argList, configFileOption);\n    final T configuration = getOrCreateConfigFromFile(configFileName, configClass);\n    injectSystemPropertiesFromConfig(configuration);\n}","1171":"@VisibleForTesting\nstatic <T extends Config> LinkedHashMap<String, String> getSystemPropertiesFromConfig(final T config) {\n    Utils.nonNull(config);\n    final LinkedHashMap<String, String> properties = new LinkedHashMap<>();\n    for (final Map.Entry<String, Object> entry : getConfigMap(config, true).entrySet()) {\n        properties.put(entry.getKey(), String.valueOf(entry.getValue()));\n    }\n    return properties;\n}","1172":"public static JavaRDD<GATKRead> querynameSortReadsIfNecessary(JavaRDD<GATKRead> reads, int numReducers, SAMFileHeader header) {\n    JavaRDD<GATKRead> sortedReadsForMarking;\n    if (ReadUtils.isReadNameGroupedBam(header)) {\n        sortedReadsForMarking = reads;\n    } else {\n        header.setSortOrder(SAMFileHeader.SortOrder.queryname);\n        sortedReadsForMarking = sortReadsAccordingToHeader(reads, header, numReducers);\n    }\n    return sortedReadsForMarking;\n}","1173":"@Override\npublic void write(final F feature) {\n    Utils.nonNull(feature);\n    if (indexCreator != null) {\n        indexCreator.addFeature(feature, locationAware.getPosition());\n    }\n    try {\n        outputStream.write((encoder.apply(feature) + NEWLINE_CHARACTER).getBytes());\n    } catch (final IOException e) {\n        throw new GATKException(\"Error writing record\", e);\n    }\n}","1174":"@Override\npublic void close() {\n    try {\n        outputStream.close();\n        if (indexCreator != null) {\n            final Index index = indexCreator.finalizeIndex(locationAware.getPosition());\n            index.writeBasedOnFeaturePath(featurePath);\n        }\n    } catch (final IOException e) {\n        throw new GATKException(\"Error closing output\", e);\n    }\n}","1175":"public static List<VariantShard> getVariantShardsFromInterval(final Locatable location) {\n    if (location.getContig() == null) {\n        throw new GATKException(\"getVariantShardsFromInterval requires locations to be mapped\");\n    }\n    List<VariantShard> shardList = new ArrayList<>();\n    int startShard = location.getStart() \/ VARIANT_SHARDSIZE;\n    int endShard = location.getEnd() \/ VARIANT_SHARDSIZE;\n    for (int i = startShard; i <= endShard; ++i) {\n        shardList.add(new VariantShard(i, location.getContig()));\n    }\n    return shardList;\n}","1176":"public AlignmentContext stratify(final ReadOrientation type) {\n    switch(type) {\n        case COMPLETE:\n            return this;\n        case FORWARD:\n            return new AlignmentContext(loc, basePileup.makeFilteredPileup(pe -> !pe.getRead().isReverseStrand()));\n        case REVERSE:\n            return new AlignmentContext(loc, basePileup.makeFilteredPileup(pe -> pe.getRead().isReverseStrand()));\n        default:\n            throw new IllegalArgumentException(\"Unable to get alignment context for type = \" + type);\n    }\n}","1177":"public Map<String, AlignmentContext> splitContextBySampleName(final String assumedSingleSample, final SAMFileHeader header) {\n    if (assumedSingleSample != null) {\n        return Collections.singletonMap(assumedSingleSample, this);\n    }\n    final Locatable loc = this.getLocation();\n    final Map<String, ReadPileup> pileups = this.getBasePileup().splitBySample(header, assumedSingleSample);\n    final Map<String, AlignmentContext> contexts = new LinkedHashMap<>(pileups.size());\n    for (final Map.Entry<String, ReadPileup> entry : pileups.entrySet()) {\n        if (entry.getValue().isEmpty()) {\n            continue;\n        }\n        contexts.put(entry.getKey(), new AlignmentContext(loc, entry.getValue()));\n    }\n    return contexts;\n}","1178":"private T loadNextNovelFeature() {\n    T candidateFeature;\n    do {\n        candidateFeature = loadNextFeature();\n        if (candidateFeature != null && featureIsNovel(candidateFeature)) {\n            return candidateFeature;\n        }\n    } while (candidateFeature != null);\n    return null;\n}","1179":"private T loadNextFeature() {\n    while (featuresInCurrentInterval == null || !featuresInCurrentInterval.hasNext()) {\n        if (!queryNextInterval()) {\n            return null;\n        }\n    }\n    return featuresInCurrentInterval.next();\n}","1180":"private ReferenceContext makeSpanningReferenceContext(final List<VariantContext> variantContexts, final int referenceWindowPadding) {\n    Utils.nonEmpty(variantContexts, \"Must have at least one current variant context\");\n    final List<String> contigs = variantContexts.stream().map(VariantContext::getContig).distinct().collect(Collectors.toList());\n    Utils.validate(contigs.size() == 1, \"variant contexts should all have the same contig\");\n    final int minStart = variantContexts.stream().mapToInt(VariantContext::getStart).min().getAsInt();\n    final int maxEnd = variantContexts.stream().mapToInt(VariantContext::getEnd).max().getAsInt();\n    final SimpleInterval combinedInterval = new SimpleInterval(contigs.get(0), minStart, maxEnd);\n    final ReferenceContext combinedReferenceContext = new ReferenceContext(reference, combinedInterval);\n    combinedReferenceContext.setWindow(referenceWindowPadding, referenceWindowPadding);\n    return combinedReferenceContext;\n}","1181":"private void afterTraverse() {\n    if (currentVariants.isEmpty()) {\n        logger.warn(\"Error: The requested interval contained no data in source VCF files\");\n    } else {\n        apply(currentVariants, currentReadsContexts);\n    }\n}","1182":"public void stop() {\n    if (disabled) {\n        return;\n    }\n    Utils.validate(started, \"the progress meter has not been started yet\");\n    Utils.validate(!stopped, \"the progress meter has been stopped already\");\n    this.stopped = true;\n    currentTimeMs = timeFunction.getAsLong();\n    printProgress();\n    logger.info(String.format(\"Traversal complete. Processed %d total %s in %.1f minutes.\", numRecordsProcessed, recordLabel, elapsedTimeInMinutes()));\n}","1183":"public void forEachRead(final GATKReadConsumer readHandler) {\n    if (passCount > 1) {\n        countedFilter = makeReadFilter();\n        resetReadsDataSource();\n        logger.info(String.format(\"Starting traversal pass %d\", passCount));\n    }\n    getTransformedReadStream(countedFilter).forEach(read -> {\n        final SimpleInterval readInterval = getReadInterval(read);\n        readHandler.consume(read, new ReferenceContext(reference, readInterval), new FeatureContext(features, readInterval));\n        progressMeter.update(readInterval);\n    });\n    logger.info(countedFilter.getSummaryLine());\n    passCount++;\n}","1184":"@Override\npublic void traverse() {\n    final CountingReadFilter readFilter = makeReadFilter();\n    for (final SimpleInterval locus : getIntervalIterator()) {\n        final SimpleInterval referenceWindow = getReferenceWindow(locus);\n        final ReferenceContext referenceContext = new ReferenceContext(reference, locus, referenceWindow);\n        apply(referenceContext, new ReadsContext(reads, referenceContext.getWindow(), readFilter), new FeatureContext(features, referenceContext.getWindow()));\n        progressMeter.update(referenceContext.getInterval());\n    }\n    ;\n}","1185":"@Override\npublic void traverse() {\n    final CountingVariantFilter countingVariantFilter = makeVariantFilter();\n    final CountingReadFilter readFilter = makeReadFilter();\n    for (int n = 0; n < numberOfPasses(); n++) {\n        logger.info(\"Starting pass \" + n + \" through the variants\");\n        final int nCopyInLambda = n;\n        traverseVariants(countingVariantFilter, readFilter, (vc, rc, ref, fc) -> nthPassApply(vc, rc, ref, fc, nCopyInLambda));\n        logger.info(\"Finished pass \" + n + \" through the variants\");\n        afterNthPass(n);\n    }\n    logger.info(countingVariantFilter.getSummaryLine());\n    logger.info(readFilter.getSummaryLine());\n}","1186":"private String makeIntoAbsolutePath() {\n    if (IOUtils.isGenomicsDBPath(this)) {\n        return IOUtils.getAbsolutePathWithGenomicsDBURIScheme(this);\n    } else if (getScheme() != null && !getScheme().equals(\"file\")) {\n        return toPath().toAbsolutePath().toUri().toString();\n    } else {\n        return getURI().getPath();\n    }\n}","1187":"public boolean cacheHit(final Locatable interval) {\n    final boolean cacheHit = cachedInterval != null && cachedInterval.contains(interval);\n    if (cacheHit) {\n        ++numCacheHits;\n    } else {\n        ++numCacheMisses;\n    }\n    return cacheHit;\n}","1188":"public void printCacheStatistics(final String sourceName) {\n    final String sourceNameString = sourceName.isEmpty() ? \"\" : \"for data source \" + sourceName;\n    final int totalQueries = getNumCacheHits() + getNumCacheMisses();\n    logger.debug(String.format(\"Cache hit rate %s was %.2f%% (%d out of %d total queries)\", sourceNameString, totalQueries > 0 ? ((double) getNumCacheHits() \/ totalQueries) * 100.0 : 0.0, getNumCacheHits(), totalQueries));\n}","1189":"@Override\npublic byte[] getBases(final SimpleInterval window) {\n    if (dataSource == null || window == null) {\n        return new byte[0];\n    }\n    final SimpleInterval trimmedWindow = new SimpleInterval(window.getContig(), trimToContigStart(window.getStart()), trimToContigLength(window.getContig(), window.getEnd()));\n    return dataSource.queryAndPrefetch(trimmedWindow).getBases();\n}","1190":"public byte[] getBases(final int windowLeadingBases, final int windowTrailingBases) {\n    if (dataSource == null || window == null) {\n        return new byte[0];\n    }\n    final SimpleInterval trimmedWindow = new SimpleInterval(window.getContig(), trimToContigStart(window.getStart() - windowLeadingBases), trimToContigLength(window.getContig(), window.getEnd() + windowTrailingBases));\n    return dataSource.queryAndPrefetch(trimmedWindow).getBases();\n}","1191":"public void setWindow(final int windowLeadingBases, final int windowTrailingBases) {\n    if (windowLeadingBases < 0) {\n        throw new GATKException(\"Reference window starts after the current interval\");\n    }\n    if (windowTrailingBases < 0) {\n        throw new GATKException(\"Reference window ends before the current interval\");\n    }\n    if (interval == null || (windowLeadingBases == 0 && windowTrailingBases == 0)) {\n        window = interval;\n    } else {\n        window = new SimpleInterval(interval.getContig(), calculateWindowStart(interval, windowLeadingBases), calculateWindowStop(interval, windowTrailingBases));\n    }\n    cachedSequence = null;\n}","1192":"public String getKmerAround(final int center, final int numBasesOnEachSide) {\n    Utils.validateArg(center >= 1, () -> \"start position must be positive\");\n    Utils.validateArg(window.getStart() <= center && center <= window.getEnd(), \"position must be smaller than end position\");\n    final SimpleInterval newWindow = new SimpleInterval(window.getContig(), center, center).expandWithinContig(numBasesOnEachSide, getContigLength(window.getContig()));\n    if (newWindow.getEnd() - newWindow.getStart() < 2 * numBasesOnEachSide) {\n        return null;\n    }\n    return new String(getBases(newWindow));\n}","1193":"@Override\nvoid initializeFeatures() {\n    features = new FeatureManager(this, 0, cloudPrefetchBuffer, cloudIndexPrefetchBuffer, getGenomicsDBOptions());\n    if (features.isEmpty()) {\n        features = null;\n    }\n}","1194":"\/**\n * Implementation of locus-based traversal.\n *\n * This implementation behaves similarly to {@link LocusWalker#traverse()} in that it iterates over all positions in the reference\n * covered by filtered and transformed reads including deletions only if {@link #includeDeletions()} returns {@code true}.\n *\n * This method also keeps track of interval objects provided by {@link #getIntervalObjectsToQueryOver()} and constructs a\n * global overlaps detector for all of the intervals which is used by the {@link #apply(AlignmentContext, ReferenceContext, FeatureContext)}\n * method to track which locatable still have active hooks. This method also makes sure to close out the list of previous intervals\n * when traversal has completed so that writers can be populated.\n *\/\n@Override\npublic void traverse() {\n    final CountingReadFilter countedFilter = makeReadFilter();\n    final Iterator<AlignmentContext> iterator = getAlignmentContextIterator(countedFilter);\n    intervalsToTrack = OverlapDetector.create(getIntervalObjectsToQueryOver());\n    \/\/ iterate over each alignment, and apply the function\n    iterator.forEachRemaining(alignmentContext -> {\n        final SimpleInterval alignmentInterval = new SimpleInterval(alignmentContext);\n        apply(alignmentContext, new ReferenceContext(reference, alignmentInterval), new FeatureContext(features, alignmentInterval));\n        progressMeter.update(alignmentInterval);\n    });\n    for (Locatable l : previousIntervals) {\n        onIntervalEnd(l);\n    }\n    logger.info(countedFilter.getSummaryLine());\n}","1195":"public static synchronized JavaSparkContext getTestSparkContext(Map<String, String> overridingProperties) {\n    if (testContextEnabled && testContext == null) {\n        testContext = createTestSparkContext(overridingProperties);\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n\n            @Override\n            public void run() {\n                testContext.stop();\n            }\n        });\n    }\n    return testContext;\n}","1196":"\/**\n * Prints the given message (may be null) to the provided stream, adding adornments and formatting.\n *\/\nprotected static void printDecoratedExceptionMessage(final PrintStream ps, final Exception e, String prefix) {\n    Utils.nonNull(ps, \"stream\");\n    Utils.nonNull(e, \"exception\");\n    ps.println(\"***********************************************************************\");\n    ps.println();\n    ps.println(prefix + e.getMessage());\n    ps.println();\n    ps.println(\"***********************************************************************\");\n}","1197":"protected void handleStorageException(final StorageException exception) {\n    System.err.println(\"code:      \" + exception.getCode());\n    System.err.println(\"message:   \" + exception.getMessage());\n    System.err.println(\"reason:    \" + exception.getReason());\n    System.err.println(\"location:  \" + exception.getLocation());\n    System.err.println(\"retryable: \" + exception.isRetryable());\n    exception.printStackTrace();\n}","1198":"public String getReferenceFileName() {\n    final GATKPath inputPathSpec = getReferenceSpecifier();\n    return inputPathSpec == null ? null : inputPathSpec.getURI().getPath();\n}","1199":"public List<SimpleInterval> getIntervalsWithoutMerging(final SAMSequenceDictionary sequenceDict) {\n    if (getIntervalStrings().isEmpty()) {\n        throw new GATKException(\"Cannot call getIntervalsWithoutMerging() without specifying intervals to include.\");\n    }\n    List<GenomeLoc> intervals = IntervalUtils.loadIntervalsNonMerging(getIntervalStrings(), intervalPadding, new GenomeLocParser(sequenceDict));\n    boolean traverseUnmapped = false;\n    if (intervals.contains(GenomeLoc.UNMAPPED)) {\n        traverseUnmapped = true;\n        intervals.remove(GenomeLoc.UNMAPPED);\n    }\n    return new TraversalParameters(IntervalUtils.convertGenomeLocsToSimpleIntervals(intervals), traverseUnmapped).getIntervalsForTraversal();\n}","1200":"public SAMFileWriter createSAMWriter(final File outputFile, final File referenceFile, final SAMFileHeader header, final boolean preSorted) {\n    BlockCompressedOutputStream.setDefaultCompressionLevel(COMPRESSION_LEVEL);\n    SAMFileWriterFactory factory = new SAMFileWriterFactory().setCreateIndex(CREATE_INDEX).setCreateMd5File(CREATE_MD5_FILE);\n    if (MAX_RECORDS_IN_RAM != null) {\n        factory = factory.setMaxRecordsInRam(MAX_RECORDS_IN_RAM);\n    }\n    return ReadUtils.createCommonSAMWriterFromFactory(factory, outputFile, referenceFile, header, preSorted);\n}","1201":"\/**\n * Entry point to run command line argument validation only.\n *\/\n@Override\npublic Object instanceMain(final String[] argv) {\n    if (targetCommandLineProgram instanceof PicardCommandLineProgramExecutor) {\n        return ((PicardCommandLineProgramExecutor) targetCommandLineProgram).validateArgs(argv);\n    } else {\n        \/\/ just call parseArgs and then return\n        return targetCommandLineProgram.parseArgs(argv);\n    }\n}","1202":"\/**\n * Build a {@link FuncotationFiltrationRule} matching Funcotations from variants with a\n * maximum MAF less than some threshold.\n *\n * @param maxMaf the MAF threshold to check in the rule. Must be in the range [0, 1]\n * @param afDataSource the allele frequency data source (ExAC or gnomAD) with which the original VCF was Funcotated.\n * @return a {@link FuncotationFiltrationRule} matching Funcotations with a MAF\n *         less than {@code maxMaf} across all sub-populations.\n *\/\npublic static FuncotationFiltrationRule buildMaxMafRule(final double maxMaf, final AlleleFrequencyDataSource afDataSource) {\n    ParamUtils.inRange(maxMaf, 0, 1, \"MAF must be between 0 and 1\");\n    if (afDataSource.equals(AlleleFrequencyDataSource.exac)) {\n        return (funcotations, variant) -> AlleleFrequencyExacUtils.getMaxMinorAlleleFreq(funcotations) <= maxMaf;\n    } else {\n        return (funcotations, variant) -> {\n            final Map<String, List<String>> condensedFuncotations = funcotations.stream().collect(Collectors.groupingBy(Map.Entry::getKey, Collectors.mapping(Map.Entry::getValue, Collectors.toList())));\n            return (!AlleleFrequencyGnomadUtils.allFrequenciesFiltered(condensedFuncotations) && AlleleFrequencyGnomadUtils.getMaxMinorAlleleFreq(condensedFuncotations) <= maxMaf);\n        };\n    }\n}","1203":"\/**\n * Generates an instance of {@link IntegerCopyNumberState} from a {@link DataLine} entry read from\n * a baseline copy-number file generated by `gcnvkernel`.\n *\/\nprivate static Function<DataLine, IntegerCopyNumberState> getBaselineCopyNumberRecordFromDataLineDecoder(final File inputFile) {\n    return dataLine -> {\n        try {\n            return new IntegerCopyNumberState(dataLine.getInt(GermlineCNVNamingConstants.BASELINE_COPY_NUMBER_TABLE_COLUMN));\n        } catch (final IllegalArgumentException ex) {\n            throw new UserException.BadInput(String.format(\"Error parsing baseline copy-number file (%s) at line %d.\", inputFile.getAbsolutePath(), dataLine.getLineNumber()));\n        }\n    };\n}","1204":"\/**\n * Generates a value from a {@link DataLine} entry read from a denoised copy\n * ratio file generated by `gcnvkernel`.\n *\/\nprivate static Function<DataLine, Double> getDoubleRecordFromDataLineDecoder() {\n    return dataLine -> {\n        try {\n            return dataLine.getDouble(defaultColumnName);\n        } catch (final IllegalArgumentException ex) {\n            throw new UserException.BadInput(String.format(\"Validation error occurred on line %d of the denoised copy ratio file : \", dataLine.getLineNumber()) + ex.getMessage());\n        }\n    };\n}","1205":"@Override\npublic void close() {\n    try {\n        writer.close();\n    } catch (final IOException e) {\n        throw new UserException.CouldNotCreateOutputFile(\"Could not close file writing.\", e);\n    }\n}","1206":"@Override\npublic void add(final AnnotatedInterval annotatedInterval) {\n    if (!hasHeaderBeenWritten) {\n        throw new GATKException.ShouldNeverReachHereException(\"This is an invalid code path, since the header of the output file should already be written.  Please post this error to the GATK forum (https:\/\/gatkforums.broadinstitute.org\/gatk)\");\n    }\n    try {\n        writer.writeRecord(annotatedInterval);\n    } catch (IOException e) {\n        throw new UserException.CouldNotCreateOutputFile(\"Could not write to file.\", e);\n    }\n}","1207":"private double[] calculateCorrectionFactors(final List<List<Double>> readCountsByGC) {\n    final RealVector medians = new ArrayRealVector(readCountsByGC.stream().mapToDouble(GCBiasCorrector::medianOrDefault).toArray());\n    return IntStream.range(0, NUMBER_OF_GC_BINS).mapToDouble(bin -> {\n        final RealVector weights = new ArrayRealVector(IntStream.range(0, NUMBER_OF_GC_BINS).mapToDouble(n -> readCountsByGC.get(n).size() * Math.exp(-Math.abs(bin - n) * correlationDecayRatePerBin)).toArray());\n        return weights.dotProduct(medians) \/ weights.getL1Norm();\n    }).map(x -> 1 \/ x).toArray();\n}","1208":"private void initializeSampleDBAndSetFounders(GATKPath pedigreeFile) {\n    final SampleDBBuilder sampleDBBuilder = new SampleDBBuilder(PedigreeValidationType.STRICT);\n    sampleDBBuilder.addSamplesFromPedigreeFiles(Collections.singletonList(pedigreeFile));\n    Set<String> founderIdsToAdd = sampleDBBuilder.getFinalSampleDB().getFounderIds();\n    if (this.founderIds == null || this.founderIds.isEmpty()) {\n        this.founderIds = founderIdsToAdd;\n    } else {\n        this.founderIds.addAll(founderIdsToAdd);\n    }\n    hasAddedPedigreeFounders = true;\n}","1209":"@Override\npublic double cumulativeProbability(int k) {\n    ParamUtils.isPositiveOrZero(k, \"Number of successes must be greater than or equal to zero.\");\n    double result = 0.0;\n    for (int i = 0; i <= k; i++) {\n        result += probability(i);\n    }\n    return result;\n}","1210":"static Collection<Kmer> determineNonUniqueKmers(final SequenceForKmers seqForKmers, final int kmerSize) {\n    final Set<Kmer> allKmers = new LinkedHashSet<>();\n    final List<Kmer> nonUniqueKmers = new ArrayList<>();\n    final int stopPosition = seqForKmers.stop - kmerSize;\n    for (int i = 0; i <= stopPosition; i++) {\n        final Kmer kmer = new Kmer(seqForKmers.sequence, i, kmerSize);\n        if (!allKmers.add(kmer)) {\n            nonUniqueKmers.add(kmer);\n        }\n    }\n    return nonUniqueKmers;\n}","1211":"\/**\n *  Compute the hashcode for a KMer.\n *  Equivalent to <code>new String(bases, start, length).hashCode()<\/code>\n *\/\nprivate static int hashCode(final byte[] bases, final int start, final int length) {\n    if (length == 0) {\n        return 0;\n    }\n    int h = 0;\n    for (int i = start, stop = start + length; i < stop; i++) {\n        h = 31 * h + bases[i];\n    }\n    return h;\n}","1212":"public int getDifferingPositions(final Kmer other, final int maxDistance, final int[] differingIndeces, final byte[] differingBases) {\n    Utils.nonNull(other);\n    Utils.nonNull(differingIndeces);\n    Utils.nonNull(differingBases);\n    Utils.validateArg(maxDistance > 0, \"maxDistance must be positive but was \" + maxDistance);\n    int dist = 0;\n    if (length == other.length()) {\n        final byte[] f2 = other.bases;\n        for (int i = 0; i < length; i++) {\n            if (bases[start + i] != f2[i]) {\n                differingIndeces[dist] = i;\n                differingBases[dist++] = f2[i];\n                if (dist > maxDistance) {\n                    return -1;\n                }\n            }\n        }\n    }\n    return dist;\n}","1213":"@VisibleForTesting\nstatic Pair<SeqVertex, SeqVertex> commonPrefixAndSuffixOfVertices(final Collection<SeqVertex> middleVertices) {\n    final List<byte[]> kmers = new ArrayList<>(middleVertices.size());\n    int min = Integer.MAX_VALUE;\n    for (final SeqVertex v : middleVertices) {\n        kmers.add(v.getSequence());\n        min = Math.min(min, v.getSequence().length);\n    }\n    final int prefixLen = GraphUtils.commonMaximumPrefixLength(kmers);\n    final int suffixLen = GraphUtils.commonMaximumSuffixLength(kmers, min - prefixLen);\n    final byte[] kmer = kmers.get(0);\n    final byte[] prefix = Arrays.copyOfRange(kmer, 0, prefixLen);\n    final byte[] suffix = Arrays.copyOfRange(kmer, kmer.length - suffixLen, kmer.length);\n    return new MutablePair<>(new SeqVertex(prefix), new SeqVertex(suffix));\n}","1214":"public final boolean isReferenceNode(final V v) {\n    Utils.nonNull(v, \"Attempting to test a null vertex.\");\n    if (edgesOf(v).stream().anyMatch(e -> e.isRef())) {\n        return true;\n    }\n    return vertexSet().size() == 1;\n}","1215":"@SafeVarargs\npublic final void addEdges(final V start, final V... remaining) {\n    Utils.nonNull(start, \"start vertex\");\n    if (remaining == null || remaining.length == 0) {\n        return;\n    }\n    V prev = start;\n    for (final V next : remaining) {\n        Utils.nonNull(next, \"null vertex\");\n        addEdge(prev, next);\n        prev = next;\n    }\n}","1216":"@SafeVarargs\npublic final void addEdges(final Supplier<E> template, final V start, final V... remaining) {\n    Utils.nonNull(template, \"template edge\");\n    Utils.nonNull(start, \"start vertex\");\n    V prev = start;\n    for (final V next : remaining) {\n        Utils.nonNull(next, \"null vertex\");\n        addEdge(prev, next, template.get());\n        prev = next;\n    }\n}","1217":"public final void removeVerticesNotConnectedToRefRegardlessOfEdgeDirection() {\n    final Collection<V> toRemove = new HashSet<>(vertexSet());\n    final V refV = getReferenceSourceVertex();\n    if (refV != null) {\n        for (final V v : new BaseGraphIterator<>(this, refV, true, true)) {\n            toRemove.remove(v);\n        }\n    }\n    removeAllVertices(toRemove);\n}","1218":"private Set<V> verticesWithinDistance(final V source, final int distance) {\n    if (distance == 0) {\n        return Collections.singleton(source);\n    }\n    final Set<V> found = new HashSet<>();\n    found.add(source);\n    for (final V v : neighboringVerticesOf(source)) {\n        found.addAll(verticesWithinDistance(v, distance - 1));\n    }\n    return found;\n}","1219":"public final BaseGraph<V, E> subsetToNeighbors(final V target, final int distance) {\n    Utils.nonNull(target, \"Target cannot be null\");\n    Utils.validateArg(containsVertex(target), () -> \"Graph doesn't contain vertex \" + target);\n    Utils.validateArg(distance >= 0, () -> \"Distance must be >= 0 but got \" + distance);\n    final Set<V> toKeep = verticesWithinDistance(target, distance);\n    final Collection<V> toRemove = new HashSet<>(vertexSet());\n    toRemove.removeAll(toKeep);\n    final BaseGraph<V, E> result = clone();\n    result.removeAllVertices(toRemove);\n    return result;\n}","1220":"\/**\n * Compute the maximum shared prefix length of list of bytes.\n *\n * @param listOfBytes a list of bytes with at least one element\n * @return the number of shared bytes common at the start of all bytes\n *\/\npublic static int commonMaximumPrefixLength(final List<byte[]> listOfBytes) {\n    final int minLength = GraphUtils.minKmerLength(listOfBytes);\n    for (int i = 0; i < minLength; i++) {\n        final byte b = listOfBytes.get(0)[i];\n        for (int j = 1; j < listOfBytes.size(); j++) {\n            if (b != listOfBytes.get(j)[i]) {\n                return i;\n            }\n        }\n    }\n    return minLength;\n}","1221":"\/**\n * Copies the values from other into this StandardCallerArgumentCollection\n *\n * @param other StandardCallerArgumentCollection from which to copy values\n *\/\npublic void copyStandardCallerArgsFrom(final StandardCallerArgumentCollection other) {\n    Utils.nonNull(other);\n    this.genotypeArgs = other.genotypeArgs.clone();\n    this.CONTAMINATION_FRACTION = other.CONTAMINATION_FRACTION;\n    this.CONTAMINATION_FRACTION_FILE = other.CONTAMINATION_FRACTION_FILE != null ? new File(other.CONTAMINATION_FRACTION_FILE.getAbsolutePath()) : null;\n    if (other.sampleContamination != null) {\n        setSampleContamination(other.sampleContamination);\n    }\n    this.outputMode = other.outputMode;\n    this.annotateAllSitesWithPLs = other.annotateAllSitesWithPLs;\n}","1222":"private boolean contaminationIsPresentInMap(final Map<String, Double> contaminationMap) {\n    if (contaminationMap == null) {\n        return false;\n    }\n    for (final Map.Entry<String, Double> mapEntry : contaminationMap.entrySet()) {\n        if (contaminationFractionIsSet(mapEntry.getValue())) {\n            return true;\n        }\n    }\n    return false;\n}","1223":"public double[] getCoverageProportions(String sample) {\n    long[] hist = granularHistogramBySample.get(sample);\n    double[] distribution = new double[hist.length];\n    long count = 0;\n    for (int i = hist.length - 1; i >= 0; i--) {\n        count += hist[i];\n        distribution[i] = ((double) count) \/ nLoci;\n    }\n    return distribution;\n}","1224":"\/**\n * @return The list of contig names to be traversed, preferentially taking user supplied intervals, but otherwise defaulting to driving variants\n *\/\nprivate List<String> getContigNames() {\n    final TreeSet<String> contigs = new TreeSet<>();\n    if (getEngine().getTraversalIntervals() == null) {\n        getEngine().getSequenceDictionaryForDrivingVariants().getSequences().stream().map(SAMSequenceRecord::getSequenceName).forEach(contigs::add);\n    } else {\n        getEngine().getTraversalIntervals().stream().map(SimpleInterval::getContig).forEach(contigs::add);\n    }\n    return new ArrayList<>(contigs);\n}","1225":"\/**\n * Initialize the collector with input arguments;\n *\/\n@Override\npublic void initialize(final ExampleSingleMetricsArgumentCollection inputArgs, final SAMFileHeader samHeader, final List<Header> defaultHeaders) {\n    metricsFile = new MetricsFile<ExampleSingleMetrics, Integer>();\n    defaultHeaders.stream().forEach(h -> metricsFile.addHeader(h));\n    this.args = inputArgs;\n}","1226":"@Override\npublic void collectMetrics(final JavaRDD<GATKRead> filteredReads, final SAMFileHeader samHeader) {\n    final ExampleSingleMetrics metrics = filteredReads.aggregate(new ExampleSingleMetrics(), (hgp, read) -> hgp.addRead(read), (hgp1, hgp2) -> hgp1.combine(hgp2)).finish();\n    metricsFile.addMetric(metrics);\n}","1227":"\/**\n * @param inputArgs ExampleMultiMetricsArgumentCollection populated with argument values. May not be null.\n * @param samHeader samHeader for the input to be processed. May not be null.\n *\/\npublic void initialize(final ExampleMultiMetricsArgumentCollection inputArgs, final SAMFileHeader samHeader) {\n    Utils.nonNull(inputArgs);\n    Utils.nonNull(samHeader);\n    this.inputArgs = inputArgs;\n    \/\/ call setup to create the level distributors\n    setup(inputArgs.metricAccumulationLevel.accumulationLevels, samHeader.getReadGroups());\n}","1228":"@Override\nprotected PerUnitExampleMultiMetricsCollector makeChildCollector(final String sample, final String library, final String readGroup) {\n    return new PerUnitExampleMultiMetricsCollector(sample, library, readGroup);\n}","1229":"public void saveMetrics(final MetricsFile<ExampleMultiMetrics, Integer> metricsFile) {\n    Utils.nonNull(metricsFile);\n    finish();\n    addAllLevelsToFile(metricsFile);\n    MetricsUtils.saveMetrics(metricsFile, inputArgs.output);\n}","1230":"public PerUnitExampleMultiMetricsCollector combine(PerUnitExampleMultiMetricsCollector sourceCollector) {\n    Utils.nonNull(sourceCollector);\n    final String validationMessage = \"Internal error combining collectors\";\n    validateEquals(this.metrics.SAMPLE, sourceCollector.metrics.SAMPLE, validationMessage);\n    validateEquals(this.metrics.LIBRARY, sourceCollector.metrics.LIBRARY, validationMessage);\n    validateEquals(this.metrics.READ_GROUP, sourceCollector.metrics.READ_GROUP, validationMessage);\n    final PerUnitExampleMultiMetricsCollector combinedCollector = new PerUnitExampleMultiMetricsCollector(this.metrics.SAMPLE, this.metrics.LIBRARY, this.metrics.READ_GROUP);\n    combinedCollector.metrics.NUMREADS = this.metrics.NUMREADS + sourceCollector.metrics.NUMREADS;\n    return combinedCollector;\n}","1231":"private static double[] computeFrequencies(final int[] counts, final int number) {\n    final double[] freq = new double[counts.length];\n    if (number == 0) {\n        Arrays.fill(freq, Double.NaN);\n    } else {\n        for (int i = 0; i < counts.length; i++) {\n            freq[i] = counts[i] \/ (double) number;\n        }\n    }\n    return freq;\n}","1232":"\/**\n * Computes number of reads filtered at each step and total final reads.\n *\/\npublic void computeDerivedMetrics() {\n    if (PRIMARY_READS == null || READS_AFTER_PREALIGNED_HOST_FILTER == null || READS_AFTER_QUALITY_AND_COMPLEXITY_FILTER == null || READS_AFTER_HOST_FILTER == null || READS_AFTER_DEDUPLICATION == null || FINAL_PAIRED_READS == null) {\n        throw new IllegalStateException(\"Cannot compute metrics if primary, pre-aligned host, quality, host, duplicate, or final paired read counts are not initialized\");\n    }\n    FINAL_TOTAL_READS = READS_AFTER_DEDUPLICATION;\n    FINAL_UNPAIRED_READS = FINAL_TOTAL_READS - FINAL_PAIRED_READS;\n    LOW_QUALITY_OR_LOW_COMPLEXITY_READS_FILTERED = READS_AFTER_PREALIGNED_HOST_FILTER - READS_AFTER_QUALITY_AND_COMPLEXITY_FILTER;\n    HOST_READS_FILTERED = PRIMARY_READS - READS_AFTER_PREALIGNED_HOST_FILTER + READS_AFTER_QUALITY_AND_COMPLEXITY_FILTER - READS_AFTER_HOST_FILTER;\n    DUPLICATE_READS_FILTERED = READS_AFTER_HOST_FILTER - READS_AFTER_DEDUPLICATION;\n}","1233":"protected static LargeLongHopscotchSet longArrayCollectionToSet(final Collection<long[]> longs, final long numLongs) {\n    final LargeLongHopscotchSet kmerHopscotchSet = new LargeLongHopscotchSet(numLongs);\n    for (final long[] array : longs) {\n        for (final long val : array) {\n            kmerHopscotchSet.add(val);\n        }\n    }\n    return kmerHopscotchSet;\n}","1234":"protected static LongBloomFilter longArrayCollectionToBloomFilter(final Collection<long[]> longs, final long numLongs, final double bloomFpp) {\n    final LongBloomFilter bloomFilter = new LongBloomFilter(numLongs, bloomFpp);\n    final ProgressCounter counter = new ProgressCounter(numLongs, 1e6, \"million kmers\", logger);\n    for (final long[] array : longs) {\n        bloomFilter.addAll(array);\n        counter.update(array.length);\n    }\n    return bloomFilter;\n}","1235":"private static Iterator<String> getSequenceNames(final GATKRead read) {\n    if (read.isUnmapped() || read.getAssignedContig().equals(\"*\"))\n        return Collections.emptyIterator();\n    if (!read.hasAttribute(\"SA\"))\n        return Collections.singleton(read.getAssignedContig()).iterator();\n    final String[] saTokens = read.getAttributeAsString(\"SA\").split(\";\");\n    final Set<String> sequenceNames = new HashSet<>(SVUtils.hashMapCapacity(1 + saTokens.length));\n    sequenceNames.add(read.getAssignedContig());\n    for (final String token : saTokens) {\n        final String[] alignmentTokens = token.split(\",\", 1);\n        sequenceNames.add(alignmentTokens[0]);\n    }\n    return sequenceNames.iterator();\n}","1236":"public static void writeTaxonomyDatabase(final String filePath, final PSTaxonomyDatabase taxonomyDatabase) {\n    try {\n        final Kryo kryo = new Kryo();\n        kryo.setReferences(false);\n        Output output = new Output(new FileOutputStream(filePath));\n        kryo.writeObject(output, taxonomyDatabase);\n        output.close();\n    } catch (final FileNotFoundException e) {\n        throw new UserException.CouldNotCreateOutputFile(\"Could not serialize objects to file\", e);\n    }\n}","1237":"\/**\n * {@code referenceSequenceDictionary} is required because 2bit Broadcast references currently order their\n * sequence dictionaries in a scrambled order, see https:\/\/github.com\/broadinstitute\/gatk\/issues\/2037.\n *\/\npublic static void writeVCF(final List<VariantContext> localVariants, final String vcfFileName, final SAMSequenceDictionary referenceSequenceDictionary, final Set<VCFHeaderLine> defaultToolVCFHeaderLines, final Logger logger) {\n    final List<VariantContext> sortedVariantsList = sortVariantsByCoordinate(localVariants, referenceSequenceDictionary);\n    if (logger != null)\n        logNumOfVarByTypes(sortedVariantsList, logger);\n    writeVariants(vcfFileName, sortedVariantsList, referenceSequenceDictionary, defaultToolVCFHeaderLines);\n}","1238":"public static void writeQNames(final String qNameFile, final Iterable<QNameAndInterval> qNames) {\n    try (final OutputStreamWriter writer = new OutputStreamWriter(new BufferedOutputStream(BucketUtils.createFile(qNameFile)))) {\n        for (final QNameAndInterval qnameAndInterval : qNames) {\n            writer.write(qnameAndInterval.toString() + \"\\n\");\n        }\n    } catch (final IOException ioe) {\n        throw new GATKException(\"Can't write qname intervals file \" + qNameFile, ioe);\n    }\n}","1239":"\/**\n * Used in production to gather evidence derived from K-S calculation on windows.\n *\/\npublic void testReadAndGatherEvidence(final GATKRead read, final List<BreakpointEvidence> evidenceList) {\n    if (!filter.isTemplateLenTestable(read))\n        return;\n    if (!isSameBlock(read)) {\n        checkHistograms(evidenceList);\n        advanceBlock(read);\n    }\n    addObservation(read);\n}","1240":"@VisibleForTesting\nstatic List<GoodAndBadMappings> filterSecondaryConfigurationsByMappingQualityThreshold(final List<GoodAndBadMappings> differentConfigurationsForOneContig, final int mqThreshold) {\n    if (differentConfigurationsForOneContig.size() == 1) {\n        return differentConfigurationsForOneContig;\n    } else {\n        final List<GoodAndBadMappings> configurationsWithMappingAboveMQThreshold = Utils.stream(differentConfigurationsForOneContig).filter(rep -> rep.getGoodMappings().stream().mapToInt(ai -> ai.mapQual).min().orElse(mqThreshold) > mqThreshold).collect(Collectors.toList());\n        if (configurationsWithMappingAboveMQThreshold.size() != 1) {\n            return differentConfigurationsForOneContig;\n        } else {\n            return configurationsWithMappingAboveMQThreshold;\n        }\n    }\n}","1241":"\/**\n * Initialize the collector with input arguments;\n *\/\n@Override\npublic void initialize(final QualityYieldMetricsArgumentCollection inputArgs, final SAMFileHeader samHeader, final List<Header> defaultHeaders) {\n    metricsFile = new MetricsFile<QualityYieldMetrics, Integer>();\n    defaultHeaders.stream().forEach(h -> metricsFile.addHeader(h));\n    this.args = inputArgs;\n}","1242":"@Override\npublic void collectMetrics(final JavaRDD<GATKRead> filteredReads, final SAMFileHeader samHeader) {\n    final QualityYieldMetrics metrics = filteredReads.aggregate(new QualityYieldMetrics().setUseOriginalQualities(args.useOriginalQualities), (hgp, read) -> hgp.addRead(read), (hgp1, hgp2) -> hgp1.combine(hgp2)).finish();\n    metricsFile.addMetric(metrics);\n}"},"comment_lines":{"0":5,"1":4,"2":5,"3":3,"4":3,"5":4,"6":5,"7":4,"8":4,"9":7,"10":5,"11":4,"12":5,"13":7,"14":7,"15":6,"16":7,"17":7,"18":5,"19":2,"20":2,"21":2,"22":5,"23":3,"24":5,"25":6,"26":6,"27":8,"28":6,"29":5,"30":5,"31":7,"32":8,"33":3,"34":4,"35":3,"36":3,"37":3,"38":4,"39":4,"40":3,"41":2,"42":6,"43":3,"44":6,"45":4,"46":3,"47":4,"48":4,"49":2,"50":3,"51":6,"52":9,"53":8,"54":6,"55":3,"56":3,"57":5,"58":2,"59":2,"60":2,"61":8,"62":2,"63":7,"64":4,"65":6,"66":7,"67":5,"68":6,"69":4,"70":9,"71":6,"72":10,"73":11,"74":26,"75":5,"76":2,"77":6,"78":3,"79":2,"80":6,"81":2,"82":4,"83":3,"84":2,"85":3,"86":1,"87":2,"88":4,"89":2,"90":2,"91":1,"92":5,"93":1,"94":6,"95":6,"96":6,"97":6,"98":6,"99":6,"100":6,"101":6,"102":6,"103":6,"104":6,"105":3,"106":3,"107":3,"108":3,"109":11,"110":3,"111":9,"112":2,"113":3,"114":3,"115":3,"116":5,"117":3,"118":9,"119":2,"120":2,"121":13,"122":5,"123":9,"124":2,"125":2,"126":3,"127":2,"128":7,"129":5,"130":2,"131":2,"132":3,"133":4,"134":2,"135":2,"136":2,"137":2,"138":2,"139":10,"140":5,"141":5,"142":2,"143":2,"144":2,"145":2,"146":2,"147":2,"148":4,"149":2,"150":2,"151":2,"152":2,"153":2,"154":2,"155":2,"156":2,"157":2,"158":7,"159":2,"160":6,"161":4,"162":4,"163":8,"164":6,"165":4,"166":3,"167":3,"168":2,"169":4,"170":4,"171":7,"172":6,"173":7,"174":7,"175":5,"176":4,"177":4,"178":8,"179":7,"180":14,"181":15,"182":6,"183":5,"184":6,"185":6,"186":5,"187":7,"188":8,"189":7,"190":8,"191":7,"192":2,"193":2,"194":6,"195":8,"196":2,"197":2,"198":15,"199":14,"200":9,"201":3,"202":3,"203":3,"204":10,"205":6,"206":2,"207":2,"208":2,"209":4,"210":2,"211":6,"212":3,"213":6,"214":2,"215":3,"216":6,"217":2,"218":4,"219":2,"220":2,"221":4,"222":4,"223":6,"224":4,"225":4,"226":2,"227":2,"228":3,"229":4,"230":4,"231":2,"232":2,"233":2,"234":2,"235":4,"236":6,"237":3,"238":2,"239":2,"240":2,"241":4,"242":4,"243":2,"244":2,"245":3,"246":5,"247":10,"248":8,"249":2,"250":2,"251":2,"252":5,"253":4,"254":2,"255":7,"256":6,"257":2,"258":3,"259":2,"260":5,"261":5,"262":4,"263":2,"264":4,"265":3,"266":3,"267":2,"268":3,"269":2,"270":3,"271":2,"272":5,"273":5,"274":3,"275":4,"276":3,"277":5,"278":3,"279":3,"280":2,"281":2,"282":5,"283":5,"284":8,"285":7,"286":7,"287":2,"288":4,"289":4,"290":7,"291":4,"292":2,"293":2,"294":2,"295":2,"296":2,"297":2,"298":3,"299":5,"300":3,"301":1,"302":4,"303":4,"304":8,"305":8,"306":8,"307":8,"308":8,"309":7,"310":2,"311":8,"312":2,"313":6,"314":6,"315":7,"316":11,"317":4,"318":4,"319":6,"320":8,"321":5,"322":5,"323":6,"324":6,"325":5,"326":6,"327":5,"328":5,"329":5,"330":9,"331":10,"332":2,"333":5,"334":2,"335":4,"336":4,"337":4,"338":2,"339":4,"340":5,"341":5,"342":4,"343":4,"344":4,"345":9,"346":2,"347":2,"348":6,"349":6,"350":5,"351":5,"352":5,"353":4,"354":4,"355":6,"356":4,"357":11,"358":5,"359":4,"360":2,"361":6,"362":4,"363":4,"364":6,"365":7,"366":4,"367":6,"368":4,"369":5,"370":6,"371":9,"372":5,"373":5,"374":5,"375":5,"376":5,"377":5,"378":6,"379":6,"380":6,"381":6,"382":6,"383":5,"384":5,"385":5,"386":5,"387":5,"388":8,"389":5,"390":5,"391":3,"392":3,"393":4,"394":4,"395":4,"396":6,"397":7,"398":7,"399":6,"400":6,"401":6,"402":8,"403":4,"404":6,"405":6,"406":6,"407":4,"408":4,"409":4,"410":4,"411":4,"412":3,"413":4,"414":6,"415":4,"416":4,"417":4,"418":6,"419":3,"420":5,"421":3,"422":2,"423":2,"424":7,"425":6,"426":5,"427":5,"428":5,"429":5,"430":4,"431":4,"432":5,"433":4,"434":4,"435":5,"436":4,"437":5,"438":4,"439":5,"440":4,"441":5,"442":4,"443":5,"444":4,"445":5,"446":4,"447":5,"448":4,"449":5,"450":5,"451":4,"452":7,"453":4,"454":5,"455":5,"456":5,"457":4,"458":4,"459":4,"460":9,"461":4,"462":2,"463":2,"464":5,"465":4,"466":4,"467":6,"468":6,"469":6,"470":2,"471":2,"472":6,"473":4,"474":7,"475":11,"476":3,"477":4,"478":3,"479":5,"480":7,"481":10,"482":7,"483":9,"484":6,"485":8,"486":4,"487":4,"488":4,"489":2,"490":7,"491":7,"492":6,"493":5,"494":3,"495":3,"496":9,"497":12,"498":4,"499":8,"500":6,"501":5,"502":9,"503":4,"504":6,"505":8,"506":6,"507":4,"508":8,"509":7,"510":4,"511":7,"512":7,"513":7,"514":4,"515":7,"516":2,"517":4,"518":7,"519":4,"520":4,"521":2,"522":5,"523":5,"524":7,"525":4,"526":4,"527":2,"528":4,"529":9,"530":7,"531":6,"532":6,"533":2,"534":4,"535":7,"536":7,"537":5,"538":2,"539":2,"540":4,"541":6,"542":6,"543":7,"544":6,"545":4,"546":8,"547":7,"548":9,"549":11,"550":5,"551":2,"552":2,"553":4,"554":4,"555":4,"556":2,"557":4,"558":4,"559":5,"560":5,"561":9,"562":6,"563":10,"564":3,"565":4,"566":2,"567":2,"568":4,"569":2,"570":4,"571":4,"572":2,"573":4,"574":2,"575":7,"576":6,"577":5,"578":5,"579":11,"580":4,"581":2,"582":4,"583":2,"584":2,"585":7,"586":4,"587":4,"588":4,"589":4,"590":6,"591":11,"592":5,"593":2,"594":5,"595":10,"596":6,"597":6,"598":6,"599":5,"600":8,"601":5,"602":9,"603":6,"604":2,"605":6,"606":3,"607":7,"608":6,"609":6,"610":11,"611":14,"612":5,"613":7,"614":11,"615":8,"616":5,"617":6,"618":4,"619":2,"620":2,"621":6,"622":7,"623":8,"624":8,"625":7,"626":6,"627":6,"628":8,"629":9,"630":5,"631":2,"632":4,"633":5,"634":4,"635":5,"636":7,"637":4,"638":6,"639":8,"640":8,"641":7,"642":7,"643":9,"644":6,"645":6,"646":6,"647":5,"648":7,"649":5,"650":6,"651":5,"652":4,"653":7,"654":5,"655":7,"656":4,"657":4,"658":4,"659":4,"660":4,"661":8,"662":8,"663":8,"664":8,"665":6,"666":6,"667":6,"668":6,"669":6,"670":3,"671":7,"672":4,"673":4,"674":7,"675":5,"676":6,"677":6,"678":6,"679":8,"680":4,"681":4,"682":4,"683":4,"684":7,"685":12,"686":6,"687":4,"688":6,"689":4,"690":4,"691":4,"692":4,"693":4,"694":3,"695":6,"696":4,"697":4,"698":4,"699":4,"700":4,"701":4,"702":4,"703":7,"704":7,"705":4,"706":5,"707":5,"708":7,"709":4,"710":7,"711":3,"712":4,"713":4,"714":5,"715":7,"716":2,"717":10,"718":3,"719":6,"720":4,"721":4,"722":2,"723":5,"724":7,"725":5,"726":5,"727":8,"728":5,"729":6,"730":8,"731":6,"732":7,"733":7,"734":7,"735":6,"736":10,"737":9,"738":7,"739":9,"740":9,"741":9,"742":13,"743":10,"744":4,"745":4,"746":6,"747":3,"748":3,"749":3,"750":5,"751":6,"752":5,"753":4,"754":5,"755":4,"756":5,"757":6,"758":6,"759":4,"760":4,"761":4,"762":4,"763":4,"764":5,"765":2,"766":5,"767":13,"768":7,"769":3,"770":5,"771":8,"772":5,"773":6,"774":11,"775":4,"776":6,"777":8,"778":4,"779":6,"780":7,"781":5,"782":6,"783":5,"784":5,"785":6,"786":6,"787":4,"788":4,"789":6,"790":6,"791":5,"792":2,"793":2,"794":2,"795":2,"796":2,"797":2,"798":2,"799":5,"800":2,"801":3,"802":5,"803":2,"804":3,"805":6,"806":10,"807":5,"808":6,"809":24,"810":6,"811":2,"812":3,"813":3,"814":2,"815":2,"816":3,"817":3,"818":2,"819":2,"820":2,"821":2,"822":2,"823":4,"824":3,"825":10,"826":4,"827":7,"828":9,"829":5,"830":6,"831":7,"832":5,"833":2,"834":2,"835":3,"836":3,"837":7,"838":5,"839":5,"840":3,"841":2,"842":8,"843":9,"844":4,"845":3,"846":7,"847":2,"848":4,"849":5,"850":3,"851":2,"852":5,"853":5,"854":2,"855":4,"856":7,"857":8,"858":3,"859":4,"860":4,"861":3,"862":2,"863":4,"864":8,"865":2,"866":3,"867":2,"868":2,"869":3,"870":4,"871":2,"872":4,"873":4,"874":5,"875":6,"876":2,"877":5,"878":9,"879":2,"880":5,"881":4,"882":7,"883":10,"884":2,"885":4,"886":5,"887":3,"888":7,"889":7,"890":8,"891":6,"892":5,"893":2,"894":6,"895":7,"896":3,"897":5,"898":6,"899":8,"900":5,"901":5,"902":8,"903":6,"904":7,"905":5,"906":5,"907":7,"908":4,"909":5,"910":12,"911":5,"912":2,"913":8,"914":3,"915":12,"916":2,"917":2,"918":4,"919":7,"920":2,"921":6,"922":3,"923":3,"924":3,"925":9,"926":5,"927":4,"928":4,"929":2,"930":3,"931":2,"932":6,"933":9,"934":2,"935":3,"936":5,"937":5,"938":3,"939":5,"940":5,"941":2,"942":2,"943":2,"944":9,"945":12,"946":7,"947":3,"948":3,"949":6,"950":5,"951":8,"952":4,"953":5,"954":4,"955":5,"956":5,"957":8,"958":5,"959":7,"960":6,"961":4,"962":6,"963":3,"964":2,"965":7,"966":12,"967":7,"968":4,"969":2,"970":7,"971":4,"972":8,"973":6,"974":8,"975":6,"976":5,"977":8,"978":12,"979":5,"980":11,"981":4,"982":3,"983":3,"984":4,"985":5,"986":5,"987":5,"988":5,"989":2,"990":2,"991":2,"992":2,"993":5,"994":2,"995":4,"996":4,"997":3,"998":3,"999":7,"1000":4,"1001":5,"1002":5,"1003":4,"1004":4,"1005":2,"1006":2,"1007":5,"1008":5,"1009":3,"1010":4,"1011":4,"1012":8,"1013":2,"1014":6,"1015":3,"1016":3,"1017":3,"1018":5,"1019":3,"1020":2,"1021":4,"1022":3,"1023":4,"1024":7,"1025":5,"1026":2,"1027":5,"1028":2,"1029":2,"1030":6,"1031":3,"1032":5,"1033":3,"1034":5,"1035":9,"1036":8,"1037":4,"1038":10,"1039":6,"1040":10,"1041":2,"1042":4,"1043":6,"1044":5,"1045":5,"1046":6,"1047":3,"1048":2,"1049":5,"1050":3,"1051":5,"1052":6,"1053":7,"1054":3,"1055":3,"1056":4,"1057":4,"1058":5,"1059":2,"1060":2,"1061":2,"1062":2,"1063":2,"1064":2,"1065":3,"1066":3,"1067":3,"1068":2,"1069":2,"1070":2,"1071":4,"1072":8,"1073":9,"1074":2,"1075":2,"1076":2,"1077":4,"1078":4,"1079":2,"1080":10,"1081":8,"1082":5,"1083":7,"1084":3,"1085":3,"1086":5,"1087":5,"1088":5,"1089":6,"1090":4,"1091":7,"1092":5,"1093":5,"1094":6,"1095":4,"1096":6,"1097":2,"1098":3,"1099":4,"1100":3,"1101":5,"1102":8,"1103":6,"1104":4,"1105":6,"1106":5,"1107":4,"1108":4,"1109":4,"1110":5,"1111":8,"1112":6,"1113":6,"1114":5,"1115":5,"1116":5,"1117":11,"1118":7,"1119":8,"1120":10,"1121":5,"1122":3,"1123":2,"1124":11,"1125":6,"1126":5,"1127":8,"1128":7,"1129":5,"1130":2,"1131":9,"1132":8,"1133":5,"1134":2,"1135":8,"1136":9,"1137":4,"1138":4,"1139":2,"1140":5,"1141":8,"1142":4,"1143":4,"1144":7,"1145":2,"1146":2,"1147":3,"1148":5,"1149":24,"1150":4,"1151":3,"1152":3,"1153":8,"1154":9,"1155":4,"1156":7,"1157":2,"1158":2,"1159":3,"1160":8,"1161":4,"1162":4,"1163":8,"1164":2,"1165":8,"1166":2,"1167":5,"1168":2,"1169":4,"1170":6,"1171":6,"1172":2,"1173":4,"1174":2,"1175":4,"1176":3,"1177":7,"1178":3,"1179":3,"1180":3,"1181":2,"1182":3,"1183":11,"1184":8,"1185":11,"1186":2,"1187":5,"1188":3,"1189":6,"1190":7,"1191":14,"1192":5,"1193":2,"1194":10,"1195":4,"1196":2,"1197":3,"1198":2,"1199":8,"1200":8,"1201":2,"1202":8,"1203":3,"1204":3,"1205":2,"1206":2,"1207":5,"1208":2,"1209":3,"1210":5,"1211":3,"1212":15,"1213":9,"1214":3,"1215":4,"1216":4,"1217":3,"1218":6,"1219":5,"1220":5,"1221":4,"1222":6,"1223":4,"1224":2,"1225":2,"1226":4,"1227":3,"1228":2,"1229":3,"1230":6,"1231":2,"1232":2,"1233":2,"1234":2,"1235":2,"1236":4,"1237":3,"1238":2,"1239":2,"1240":11,"1241":2,"1242":4},"tokens":{"0":87,"1":41,"2":68,"3":51,"4":49,"5":56,"6":63,"7":81,"8":55,"9":123,"10":78,"11":96,"12":91,"13":83,"14":83,"15":98,"16":83,"17":94,"18":120,"19":73,"20":76,"21":103,"22":117,"23":96,"24":117,"25":76,"26":76,"27":122,"28":73,"29":128,"30":85,"31":110,"32":185,"33":50,"34":88,"35":68,"36":71,"37":71,"38":87,"39":89,"40":143,"41":69,"42":104,"43":88,"44":106,"45":100,"46":67,"47":96,"48":87,"49":57,"50":76,"51":107,"52":138,"53":78,"54":111,"55":54,"56":82,"57":81,"58":77,"59":85,"60":97,"61":128,"62":90,"63":85,"64":77,"65":91,"66":95,"67":97,"68":97,"69":114,"70":142,"71":134,"72":108,"73":108,"74":259,"75":95,"76":89,"77":172,"78":73,"79":86,"80":54,"81":81,"82":77,"83":76,"84":65,"85":74,"86":54,"87":101,"88":125,"89":45,"90":62,"91":84,"92":114,"93":100,"94":106,"95":102,"96":104,"97":104,"98":104,"99":110,"100":102,"101":104,"102":104,"103":100,"104":106,"105":164,"106":104,"107":101,"108":96,"109":137,"110":72,"111":206,"112":72,"113":96,"114":80,"115":75,"116":185,"117":217,"118":201,"119":101,"120":104,"121":190,"122":141,"123":192,"124":84,"125":125,"126":125,"127":112,"128":99,"129":98,"130":75,"131":81,"132":93,"133":131,"134":87,"135":91,"136":68,"137":102,"138":79,"139":147,"140":128,"141":164,"142":99,"143":99,"144":99,"145":103,"146":120,"147":123,"148":121,"149":99,"150":103,"151":120,"152":99,"153":84,"154":102,"155":102,"156":60,"157":78,"158":151,"159":92,"160":102,"161":94,"162":103,"163":195,"164":140,"165":74,"166":111,"167":79,"168":51,"169":99,"170":119,"171":151,"172":93,"173":127,"174":129,"175":123,"176":102,"177":56,"178":124,"179":69,"180":335,"181":177,"182":38,"183":92,"184":106,"185":108,"186":79,"187":65,"188":51,"189":55,"190":50,"191":52,"192":61,"193":63,"194":103,"195":121,"196":57,"197":57,"198":152,"199":152,"200":116,"201":77,"202":84,"203":68,"204":109,"205":93,"206":35,"207":53,"208":47,"209":117,"210":72,"211":118,"212":126,"213":79,"214":66,"215":147,"216":81,"217":82,"218":84,"219":54,"220":77,"221":95,"222":67,"223":86,"224":84,"225":69,"226":84,"227":99,"228":62,"229":85,"230":68,"231":59,"232":68,"233":68,"234":49,"235":68,"236":113,"237":91,"238":71,"239":70,"240":94,"241":51,"242":53,"243":65,"244":56,"245":66,"246":87,"247":162,"248":163,"249":90,"250":98,"251":64,"252":57,"253":72,"254":110,"255":107,"256":73,"257":66,"258":75,"259":45,"260":107,"261":83,"262":86,"263":74,"264":61,"265":120,"266":92,"267":72,"268":86,"269":100,"270":89,"271":85,"272":86,"273":85,"274":65,"275":72,"276":61,"277":167,"278":88,"279":93,"280":79,"281":82,"282":132,"283":58,"284":76,"285":73,"286":95,"287":36,"288":77,"289":98,"290":141,"291":70,"292":92,"293":47,"294":84,"295":46,"296":91,"297":78,"298":59,"299":150,"300":56,"301":88,"302":92,"303":98,"304":137,"305":160,"306":150,"307":152,"308":150,"309":154,"310":52,"311":141,"312":92,"313":103,"314":98,"315":76,"316":125,"317":106,"318":82,"319":134,"320":79,"321":116,"322":84,"323":133,"324":154,"325":63,"326":154,"327":66,"328":62,"329":67,"330":334,"331":96,"332":106,"333":70,"334":199,"335":59,"336":71,"337":64,"338":199,"339":117,"340":104,"341":72,"342":131,"343":148,"344":136,"345":104,"346":64,"347":135,"348":120,"349":126,"350":117,"351":276,"352":106,"353":64,"354":96,"355":104,"356":64,"357":261,"358":136,"359":80,"360":76,"361":69,"362":77,"363":65,"364":120,"365":130,"366":75,"367":133,"368":76,"369":102,"370":97,"371":169,"372":91,"373":144,"374":83,"375":90,"376":93,"377":100,"378":163,"379":163,"380":102,"381":134,"382":127,"383":123,"384":118,"385":128,"386":98,"387":111,"388":133,"389":153,"390":131,"391":93,"392":90,"393":85,"394":61,"395":57,"396":88,"397":131,"398":126,"399":131,"400":105,"401":88,"402":155,"403":87,"404":174,"405":112,"406":115,"407":132,"408":125,"409":129,"410":113,"411":115,"412":94,"413":105,"414":105,"415":85,"416":56,"417":60,"418":88,"419":132,"420":128,"421":152,"422":106,"423":106,"424":67,"425":246,"426":276,"427":206,"428":272,"429":251,"430":48,"431":58,"432":72,"433":167,"434":66,"435":67,"436":88,"437":71,"438":90,"439":69,"440":90,"441":72,"442":90,"443":68,"444":90,"445":73,"446":91,"447":65,"448":86,"449":61,"450":85,"451":106,"452":221,"453":111,"454":113,"455":137,"456":70,"457":111,"458":76,"459":76,"460":131,"461":160,"462":35,"463":29,"464":97,"465":125,"466":96,"467":78,"468":77,"469":78,"470":48,"471":41,"472":54,"473":62,"474":95,"475":135,"476":115,"477":133,"478":83,"479":212,"480":329,"481":167,"482":42,"483":219,"484":63,"485":164,"486":188,"487":103,"488":151,"489":49,"490":191,"491":194,"492":80,"493":80,"494":60,"495":73,"496":72,"497":299,"498":38,"499":107,"500":142,"501":101,"502":129,"503":147,"504":117,"505":128,"506":80,"507":54,"508":80,"509":178,"510":87,"511":125,"512":136,"513":89,"514":62,"515":47,"516":51,"517":48,"518":45,"519":66,"520":66,"521":38,"522":66,"523":71,"524":62,"525":78,"526":52,"527":26,"528":81,"529":59,"530":102,"531":94,"532":66,"533":29,"534":55,"535":65,"536":67,"537":70,"538":96,"539":96,"540":80,"541":59,"542":58,"543":66,"544":48,"545":118,"546":153,"547":128,"548":133,"549":103,"550":101,"551":68,"552":106,"553":103,"554":95,"555":50,"556":97,"557":58,"558":101,"559":99,"560":108,"561":118,"562":97,"563":155,"564":70,"565":94,"566":111,"567":111,"568":102,"569":97,"570":144,"571":114,"572":88,"573":120,"574":115,"575":109,"576":143,"577":81,"578":78,"579":124,"580":54,"581":64,"582":62,"583":95,"584":71,"585":124,"586":77,"587":100,"588":102,"589":96,"590":92,"591":99,"592":89,"593":118,"594":76,"595":77,"596":64,"597":177,"598":82,"599":138,"600":141,"601":114,"602":98,"603":100,"604":30,"605":78,"606":61,"607":123,"608":66,"609":66,"610":194,"611":163,"612":54,"613":65,"614":64,"615":35,"616":63,"617":69,"618":137,"619":130,"620":92,"621":102,"622":74,"623":279,"624":206,"625":142,"626":131,"627":131,"628":179,"629":138,"630":62,"631":21,"632":41,"633":118,"634":91,"635":116,"636":105,"637":154,"638":135,"639":169,"640":75,"641":265,"642":171,"643":171,"644":159,"645":151,"646":153,"647":146,"648":182,"649":74,"650":124,"651":118,"652":78,"653":103,"654":87,"655":115,"656":83,"657":80,"658":83,"659":81,"660":83,"661":136,"662":155,"663":152,"664":149,"665":143,"666":140,"667":140,"668":127,"669":127,"670":67,"671":144,"672":88,"673":86,"674":151,"675":87,"676":118,"677":88,"678":127,"679":149,"680":94,"681":83,"682":110,"683":110,"684":132,"685":185,"686":133,"687":98,"688":120,"689":95,"690":115,"691":99,"692":111,"693":114,"694":84,"695":116,"696":101,"697":237,"698":123,"699":123,"700":129,"701":124,"702":124,"703":107,"704":110,"705":79,"706":243,"707":101,"708":105,"709":119,"710":124,"711":69,"712":79,"713":79,"714":112,"715":197,"716":60,"717":278,"718":639,"719":105,"720":71,"721":86,"722":103,"723":142,"724":205,"725":151,"726":106,"727":177,"728":133,"729":152,"730":253,"731":152,"732":130,"733":128,"734":154,"735":154,"736":341,"737":189,"738":135,"739":189,"740":177,"741":177,"742":144,"743":82,"744":85,"745":70,"746":130,"747":81,"748":125,"749":68,"750":90,"751":180,"752":156,"753":91,"754":151,"755":121,"756":112,"757":227,"758":85,"759":94,"760":102,"761":104,"762":104,"763":31,"764":104,"765":47,"766":91,"767":82,"768":126,"769":119,"770":108,"771":139,"772":110,"773":152,"774":221,"775":71,"776":81,"777":129,"778":74,"779":83,"780":173,"781":130,"782":111,"783":126,"784":122,"785":122,"786":104,"787":112,"788":125,"789":132,"790":118,"791":185,"792":110,"793":109,"794":71,"795":74,"796":71,"797":71,"798":78,"799":133,"800":126,"801":129,"802":53,"803":115,"804":81,"805":150,"806":284,"807":119,"808":91,"809":269,"810":196,"811":102,"812":74,"813":74,"814":61,"815":61,"816":74,"817":74,"818":63,"819":101,"820":94,"821":94,"822":68,"823":171,"824":110,"825":257,"826":114,"827":189,"828":169,"829":63,"830":185,"831":106,"832":183,"833":61,"834":80,"835":105,"836":152,"837":88,"838":110,"839":76,"840":83,"841":112,"842":190,"843":140,"844":129,"845":137,"846":188,"847":57,"848":121,"849":60,"850":93,"851":132,"852":140,"853":181,"854":83,"855":99,"856":182,"857":213,"858":89,"859":214,"860":90,"861":139,"862":77,"863":125,"864":114,"865":134,"866":176,"867":80,"868":105,"869":155,"870":102,"871":95,"872":86,"873":150,"874":61,"875":122,"876":67,"877":130,"878":172,"879":67,"880":60,"881":51,"882":106,"883":132,"884":44,"885":133,"886":103,"887":111,"888":90,"889":102,"890":121,"891":103,"892":112,"893":66,"894":115,"895":95,"896":75,"897":76,"898":78,"899":81,"900":126,"901":87,"902":81,"903":68,"904":100,"905":102,"906":109,"907":113,"908":72,"909":69,"910":127,"911":104,"912":71,"913":151,"914":65,"915":153,"916":75,"917":92,"918":56,"919":157,"920":94,"921":108,"922":64,"923":98,"924":71,"925":258,"926":132,"927":84,"928":74,"929":73,"930":134,"931":49,"932":108,"933":107,"934":82,"935":54,"936":153,"937":68,"938":112,"939":109,"940":127,"941":82,"942":80,"943":82,"944":262,"945":156,"946":198,"947":89,"948":79,"949":102,"950":92,"951":136,"952":72,"953":158,"954":44,"955":175,"956":170,"957":86,"958":130,"959":93,"960":80,"961":77,"962":57,"963":71,"964":63,"965":128,"966":298,"967":99,"968":60,"969":60,"970":123,"971":210,"972":76,"973":273,"974":152,"975":84,"976":53,"977":135,"978":210,"979":82,"980":133,"981":108,"982":114,"983":92,"984":81,"985":130,"986":131,"987":119,"988":78,"989":81,"990":70,"991":61,"992":78,"993":131,"994":64,"995":110,"996":84,"997":50,"998":50,"999":280,"1000":74,"1001":218,"1002":76,"1003":59,"1004":76,"1005":60,"1006":103,"1007":91,"1008":99,"1009":82,"1010":47,"1011":105,"1012":139,"1013":105,"1014":73,"1015":91,"1016":88,"1017":87,"1018":67,"1019":61,"1020":68,"1021":67,"1022":86,"1023":102,"1024":122,"1025":205,"1026":84,"1027":114,"1028":112,"1029":47,"1030":109,"1031":139,"1032":84,"1033":125,"1034":112,"1035":291,"1036":152,"1037":91,"1038":258,"1039":129,"1040":137,"1041":52,"1042":88,"1043":122,"1044":70,"1045":90,"1046":95,"1047":148,"1048":90,"1049":104,"1050":108,"1051":143,"1052":108,"1053":86,"1054":107,"1055":63,"1056":121,"1057":124,"1058":67,"1059":65,"1060":101,"1061":64,"1062":46,"1063":61,"1064":75,"1065":89,"1066":53,"1067":238,"1068":117,"1069":114,"1070":115,"1071":89,"1072":138,"1073":168,"1074":171,"1075":59,"1076":73,"1077":80,"1078":60,"1079":122,"1080":155,"1081":92,"1082":119,"1083":116,"1084":81,"1085":88,"1086":83,"1087":75,"1088":107,"1089":138,"1090":93,"1091":117,"1092":64,"1093":69,"1094":129,"1095":78,"1096":140,"1097":96,"1098":111,"1099":106,"1100":104,"1101":73,"1102":128,"1103":65,"1104":69,"1105":94,"1106":77,"1107":49,"1108":49,"1109":94,"1110":136,"1111":109,"1112":114,"1113":115,"1114":75,"1115":75,"1116":76,"1117":158,"1118":97,"1119":72,"1120":159,"1121":76,"1122":87,"1123":110,"1124":305,"1125":110,"1126":63,"1127":65,"1128":128,"1129":113,"1130":70,"1131":136,"1132":93,"1133":172,"1134":62,"1135":262,"1136":241,"1137":108,"1138":71,"1139":96,"1140":102,"1141":136,"1142":65,"1143":163,"1144":112,"1145":94,"1146":108,"1147":98,"1148":149,"1149":281,"1150":121,"1151":91,"1152":139,"1153":216,"1154":182,"1155":82,"1156":120,"1157":74,"1158":38,"1159":110,"1160":185,"1161":135,"1162":135,"1163":223,"1164":92,"1165":190,"1166":63,"1167":115,"1168":55,"1169":102,"1170":97,"1171":84,"1172":129,"1173":82,"1174":75,"1175":140,"1176":111,"1177":161,"1178":62,"1179":50,"1180":203,"1181":53,"1182":101,"1183":126,"1184":104,"1185":160,"1186":81,"1187":58,"1188":119,"1189":87,"1190":108,"1191":157,"1192":142,"1193":50,"1194":305,"1195":83,"1196":93,"1197":84,"1198":40,"1199":158,"1200":122,"1201":82,"1202":331,"1203":143,"1204":117,"1205":46,"1206":124,"1207":153,"1208":134,"1209":70,"1210":142,"1211":113,"1212":190,"1213":194,"1214":61,"1215":90,"1216":90,"1217":88,"1218":81,"1219":137,"1220":151,"1221":166,"1222":77,"1223":91,"1224":142,"1225":76,"1226":83,"1227":115,"1228":43,"1229":49,"1230":152,"1231":90,"1232":238,"1233":99,"1234":112,"1235":153,"1236":97,"1237":165,"1238":115,"1239":88,"1240":179,"1241":78,"1242":96},"lines":{"0":12,"1":10,"2":13,"3":11,"4":11,"5":10,"6":11,"7":11,"8":11,"9":16,"10":13,"11":12,"12":12,"13":13,"14":13,"15":12,"16":13,"17":15,"18":11,"19":9,"20":9,"21":11,"22":12,"23":9,"24":11,"25":12,"26":12,"27":17,"28":12,"29":13,"30":12,"31":15,"32":17,"33":9,"34":13,"35":12,"36":12,"37":10,"38":11,"39":11,"40":12,"41":9,"42":14,"43":10,"44":14,"45":11,"46":9,"47":12,"48":11,"49":9,"50":11,"51":15,"52":18,"53":14,"54":14,"55":10,"56":11,"57":12,"58":10,"59":11,"60":11,"61":17,"62":11,"63":13,"64":10,"65":12,"66":13,"67":14,"68":13,"69":11,"70":18,"71":12,"72":17,"73":17,"74":33,"75":11,"76":11,"77":15,"78":9,"79":9,"80":12,"81":11,"82":10,"83":9,"84":11,"85":9,"86":7,"87":9,"88":11,"89":8,"90":8,"91":8,"92":13,"93":10,"94":13,"95":13,"96":13,"97":13,"98":13,"99":13,"100":13,"101":13,"102":13,"103":14,"104":13,"105":9,"106":12,"107":11,"108":9,"109":19,"110":12,"111":15,"112":8,"113":9,"114":9,"115":10,"116":12,"117":12,"118":17,"119":9,"120":8,"121":22,"122":13,"123":17,"124":11,"125":11,"126":11,"127":8,"128":13,"129":11,"130":10,"131":8,"132":9,"133":10,"134":10,"135":10,"136":8,"137":11,"138":10,"139":16,"140":14,"141":13,"142":9,"143":9,"144":9,"145":8,"146":9,"147":11,"148":11,"149":9,"150":8,"151":9,"152":9,"153":9,"154":11,"155":11,"156":8,"157":9,"158":14,"159":9,"160":15,"161":10,"162":12,"163":16,"164":12,"165":12,"166":12,"167":11,"168":11,"169":11,"170":10,"171":16,"172":12,"173":16,"174":16,"175":14,"176":10,"177":12,"178":14,"179":13,"180":20,"181":21,"182":13,"183":12,"184":13,"185":13,"186":11,"187":13,"188":16,"189":16,"190":17,"191":16,"192":9,"193":9,"194":12,"195":16,"196":9,"197":9,"198":23,"199":23,"200":15,"201":9,"202":12,"203":9,"204":17,"205":13,"206":8,"207":10,"208":9,"209":13,"210":8,"211":13,"212":10,"213":14,"214":10,"215":10,"216":13,"217":10,"218":11,"219":10,"220":8,"221":11,"222":11,"223":12,"224":12,"225":10,"226":11,"227":11,"228":11,"229":12,"230":10,"231":8,"232":8,"233":8,"234":8,"235":10,"236":13,"237":11,"238":8,"239":8,"240":11,"241":11,"242":11,"243":9,"244":11,"245":10,"246":12,"247":16,"248":17,"249":10,"250":10,"251":9,"252":11,"253":10,"254":9,"255":13,"256":15,"257":9,"258":11,"259":9,"260":14,"261":12,"262":12,"263":8,"264":12,"265":10,"266":9,"267":8,"268":12,"269":9,"270":9,"271":10,"272":12,"273":11,"274":9,"275":10,"276":9,"277":11,"278":9,"279":9,"280":9,"281":9,"282":14,"283":14,"284":14,"285":14,"286":14,"287":10,"288":11,"289":12,"290":13,"291":11,"292":10,"293":8,"294":10,"295":8,"296":8,"297":8,"298":9,"299":14,"300":9,"301":8,"302":13,"303":13,"304":17,"305":17,"306":14,"307":14,"308":14,"309":16,"310":9,"311":14,"312":11,"313":13,"314":12,"315":14,"316":19,"317":12,"318":12,"319":14,"320":15,"321":13,"322":12,"323":15,"324":15,"325":11,"326":15,"327":13,"328":12,"329":12,"330":16,"331":16,"332":9,"333":11,"334":11,"335":10,"336":10,"337":10,"338":11,"339":13,"340":12,"341":12,"342":13,"343":12,"344":13,"345":16,"346":11,"347":11,"348":12,"349":13,"350":13,"351":13,"352":13,"353":13,"354":12,"355":12,"356":10,"357":20,"358":14,"359":10,"360":10,"361":13,"362":11,"363":10,"364":14,"365":14,"366":11,"367":15,"368":12,"369":11,"370":13,"371":16,"372":11,"373":12,"374":11,"375":11,"376":12,"377":11,"378":15,"379":14,"380":12,"381":13,"382":14,"383":12,"384":13,"385":14,"386":11,"387":12,"388":17,"389":14,"390":13,"391":11,"392":11,"393":12,"394":10,"395":10,"396":14,"397":15,"398":15,"399":15,"400":13,"401":14,"402":16,"403":10,"404":15,"405":12,"406":13,"407":11,"408":12,"409":11,"410":12,"411":12,"412":12,"413":11,"414":15,"415":13,"416":10,"417":10,"418":14,"419":11,"420":12,"421":12,"422":8,"423":9,"424":13,"425":12,"426":13,"427":13,"428":14,"429":11,"430":11,"431":12,"432":12,"433":13,"434":10,"435":11,"436":10,"437":11,"438":10,"439":11,"440":10,"441":11,"442":10,"443":11,"444":10,"445":11,"446":10,"447":11,"448":10,"449":12,"450":12,"451":11,"452":13,"453":11,"454":11,"455":11,"456":11,"457":13,"458":10,"459":11,"460":15,"461":13,"462":11,"463":11,"464":11,"465":10,"466":12,"467":12,"468":12,"469":12,"470":11,"471":11,"472":13,"473":11,"474":16,"475":19,"476":10,"477":11,"478":9,"479":13,"480":15,"481":19,"482":14,"483":16,"484":14,"485":15,"486":13,"487":13,"488":12,"489":8,"490":15,"491":14,"492":12,"493":12,"494":12,"495":10,"496":17,"497":18,"498":10,"499":16,"500":12,"501":11,"502":15,"503":13,"504":14,"505":17,"506":14,"507":10,"508":17,"509":14,"510":13,"511":15,"512":15,"513":13,"514":10,"515":13,"516":8,"517":10,"518":14,"519":11,"520":11,"521":11,"522":14,"523":14,"524":14,"525":10,"526":10,"527":8,"528":12,"529":15,"530":16,"531":14,"532":14,"533":11,"534":10,"535":13,"536":13,"537":11,"538":8,"539":8,"540":12,"541":14,"542":14,"543":15,"544":15,"545":10,"546":16,"547":15,"548":15,"549":19,"550":11,"551":9,"552":10,"553":11,"554":12,"555":10,"556":11,"557":11,"558":11,"559":13,"560":13,"561":15,"562":12,"563":18,"564":10,"565":13,"566":11,"567":10,"568":10,"569":10,"570":11,"571":13,"572":10,"573":11,"574":9,"575":16,"576":12,"577":12,"578":12,"579":18,"580":12,"581":11,"582":12,"583":9,"584":8,"585":15,"586":10,"587":11,"588":11,"589":13,"590":13,"591":17,"592":12,"593":11,"594":11,"595":16,"596":12,"597":13,"598":12,"599":11,"600":16,"601":14,"602":18,"603":14,"604":11,"605":12,"606":11,"607":13,"608":12,"609":12,"610":18,"611":23,"612":14,"613":16,"614":17,"615":14,"616":13,"617":14,"618":10,"619":9,"620":8,"621":14,"622":15,"623":16,"624":16,"625":15,"626":12,"627":12,"628":17,"629":18,"630":12,"631":8,"632":10,"633":11,"634":10,"635":13,"636":13,"637":12,"638":14,"639":16,"640":17,"641":15,"642":15,"643":15,"644":12,"645":13,"646":13,"647":12,"648":13,"649":11,"650":12,"651":12,"652":10,"653":14,"654":13,"655":14,"656":12,"657":12,"658":12,"659":10,"660":10,"661":15,"662":14,"663":14,"664":14,"665":14,"666":14,"667":14,"668":14,"669":13,"670":9,"671":16,"672":11,"673":11,"674":13,"675":12,"676":13,"677":13,"678":14,"679":17,"680":10,"681":10,"682":13,"683":13,"684":14,"685":20,"686":15,"687":13,"688":14,"689":12,"690":13,"691":12,"692":13,"693":11,"694":12,"695":12,"696":11,"697":11,"698":11,"699":11,"700":11,"701":11,"702":11,"703":14,"704":14,"705":12,"706":13,"707":14,"708":13,"709":12,"710":13,"711":9,"712":10,"713":10,"714":12,"715":15,"716":8,"717":17,"718":10,"719":12,"720":12,"721":11,"722":8,"723":13,"724":16,"725":14,"726":12,"727":16,"728":13,"729":12,"730":17,"731":13,"732":14,"733":14,"734":16,"735":14,"736":17,"737":18,"738":15,"739":18,"740":17,"741":17,"742":22,"743":16,"744":10,"745":10,"746":12,"747":10,"748":11,"749":9,"750":12,"751":14,"752":11,"753":13,"754":13,"755":10,"756":12,"757":14,"758":13,"759":11,"760":12,"761":12,"762":12,"763":10,"764":13,"765":8,"766":12,"767":20,"768":13,"769":10,"770":13,"771":17,"772":13,"773":13,"774":18,"775":12,"776":14,"777":14,"778":10,"779":15,"780":14,"781":11,"782":12,"783":12,"784":12,"785":13,"786":15,"787":11,"788":12,"789":12,"790":14,"791":14,"792":8,"793":8,"794":8,"795":8,"796":8,"797":8,"798":8,"799":14,"800":8,"801":11,"802":13,"803":11,"804":12,"805":15,"806":19,"807":14,"808":13,"809":30,"810":14,"811":9,"812":11,"813":11,"814":9,"815":9,"816":11,"817":11,"818":8,"819":11,"820":11,"821":11,"822":8,"823":13,"824":9,"825":18,"826":13,"827":13,"828":16,"829":11,"830":15,"831":13,"832":14,"833":8,"834":8,"835":12,"836":10,"837":15,"838":11,"839":14,"840":9,"841":9,"842":15,"843":15,"844":13,"845":9,"846":16,"847":8,"848":10,"849":11,"850":12,"851":11,"852":12,"853":14,"854":9,"855":12,"856":16,"857":16,"858":9,"859":13,"860":13,"861":11,"862":10,"863":12,"864":16,"865":9,"866":10,"867":11,"868":11,"869":12,"870":12,"871":8,"872":12,"873":11,"874":12,"875":14,"876":9,"877":13,"878":15,"879":8,"880":14,"881":13,"882":14,"883":16,"884":11,"885":10,"886":11,"887":10,"888":13,"889":13,"890":16,"891":15,"892":14,"893":8,"894":14,"895":13,"896":12,"897":13,"898":13,"899":14,"900":11,"901":11,"902":14,"903":12,"904":14,"905":11,"906":12,"907":13,"908":10,"909":12,"910":18,"911":11,"912":11,"913":14,"914":11,"915":19,"916":8,"917":8,"918":10,"919":16,"920":10,"921":12,"922":12,"923":12,"924":12,"925":17,"926":11,"927":10,"928":10,"929":9,"930":12,"931":9,"932":12,"933":16,"934":11,"935":9,"936":12,"937":11,"938":9,"939":11,"940":11,"941":8,"942":8,"943":8,"944":18,"945":19,"946":16,"947":9,"948":11,"949":12,"950":12,"951":17,"952":10,"953":11,"954":10,"955":12,"956":12,"957":14,"958":14,"959":14,"960":13,"961":11,"962":15,"963":11,"964":9,"965":14,"966":20,"967":13,"968":11,"969":10,"970":13,"971":13,"972":15,"973":12,"974":15,"975":15,"976":11,"977":17,"978":18,"979":11,"980":19,"981":12,"982":9,"983":10,"984":10,"985":12,"986":13,"987":13,"988":14,"989":10,"990":11,"991":9,"992":9,"993":14,"994":8,"995":11,"996":12,"997":12,"998":12,"999":16,"1000":11,"1001":12,"1002":14,"1003":10,"1004":11,"1005":8,"1006":10,"1007":11,"1008":11,"1009":9,"1010":10,"1011":12,"1012":14,"1013":11,"1014":12,"1015":10,"1016":10,"1017":10,"1018":12,"1019":10,"1020":11,"1021":10,"1022":11,"1023":13,"1024":15,"1025":14,"1026":8,"1027":12,"1028":10,"1029":9,"1030":13,"1031":11,"1032":11,"1033":12,"1034":11,"1035":17,"1036":15,"1037":12,"1038":16,"1039":13,"1040":17,"1041":10,"1042":13,"1043":12,"1044":12,"1045":14,"1046":13,"1047":10,"1048":10,"1049":14,"1050":10,"1051":14,"1052":14,"1053":16,"1054":10,"1055":9,"1056":12,"1057":10,"1058":12,"1059":8,"1060":8,"1061":9,"1062":11,"1063":8,"1064":9,"1065":12,"1066":9,"1067":10,"1068":11,"1069":11,"1070":9,"1071":12,"1072":17,"1073":15,"1074":9,"1075":9,"1076":9,"1077":10,"1078":12,"1079":11,"1080":16,"1081":15,"1082":13,"1083":16,"1084":9,"1085":12,"1086":11,"1087":12,"1088":11,"1089":14,"1090":11,"1091":13,"1092":12,"1093":13,"1094":12,"1095":11,"1096":15,"1097":10,"1098":10,"1099":10,"1100":9,"1101":11,"1102":16,"1103":12,"1104":13,"1105":15,"1106":12,"1107":10,"1108":10,"1109":13,"1110":13,"1111":14,"1112":14,"1113":14,"1114":14,"1115":14,"1116":11,"1117":19,"1118":14,"1119":14,"1120":16,"1121":13,"1122":10,"1123":9,"1124":20,"1125":14,"1126":11,"1127":15,"1128":16,"1129":14,"1130":8,"1131":17,"1132":15,"1133":14,"1134":10,"1135":15,"1136":15,"1137":10,"1138":12,"1139":11,"1140":12,"1141":15,"1142":11,"1143":13,"1144":13,"1145":9,"1146":11,"1147":11,"1148":14,"1149":30,"1150":10,"1151":10,"1152":11,"1153":17,"1154":17,"1155":10,"1156":14,"1157":9,"1158":8,"1159":10,"1160":14,"1161":12,"1162":12,"1163":15,"1164":9,"1165":14,"1166":8,"1167":12,"1168":8,"1169":13,"1170":15,"1171":12,"1172":9,"1173":11,"1174":11,"1175":13,"1176":11,"1177":16,"1178":12,"1179":11,"1180":11,"1181":8,"1182":12,"1183":18,"1184":14,"1185":17,"1186":8,"1187":11,"1188":10,"1189":14,"1190":13,"1191":20,"1192":12,"1193":11,"1194":18,"1195":11,"1196":8,"1197":12,"1198":8,"1199":14,"1200":17,"1201":8,"1202":15,"1203":10,"1204":9,"1205":8,"1206":10,"1207":12,"1208":11,"1209":11,"1210":12,"1211":9,"1212":24,"1213":17,"1214":9,"1215":12,"1216":11,"1217":11,"1218":12,"1219":13,"1220":12,"1221":11,"1222":12,"1223":10,"1224":10,"1225":8,"1226":12,"1227":11,"1228":9,"1229":9,"1230":14,"1231":10,"1232":11,"1233":8,"1234":8,"1235":11,"1236":10,"1237":11,"1238":10,"1239":8,"1240":18,"1241":8,"1242":12},"parameters":{"0":1,"1":1,"2":2,"3":0,"4":0,"5":1,"6":1,"7":0,"8":0,"9":2,"10":1,"11":1,"12":0,"13":2,"14":2,"15":1,"16":2,"17":1,"18":2,"19":0,"20":0,"21":0,"22":1,"23":0,"24":2,"25":3,"26":3,"27":5,"28":3,"29":1,"30":2,"31":3,"32":4,"33":0,"34":1,"35":0,"36":0,"37":3,"38":0,"39":0,"40":0,"41":0,"42":3,"43":1,"44":2,"45":1,"46":0,"47":0,"48":1,"49":0,"50":0,"51":1,"52":5,"53":1,"54":3,"55":1,"56":1,"57":0,"58":0,"59":0,"60":0,"61":4,"62":1,"63":2,"64":2,"65":2,"66":2,"67":1,"68":1,"69":0,"70":3,"71":3,"72":1,"73":1,"74":5,"75":2,"76":2,"77":0,"78":0,"79":0,"80":1,"81":1,"82":0,"83":2,"84":1,"85":1,"86":0,"87":1,"88":1,"89":1,"90":2,"91":2,"92":0,"93":2,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1,"105":1,"106":1,"107":1,"108":1,"109":1,"110":2,"111":2,"112":1,"113":1,"114":1,"115":1,"116":3,"117":1,"118":3,"119":0,"120":0,"121":3,"122":1,"123":1,"124":1,"125":1,"126":1,"127":0,"128":1,"129":1,"130":1,"131":0,"132":1,"133":1,"134":0,"135":1,"136":0,"137":1,"138":0,"139":3,"140":0,"141":2,"142":1,"143":1,"144":1,"145":1,"146":1,"147":1,"148":2,"149":1,"150":1,"151":1,"152":1,"153":0,"154":0,"155":0,"156":0,"157":0,"158":1,"159":1,"160":2,"161":1,"162":0,"163":3,"164":2,"165":0,"166":0,"167":0,"168":0,"169":0,"170":1,"171":1,"172":2,"173":1,"174":1,"175":0,"176":1,"177":1,"178":1,"179":1,"180":1,"181":2,"182":1,"183":1,"184":1,"185":1,"186":1,"187":1,"188":1,"189":1,"190":1,"191":1,"192":1,"193":1,"194":2,"195":2,"196":0,"197":0,"198":4,"199":4,"200":1,"201":1,"202":3,"203":0,"204":2,"205":1,"206":0,"207":0,"208":0,"209":2,"210":1,"211":3,"212":2,"213":1,"214":0,"215":2,"216":1,"217":0,"218":2,"219":0,"220":2,"221":2,"222":0,"223":2,"224":2,"225":3,"226":1,"227":1,"228":0,"229":0,"230":0,"231":1,"232":0,"233":0,"234":2,"235":0,"236":1,"237":1,"238":1,"239":1,"240":2,"241":1,"242":1,"243":0,"244":0,"245":2,"246":1,"247":6,"248":3,"249":1,"250":4,"251":0,"252":1,"253":0,"254":0,"255":1,"256":1,"257":1,"258":0,"259":0,"260":1,"261":1,"262":0,"263":2,"264":1,"265":1,"266":1,"267":1,"268":1,"269":1,"270":0,"271":0,"272":1,"273":2,"274":1,"275":0,"276":1,"277":1,"278":1,"279":1,"280":0,"281":0,"282":1,"283":1,"284":2,"285":2,"286":1,"287":0,"288":1,"289":3,"290":0,"291":1,"292":1,"293":2,"294":1,"295":1,"296":1,"297":1,"298":2,"299":2,"300":0,"301":1,"302":1,"303":1,"304":2,"305":2,"306":3,"307":3,"308":3,"309":3,"310":2,"311":1,"312":0,"313":3,"314":2,"315":1,"316":1,"317":0,"318":1,"319":2,"320":2,"321":0,"322":1,"323":3,"324":2,"325":1,"326":2,"327":1,"328":1,"329":1,"330":0,"331":2,"332":0,"333":1,"334":0,"335":1,"336":0,"337":0,"338":0,"339":2,"340":0,"341":1,"342":1,"343":1,"344":1,"345":0,"346":1,"347":0,"348":3,"349":2,"350":1,"351":1,"352":1,"353":1,"354":1,"355":2,"356":1,"357":1,"358":2,"359":1,"360":0,"361":2,"362":1,"363":1,"364":2,"365":3,"366":1,"367":2,"368":1,"369":1,"370":2,"371":2,"372":2,"373":1,"374":1,"375":1,"376":1,"377":1,"378":1,"379":1,"380":1,"381":1,"382":1,"383":1,"384":1,"385":1,"386":1,"387":1,"388":1,"389":1,"390":1,"391":0,"392":0,"393":0,"394":1,"395":0,"396":0,"397":0,"398":0,"399":0,"400":0,"401":0,"402":2,"403":1,"404":1,"405":2,"406":2,"407":0,"408":0,"409":0,"410":0,"411":0,"412":0,"413":0,"414":0,"415":0,"416":0,"417":1,"418":0,"419":0,"420":1,"421":0,"422":0,"423":0,"424":2,"425":1,"426":1,"427":1,"428":1,"429":1,"430":0,"431":0,"432":1,"433":1,"434":0,"435":1,"436":1,"437":1,"438":1,"439":1,"440":1,"441":1,"442":1,"443":1,"444":1,"445":1,"446":1,"447":1,"448":1,"449":1,"450":1,"451":0,"452":1,"453":0,"454":1,"455":0,"456":0,"457":0,"458":0,"459":1,"460":1,"461":0,"462":0,"463":0,"464":1,"465":0,"466":0,"467":1,"468":1,"469":1,"470":0,"471":0,"472":1,"473":0,"474":2,"475":7,"476":1,"477":1,"478":0,"479":1,"480":1,"481":4,"482":2,"483":1,"484":0,"485":1,"486":0,"487":0,"488":1,"489":0,"490":3,"491":3,"492":1,"493":1,"494":0,"495":0,"496":1,"497":3,"498":1,"499":1,"500":0,"501":2,"502":1,"503":0,"504":1,"505":1,"506":1,"507":0,"508":1,"509":2,"510":1,"511":1,"512":2,"513":2,"514":1,"515":2,"516":0,"517":0,"518":1,"519":0,"520":0,"521":0,"522":1,"523":1,"524":1,"525":0,"526":1,"527":0,"528":1,"529":4,"530":2,"531":1,"532":1,"533":0,"534":0,"535":1,"536":1,"537":2,"538":0,"539":0,"540":0,"541":1,"542":1,"543":2,"544":1,"545":0,"546":2,"547":1,"548":1,"549":1,"550":2,"551":0,"552":0,"553":1,"554":0,"555":1,"556":0,"557":1,"558":1,"559":1,"560":1,"561":1,"562":3,"563":5,"564":0,"565":0,"566":0,"567":0,"568":0,"569":0,"570":0,"571":1,"572":0,"573":1,"574":0,"575":3,"576":3,"577":1,"578":2,"579":3,"580":1,"581":1,"582":1,"583":0,"584":0,"585":2,"586":1,"587":1,"588":1,"589":0,"590":1,"591":2,"592":1,"593":0,"594":1,"595":1,"596":2,"597":0,"598":0,"599":0,"600":1,"601":1,"602":1,"603":3,"604":0,"605":1,"606":0,"607":2,"608":1,"609":1,"610":3,"611":4,"612":2,"613":4,"614":4,"615":1,"616":1,"617":1,"618":1,"619":0,"620":0,"621":1,"622":1,"623":4,"624":4,"625":3,"626":2,"627":2,"628":2,"629":3,"630":2,"631":0,"632":1,"633":2,"634":1,"635":1,"636":2,"637":1,"638":2,"639":2,"640":2,"641":2,"642":2,"643":2,"644":3,"645":3,"646":3,"647":2,"648":3,"649":0,"650":0,"651":0,"652":1,"653":4,"654":1,"655":2,"656":1,"657":1,"658":1,"659":1,"660":1,"661":3,"662":3,"663":3,"664":3,"665":3,"666":3,"667":3,"668":3,"669":3,"670":0,"671":3,"672":1,"673":1,"674":3,"675":1,"676":2,"677":2,"678":2,"679":2,"680":0,"681":0,"682":0,"683":0,"684":1,"685":2,"686":3,"687":1,"688":1,"689":1,"690":1,"691":1,"692":1,"693":1,"694":0,"695":2,"696":1,"697":1,"698":1,"699":1,"700":1,"701":1,"702":1,"703":3,"704":2,"705":0,"706":0,"707":1,"708":1,"709":1,"710":2,"711":0,"712":0,"713":0,"714":1,"715":3,"716":0,"717":2,"718":1,"719":2,"720":1,"721":1,"722":1,"723":1,"724":3,"725":2,"726":2,"727":3,"728":3,"729":3,"730":1,"731":3,"732":1,"733":1,"734":1,"735":2,"736":2,"737":3,"738":2,"739":3,"740":3,"741":3,"742":1,"743":1,"744":2,"745":1,"746":4,"747":1,"748":1,"749":0,"750":2,"751":2,"752":3,"753":0,"754":3,"755":2,"756":3,"757":4,"758":3,"759":1,"760":1,"761":1,"762":1,"763":2,"764":4,"765":0,"766":2,"767":1,"768":1,"769":0,"770":0,"771":3,"772":1,"773":1,"774":3,"775":1,"776":1,"777":2,"778":0,"779":2,"780":4,"781":1,"782":3,"783":2,"784":2,"785":1,"786":2,"787":1,"788":1,"789":1,"790":2,"791":1,"792":0,"793":1,"794":1,"795":1,"796":1,"797":1,"798":1,"799":1,"800":1,"801":0,"802":0,"803":0,"804":2,"805":1,"806":6,"807":0,"808":1,"809":2,"810":1,"811":1,"812":1,"813":1,"814":1,"815":1,"816":1,"817":1,"818":1,"819":2,"820":2,"821":2,"822":2,"823":4,"824":1,"825":2,"826":0,"827":1,"828":3,"829":1,"830":3,"831":4,"832":2,"833":1,"834":2,"835":0,"836":1,"837":1,"838":1,"839":1,"840":1,"841":3,"842":4,"843":3,"844":1,"845":2,"846":1,"847":0,"848":1,"849":1,"850":2,"851":2,"852":1,"853":1,"854":0,"855":3,"856":4,"857":6,"858":1,"859":1,"860":1,"861":1,"862":1,"863":0,"864":2,"865":2,"866":0,"867":1,"868":1,"869":4,"870":2,"871":2,"872":3,"873":5,"874":0,"875":1,"876":0,"877":2,"878":5,"879":2,"880":1,"881":1,"882":1,"883":3,"884":0,"885":1,"886":1,"887":1,"888":1,"889":2,"890":1,"891":1,"892":2,"893":0,"894":2,"895":2,"896":0,"897":1,"898":2,"899":1,"900":1,"901":1,"902":2,"903":1,"904":3,"905":1,"906":1,"907":1,"908":0,"909":1,"910":1,"911":1,"912":1,"913":3,"914":1,"915":4,"916":1,"917":1,"918":2,"919":2,"920":0,"921":1,"922":1,"923":1,"924":1,"925":1,"926":1,"927":2,"928":2,"929":0,"930":1,"931":1,"932":2,"933":2,"934":1,"935":1,"936":0,"937":0,"938":0,"939":1,"940":0,"941":0,"942":0,"943":1,"944":2,"945":3,"946":2,"947":1,"948":1,"949":1,"950":2,"951":1,"952":1,"953":1,"954":0,"955":1,"956":1,"957":1,"958":1,"959":1,"960":1,"961":0,"962":3,"963":0,"964":0,"965":1,"966":1,"967":1,"968":1,"969":1,"970":1,"971":3,"972":0,"973":1,"974":3,"975":2,"976":0,"977":1,"978":2,"979":1,"980":3,"981":0,"982":1,"983":0,"984":2,"985":1,"986":1,"987":1,"988":1,"989":2,"990":1,"991":1,"992":0,"993":2,"994":0,"995":1,"996":0,"997":0,"998":0,"999":2,"1000":0,"1001":1,"1002":0,"1003":0,"1004":1,"1005":1,"1006":2,"1007":2,"1008":2,"1009":0,"1010":0,"1011":1,"1012":3,"1013":1,"1014":3,"1015":1,"1016":1,"1017":1,"1018":1,"1019":1,"1020":1,"1021":0,"1022":1,"1023":2,"1024":4,"1025":1,"1026":0,"1027":2,"1028":3,"1029":1,"1030":2,"1031":1,"1032":2,"1033":1,"1034":2,"1035":2,"1036":2,"1037":1,"1038":2,"1039":2,"1040":1,"1041":0,"1042":1,"1043":1,"1044":1,"1045":1,"1046":1,"1047":2,"1048":0,"1049":2,"1050":2,"1051":2,"1052":1,"1053":2,"1054":1,"1055":1,"1056":1,"1057":1,"1058":0,"1059":1,"1060":2,"1061":0,"1062":0,"1063":1,"1064":0,"1065":0,"1066":0,"1067":1,"1068":1,"1069":1,"1070":1,"1071":1,"1072":2,"1073":3,"1074":3,"1075":2,"1076":2,"1077":1,"1078":1,"1079":2,"1080":2,"1081":1,"1082":1,"1083":1,"1084":1,"1085":1,"1086":2,"1087":1,"1088":2,"1089":2,"1090":1,"1091":1,"1092":1,"1093":1,"1094":1,"1095":1,"1096":3,"1097":1,"1098":1,"1099":2,"1100":1,"1101":2,"1102":2,"1103":0,"1104":0,"1105":1,"1106":1,"1107":0,"1108":0,"1109":1,"1110":2,"1111":2,"1112":2,"1113":2,"1114":1,"1115":1,"1116":1,"1117":3,"1118":2,"1119":2,"1120":2,"1121":1,"1122":0,"1123":1,"1124":0,"1125":1,"1126":1,"1127":3,"1128":4,"1129":1,"1130":1,"1131":2,"1132":1,"1133":4,"1134":0,"1135":1,"1136":0,"1137":1,"1138":0,"1139":0,"1140":1,"1141":4,"1142":1,"1143":1,"1144":2,"1145":1,"1146":1,"1147":1,"1148":2,"1149":5,"1150":1,"1151":1,"1152":1,"1153":4,"1154":4,"1155":2,"1156":3,"1157":2,"1158":0,"1159":0,"1160":4,"1161":2,"1162":2,"1163":5,"1164":2,"1165":4,"1166":0,"1167":1,"1168":0,"1169":1,"1170":3,"1171":1,"1172":3,"1173":1,"1174":0,"1175":1,"1176":1,"1177":2,"1178":0,"1179":0,"1180":2,"1181":0,"1182":0,"1183":1,"1184":0,"1185":0,"1186":0,"1187":1,"1188":1,"1189":1,"1190":2,"1191":2,"1192":2,"1193":0,"1194":0,"1195":1,"1196":3,"1197":1,"1198":0,"1199":1,"1200":4,"1201":1,"1202":2,"1203":1,"1204":0,"1205":0,"1206":1,"1207":1,"1208":1,"1209":1,"1210":2,"1211":3,"1212":4,"1213":1,"1214":1,"1215":2,"1216":3,"1217":0,"1218":2,"1219":2,"1220":1,"1221":1,"1222":1,"1223":1,"1224":0,"1225":3,"1226":2,"1227":2,"1228":3,"1229":1,"1230":1,"1231":2,"1232":0,"1233":2,"1234":3,"1235":1,"1236":2,"1237":5,"1238":2,"1239":2,"1240":2,"1241":3,"1242":2},"functions":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":17,"13":17,"14":17,"15":17,"16":17,"17":17,"18":28,"19":24,"20":27,"21":49,"22":23,"23":0,"24":6,"25":6,"26":6,"27":6,"28":6,"29":7,"30":7,"31":7,"32":7,"33":10,"34":0,"35":0,"36":0,"37":0,"38":3,"39":3,"40":0,"41":0,"42":107,"43":25,"44":25,"45":0,"46":0,"47":63,"48":63,"49":63,"50":63,"51":63,"52":133,"53":145,"54":64,"55":0,"56":0,"57":0,"58":32,"59":32,"60":70,"61":86,"62":70,"63":70,"64":0,"65":76,"66":76,"67":76,"68":76,"69":9,"70":56,"71":8,"72":103,"73":103,"74":0,"75":0,"76":0,"77":0,"78":31,"79":31,"80":12,"81":24,"82":0,"83":0,"84":0,"85":0,"86":9,"87":9,"88":13,"89":0,"90":72,"91":130,"92":132,"93":13,"94":0,"95":0,"96":0,"97":0,"98":0,"99":0,"100":0,"101":0,"102":0,"103":0,"104":0,"105":28,"106":28,"107":57,"108":28,"109":28,"110":0,"111":23,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":36,"120":0,"121":0,"122":0,"123":0,"124":6,"125":6,"126":6,"127":0,"128":0,"129":12,"130":48,"131":5,"132":39,"133":0,"134":1,"135":1,"136":42,"137":42,"138":51,"139":51,"140":22,"141":0,"142":70,"143":70,"144":70,"145":70,"146":70,"147":70,"148":42,"149":70,"150":70,"151":70,"152":70,"153":0,"154":0,"155":0,"156":0,"157":0,"158":0,"159":0,"160":0,"161":120,"162":0,"163":0,"164":0,"165":0,"166":15,"167":15,"168":0,"169":0,"170":0,"171":3,"172":3,"173":3,"174":3,"175":0,"176":0,"177":55,"178":42,"179":42,"180":72,"181":72,"182":36,"183":107,"184":108,"185":88,"186":43,"187":24,"188":12,"189":12,"190":44,"191":44,"192":51,"193":51,"194":24,"195":24,"196":36,"197":36,"198":80,"199":80,"200":22,"201":0,"202":0,"203":0,"204":0,"205":0,"206":104,"207":104,"208":153,"209":0,"210":42,"211":0,"212":0,"213":0,"214":0,"215":0,"216":0,"217":0,"218":19,"219":111,"220":76,"221":17,"222":17,"223":0,"224":0,"225":0,"226":55,"227":55,"228":55,"229":55,"230":55,"231":65,"232":79,"233":79,"234":79,"235":79,"236":79,"237":79,"238":0,"239":0,"240":0,"241":0,"242":0,"243":0,"244":0,"245":0,"246":0,"247":0,"248":0,"249":122,"250":93,"251":19,"252":19,"253":19,"254":0,"255":101,"256":108,"257":132,"258":115,"259":75,"260":72,"261":72,"262":137,"263":7,"264":67,"265":0,"266":0,"267":0,"268":0,"269":0,"270":1,"271":1,"272":0,"273":0,"274":0,"275":0,"276":0,"277":0,"278":0,"279":0,"280":0,"281":0,"282":0,"283":0,"284":0,"285":0,"286":27,"287":0,"288":0,"289":0,"290":0,"291":0,"292":0,"293":0,"294":0,"295":0,"296":0,"297":0,"298":0,"299":106,"300":0,"301":0,"302":105,"303":105,"304":0,"305":0,"306":0,"307":0,"308":0,"309":0,"310":0,"311":8,"312":97,"313":97,"314":97,"315":97,"316":40,"317":0,"318":95,"319":95,"320":4,"321":61,"322":6,"323":127,"324":55,"325":72,"326":70,"327":20,"328":20,"329":20,"330":51,"331":51,"332":49,"333":110,"334":42,"335":42,"336":54,"337":54,"338":42,"339":42,"340":7,"341":0,"342":41,"343":41,"344":56,"345":11,"346":92,"347":125,"348":12,"349":12,"350":37,"351":37,"352":37,"353":82,"354":85,"355":0,"356":0,"357":0,"358":0,"359":12,"360":12,"361":0,"362":0,"363":18,"364":18,"365":18,"366":52,"367":52,"368":89,"369":89,"370":89,"371":89,"372":89,"373":0,"374":0,"375":0,"376":0,"377":0,"378":26,"379":26,"380":26,"381":26,"382":0,"383":0,"384":0,"385":53,"386":53,"387":53,"388":53,"389":53,"390":0,"391":96,"392":96,"393":96,"394":96,"395":96,"396":31,"397":31,"398":31,"399":31,"400":31,"401":39,"402":39,"403":53,"404":75,"405":75,"406":75,"407":75,"408":75,"409":75,"410":75,"411":75,"412":75,"413":82,"414":82,"415":82,"416":82,"417":82,"418":29,"419":71,"420":71,"421":71,"422":27,"423":31,"424":0,"425":35,"426":5,"427":5,"428":5,"429":5,"430":0,"431":0,"432":0,"433":39,"434":0,"435":0,"436":0,"437":0,"438":0,"439":0,"440":0,"441":0,"442":0,"443":0,"444":0,"445":0,"446":0,"447":0,"448":0,"449":0,"450":0,"451":3,"452":0,"453":48,"454":48,"455":48,"456":48,"457":48,"458":72,"459":72,"460":0,"461":0,"462":0,"463":0,"464":0,"465":20,"466":20,"467":0,"468":0,"469":0,"470":39,"471":39,"472":28,"473":28,"474":28,"475":12,"476":54,"477":35,"478":4,"479":54,"480":54,"481":54,"482":0,"483":0,"484":0,"485":11,"486":11,"487":11,"488":38,"489":0,"490":15,"491":15,"492":15,"493":0,"494":0,"495":14,"496":0,"497":0,"498":0,"499":0,"500":22,"501":11,"502":11,"503":44,"504":49,"505":49,"506":49,"507":83,"508":0,"509":45,"510":0,"511":77,"512":28,"513":28,"514":5,"515":54,"516":26,"517":26,"518":26,"519":68,"520":20,"521":12,"522":11,"523":11,"524":11,"525":11,"526":47,"527":58,"528":6,"529":79,"530":0,"531":23,"532":23,"533":35,"534":0,"535":32,"536":32,"537":33,"538":41,"539":41,"540":0,"541":94,"542":94,"543":94,"544":38,"545":22,"546":12,"547":12,"548":12,"549":3,"550":3,"551":34,"552":0,"553":0,"554":22,"555":0,"556":0,"557":62,"558":0,"559":99,"560":99,"561":31,"562":31,"563":82,"564":82,"565":41,"566":31,"567":45,"568":45,"569":32,"570":32,"571":25,"572":28,"573":48,"574":92,"575":34,"576":32,"577":0,"578":0,"579":52,"580":33,"581":37,"582":37,"583":103,"584":103,"585":35,"586":27,"587":27,"588":27,"589":0,"590":0,"591":0,"592":0,"593":58,"594":58,"595":21,"596":0,"597":0,"598":2,"599":10,"600":10,"601":0,"602":0,"603":4,"604":4,"605":14,"606":0,"607":0,"608":0,"609":0,"610":28,"611":28,"612":59,"613":59,"614":28,"615":28,"616":28,"617":28,"618":18,"619":18,"620":18,"621":17,"622":17,"623":34,"624":34,"625":34,"626":34,"627":34,"628":0,"629":28,"630":31,"631":31,"632":31,"633":26,"634":26,"635":1,"636":0,"637":57,"638":57,"639":0,"640":0,"641":0,"642":0,"643":0,"644":0,"645":0,"646":0,"647":6,"648":35,"649":46,"650":46,"651":46,"652":0,"653":0,"654":11,"655":44,"656":9,"657":9,"658":9,"659":9,"660":9,"661":127,"662":127,"663":127,"664":127,"665":127,"666":127,"667":127,"668":127,"669":127,"670":103,"671":2,"672":2,"673":0,"674":0,"675":11,"676":39,"677":20,"678":20,"679":20,"680":84,"681":84,"682":84,"683":84,"684":0,"685":0,"686":0,"687":0,"688":37,"689":0,"690":37,"691":37,"692":37,"693":37,"694":37,"695":37,"696":37,"697":0,"698":0,"699":0,"700":0,"701":0,"702":0,"703":5,"704":0,"705":0,"706":0,"707":0,"708":0,"709":36,"710":36,"711":36,"712":36,"713":36,"714":13,"715":0,"716":0,"717":0,"718":14,"719":0,"720":0,"721":0,"722":50,"723":41,"724":102,"725":102,"726":102,"727":102,"728":0,"729":0,"730":0,"731":0,"732":0,"733":0,"734":0,"735":0,"736":0,"737":0,"738":0,"739":0,"740":0,"741":0,"742":0,"743":0,"744":0,"745":0,"746":0,"747":0,"748":81,"749":0,"750":25,"751":0,"752":18,"753":0,"754":7,"755":0,"756":0,"757":18,"758":36,"759":0,"760":0,"761":0,"762":0,"763":0,"764":53,"765":22,"766":5,"767":1,"768":0,"769":24,"770":20,"771":39,"772":0,"773":0,"774":39,"775":15,"776":31,"777":0,"778":0,"779":0,"780":31,"781":31,"782":31,"783":0,"784":0,"785":62,"786":62,"787":0,"788":0,"789":0,"790":46,"791":46,"792":13,"793":11,"794":2,"795":2,"796":2,"797":2,"798":2,"799":0,"800":2,"801":7,"802":2,"803":2,"804":24,"805":2,"806":2,"807":2,"808":5,"809":2,"810":0,"811":2,"812":2,"813":2,"814":2,"815":2,"816":2,"817":2,"818":2,"819":2,"820":2,"821":2,"822":2,"823":13,"824":2,"825":20,"826":0,"827":2,"828":2,"829":0,"830":2,"831":0,"832":0,"833":25,"834":2,"835":2,"836":2,"837":44,"838":0,"839":42,"840":3,"841":57,"842":57,"843":57,"844":57,"845":57,"846":42,"847":0,"848":0,"849":0,"850":4,"851":4,"852":23,"853":28,"854":28,"855":25,"856":25,"857":2,"858":2,"859":2,"860":42,"861":0,"862":35,"863":25,"864":25,"865":0,"866":59,"867":59,"868":59,"869":19,"870":11,"871":2,"872":12,"873":13,"874":13,"875":13,"876":6,"877":0,"878":0,"879":0,"880":0,"881":0,"882":131,"883":2,"884":39,"885":12,"886":0,"887":167,"888":0,"889":37,"890":62,"891":0,"892":117,"893":47,"894":0,"895":0,"896":0,"897":3,"898":0,"899":0,"900":0,"901":0,"902":0,"903":0,"904":0,"905":15,"906":15,"907":114,"908":21,"909":21,"910":21,"911":15,"912":13,"913":2,"914":2,"915":22,"916":22,"917":22,"918":72,"919":14,"920":141,"921":48,"922":0,"923":0,"924":0,"925":16,"926":10,"927":22,"928":22,"929":121,"930":40,"931":40,"932":74,"933":115,"934":0,"935":0,"936":52,"937":0,"938":8,"939":8,"940":105,"941":105,"942":105,"943":105,"944":0,"945":0,"946":32,"947":0,"948":0,"949":31,"950":31,"951":0,"952":20,"953":184,"954":131,"955":184,"956":0,"957":0,"958":0,"959":0,"960":37,"961":37,"962":37,"963":0,"964":0,"965":11,"966":4,"967":4,"968":9,"969":31,"970":61,"971":57,"972":109,"973":120,"974":120,"975":120,"976":16,"977":22,"978":22,"979":22,"980":57,"981":57,"982":57,"983":57,"984":57,"985":60,"986":60,"987":60,"988":60,"989":60,"990":60,"991":60,"992":0,"993":0,"994":0,"995":0,"996":4,"997":10,"998":10,"999":4,"1000":0,"1001":0,"1002":4,"1003":0,"1004":22,"1005":22,"1006":71,"1007":4,"1008":4,"1009":0,"1010":6,"1011":183,"1012":2,"1013":62,"1014":0,"1015":0,"1016":0,"1017":0,"1018":0,"1019":0,"1020":5,"1021":20,"1022":20,"1023":0,"1024":10,"1025":15,"1026":0,"1027":18,"1028":0,"1029":97,"1030":44,"1031":28,"1032":42,"1033":42,"1034":35,"1035":47,"1036":47,"1037":47,"1038":98,"1039":98,"1040":106,"1041":54,"1042":4,"1043":38,"1044":22,"1045":60,"1046":60,"1047":0,"1048":35,"1049":35,"1050":14,"1051":14,"1052":183,"1053":183,"1054":0,"1055":0,"1056":0,"1057":32,"1058":28,"1059":0,"1060":0,"1061":32,"1062":32,"1063":40,"1064":5,"1065":32,"1066":32,"1067":96,"1068":138,"1069":138,"1070":2,"1071":2,"1072":21,"1073":21,"1074":21,"1075":21,"1076":21,"1077":21,"1078":82,"1079":0,"1080":138,"1081":138,"1082":72,"1083":72,"1084":6,"1085":64,"1086":6,"1087":62,"1088":6,"1089":6,"1090":6,"1091":6,"1092":36,"1093":36,"1094":198,"1095":14,"1096":0,"1097":100,"1098":2,"1099":2,"1100":2,"1101":2,"1102":82,"1103":82,"1104":82,"1105":2,"1106":2,"1107":2,"1108":2,"1109":0,"1110":23,"1111":23,"1112":23,"1113":23,"1114":23,"1115":23,"1116":23,"1117":23,"1118":23,"1119":23,"1120":23,"1121":2,"1122":133,"1123":133,"1124":108,"1125":67,"1126":0,"1127":0,"1128":0,"1129":77,"1130":0,"1131":6,"1132":6,"1133":103,"1134":88,"1135":84,"1136":109,"1137":111,"1138":111,"1139":6,"1140":6,"1141":6,"1142":82,"1143":0,"1144":105,"1145":87,"1146":87,"1147":87,"1148":0,"1149":20,"1150":0,"1151":0,"1152":0,"1153":143,"1154":143,"1155":0,"1156":84,"1157":82,"1158":82,"1159":44,"1160":24,"1161":0,"1162":0,"1163":37,"1164":113,"1165":113,"1166":2,"1167":88,"1168":84,"1169":102,"1170":102,"1171":102,"1172":97,"1173":100,"1174":100,"1175":84,"1176":121,"1177":121,"1178":27,"1179":27,"1180":109,"1181":109,"1182":82,"1183":134,"1184":46,"1185":54,"1186":139,"1187":27,"1188":27,"1189":117,"1190":117,"1191":117,"1192":117,"1193":31,"1194":38,"1195":86,"1196":126,"1197":126,"1198":14,"1199":9,"1200":66,"1201":2,"1202":21,"1203":84,"1204":84,"1205":99,"1206":99,"1207":103,"1208":31,"1209":21,"1210":115,"1211":82,"1212":82,"1213":82,"1214":86,"1215":86,"1216":86,"1217":86,"1218":86,"1219":86,"1220":82,"1221":97,"1222":97,"1223":18,"1224":79,"1225":102,"1226":102,"1227":89,"1228":89,"1229":89,"1230":85,"1231":0,"1232":0,"1233":123,"1234":123,"1235":124,"1236":61,"1237":106,"1238":33,"1239":151,"1240":128,"1241":101,"1242":101},"globals":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0,"50":0,"51":0,"52":0,"53":0,"54":0,"55":0,"56":0,"57":0,"58":0,"59":0,"60":0,"61":0,"62":0,"63":0,"64":0,"65":0,"66":0,"67":0,"68":0,"69":0,"70":0,"71":0,"72":0,"73":0,"74":0,"75":0,"76":0,"77":0,"78":0,"79":0,"80":0,"81":0,"82":0,"83":0,"84":0,"85":0,"86":0,"87":0,"88":0,"89":0,"90":0,"91":0,"92":0,"93":0,"94":0,"95":0,"96":0,"97":0,"98":0,"99":0,"100":0,"101":0,"102":0,"103":0,"104":0,"105":0,"106":0,"107":0,"108":0,"109":0,"110":0,"111":0,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":0,"120":0,"121":0,"122":0,"123":0,"124":0,"125":0,"126":0,"127":0,"128":0,"129":0,"130":0,"131":0,"132":0,"133":0,"134":0,"135":0,"136":0,"137":0,"138":0,"139":0,"140":0,"141":0,"142":0,"143":0,"144":0,"145":0,"146":0,"147":0,"148":0,"149":0,"150":0,"151":0,"152":0,"153":0,"154":0,"155":0,"156":0,"157":0,"158":0,"159":0,"160":0,"161":0,"162":0,"163":0,"164":0,"165":0,"166":0,"167":0,"168":0,"169":0,"170":0,"171":0,"172":0,"173":0,"174":0,"175":0,"176":0,"177":0,"178":0,"179":0,"180":0,"181":0,"182":0,"183":0,"184":0,"185":0,"186":0,"187":0,"188":0,"189":0,"190":0,"191":0,"192":0,"193":0,"194":0,"195":0,"196":0,"197":0,"198":0,"199":0,"200":0,"201":0,"202":0,"203":0,"204":0,"205":0,"206":0,"207":0,"208":0,"209":0,"210":0,"211":0,"212":0,"213":0,"214":0,"215":0,"216":0,"217":0,"218":0,"219":0,"220":0,"221":0,"222":0,"223":0,"224":0,"225":0,"226":0,"227":0,"228":0,"229":0,"230":0,"231":0,"232":0,"233":0,"234":0,"235":0,"236":0,"237":0,"238":0,"239":0,"240":0,"241":0,"242":0,"243":0,"244":0,"245":0,"246":0,"247":0,"248":0,"249":0,"250":0,"251":0,"252":0,"253":0,"254":0,"255":0,"256":0,"257":0,"258":0,"259":0,"260":0,"261":0,"262":0,"263":0,"264":0,"265":0,"266":0,"267":0,"268":0,"269":0,"270":0,"271":0,"272":0,"273":0,"274":0,"275":0,"276":0,"277":0,"278":0,"279":0,"280":0,"281":0,"282":0,"283":0,"284":0,"285":0,"286":0,"287":0,"288":0,"289":0,"290":0,"291":0,"292":0,"293":0,"294":0,"295":0,"296":0,"297":0,"298":0,"299":0,"300":0,"301":0,"302":0,"303":0,"304":0,"305":0,"306":0,"307":0,"308":0,"309":0,"310":0,"311":0,"312":0,"313":0,"314":0,"315":0,"316":0,"317":0,"318":0,"319":0,"320":0,"321":0,"322":0,"323":0,"324":0,"325":0,"326":0,"327":0,"328":0,"329":0,"330":0,"331":0,"332":0,"333":0,"334":0,"335":0,"336":0,"337":0,"338":0,"339":0,"340":0,"341":0,"342":0,"343":0,"344":0,"345":0,"346":0,"347":0,"348":0,"349":0,"350":0,"351":0,"352":0,"353":0,"354":0,"355":0,"356":0,"357":0,"358":0,"359":0,"360":0,"361":0,"362":0,"363":0,"364":0,"365":0,"366":0,"367":0,"368":0,"369":0,"370":0,"371":0,"372":0,"373":0,"374":0,"375":0,"376":0,"377":0,"378":0,"379":0,"380":0,"381":0,"382":0,"383":0,"384":0,"385":0,"386":0,"387":0,"388":0,"389":0,"390":0,"391":0,"392":0,"393":0,"394":0,"395":0,"396":0,"397":0,"398":0,"399":0,"400":0,"401":0,"402":0,"403":0,"404":0,"405":0,"406":0,"407":0,"408":0,"409":0,"410":0,"411":0,"412":0,"413":0,"414":0,"415":0,"416":0,"417":0,"418":0,"419":0,"420":0,"421":0,"422":0,"423":0,"424":0,"425":0,"426":0,"427":0,"428":0,"429":0,"430":0,"431":0,"432":0,"433":0,"434":0,"435":0,"436":0,"437":0,"438":0,"439":0,"440":0,"441":0,"442":0,"443":0,"444":0,"445":0,"446":0,"447":0,"448":0,"449":0,"450":0,"451":0,"452":0,"453":0,"454":0,"455":0,"456":0,"457":0,"458":0,"459":0,"460":0,"461":0,"462":0,"463":0,"464":0,"465":0,"466":0,"467":0,"468":0,"469":0,"470":0,"471":0,"472":0,"473":0,"474":0,"475":0,"476":0,"477":0,"478":0,"479":0,"480":0,"481":0,"482":0,"483":0,"484":0,"485":0,"486":0,"487":0,"488":0,"489":0,"490":0,"491":0,"492":0,"493":0,"494":0,"495":0,"496":0,"497":0,"498":0,"499":0,"500":0,"501":0,"502":0,"503":0,"504":0,"505":0,"506":0,"507":0,"508":0,"509":0,"510":0,"511":0,"512":0,"513":0,"514":0,"515":0,"516":0,"517":0,"518":0,"519":0,"520":0,"521":0,"522":0,"523":0,"524":0,"525":0,"526":0,"527":0,"528":0,"529":0,"530":0,"531":0,"532":0,"533":0,"534":0,"535":0,"536":0,"537":0,"538":0,"539":0,"540":0,"541":0,"542":0,"543":0,"544":0,"545":0,"546":0,"547":0,"548":0,"549":0,"550":0,"551":0,"552":0,"553":0,"554":0,"555":0,"556":0,"557":0,"558":0,"559":0,"560":0,"561":0,"562":0,"563":0,"564":0,"565":0,"566":0,"567":0,"568":0,"569":0,"570":0,"571":0,"572":0,"573":0,"574":0,"575":0,"576":0,"577":0,"578":0,"579":0,"580":0,"581":0,"582":0,"583":0,"584":0,"585":0,"586":0,"587":0,"588":0,"589":0,"590":0,"591":0,"592":0,"593":0,"594":0,"595":0,"596":0,"597":0,"598":0,"599":0,"600":0,"601":0,"602":0,"603":0,"604":0,"605":0,"606":0,"607":0,"608":0,"609":0,"610":0,"611":0,"612":0,"613":0,"614":0,"615":0,"616":0,"617":0,"618":0,"619":0,"620":0,"621":0,"622":0,"623":0,"624":0,"625":0,"626":0,"627":0,"628":0,"629":0,"630":0,"631":0,"632":0,"633":0,"634":0,"635":0,"636":0,"637":0,"638":0,"639":0,"640":0,"641":0,"642":0,"643":0,"644":0,"645":0,"646":0,"647":0,"648":0,"649":0,"650":0,"651":0,"652":0,"653":0,"654":0,"655":0,"656":0,"657":0,"658":0,"659":0,"660":0,"661":0,"662":0,"663":0,"664":0,"665":0,"666":0,"667":0,"668":0,"669":0,"670":0,"671":0,"672":0,"673":0,"674":0,"675":0,"676":0,"677":0,"678":0,"679":0,"680":0,"681":0,"682":0,"683":0,"684":0,"685":0,"686":0,"687":0,"688":0,"689":0,"690":0,"691":0,"692":0,"693":0,"694":0,"695":0,"696":0,"697":0,"698":0,"699":0,"700":0,"701":0,"702":0,"703":0,"704":0,"705":0,"706":0,"707":0,"708":0,"709":0,"710":0,"711":0,"712":0,"713":0,"714":0,"715":0,"716":0,"717":0,"718":0,"719":0,"720":0,"721":0,"722":0,"723":0,"724":0,"725":0,"726":0,"727":0,"728":0,"729":0,"730":0,"731":0,"732":0,"733":0,"734":0,"735":0,"736":0,"737":0,"738":0,"739":0,"740":0,"741":0,"742":0,"743":0,"744":0,"745":0,"746":0,"747":0,"748":0,"749":0,"750":0,"751":0,"752":0,"753":0,"754":0,"755":0,"756":0,"757":0,"758":0,"759":0,"760":0,"761":0,"762":0,"763":0,"764":0,"765":0,"766":0,"767":0,"768":0,"769":0,"770":0,"771":0,"772":0,"773":0,"774":0,"775":0,"776":0,"777":0,"778":0,"779":0,"780":0,"781":0,"782":0,"783":0,"784":0,"785":0,"786":0,"787":0,"788":0,"789":0,"790":0,"791":0,"792":0,"793":0,"794":0,"795":0,"796":0,"797":0,"798":0,"799":0,"800":0,"801":0,"802":0,"803":0,"804":0,"805":0,"806":0,"807":0,"808":0,"809":0,"810":0,"811":0,"812":0,"813":0,"814":0,"815":0,"816":0,"817":0,"818":0,"819":0,"820":0,"821":0,"822":0,"823":0,"824":0,"825":0,"826":0,"827":0,"828":0,"829":0,"830":0,"831":0,"832":0,"833":0,"834":0,"835":0,"836":0,"837":0,"838":0,"839":0,"840":0,"841":0,"842":0,"843":0,"844":0,"845":0,"846":0,"847":0,"848":0,"849":0,"850":0,"851":0,"852":0,"853":0,"854":0,"855":0,"856":0,"857":0,"858":0,"859":0,"860":0,"861":0,"862":0,"863":0,"864":0,"865":0,"866":0,"867":0,"868":0,"869":0,"870":0,"871":0,"872":0,"873":0,"874":0,"875":0,"876":0,"877":0,"878":0,"879":0,"880":0,"881":0,"882":0,"883":0,"884":0,"885":0,"886":0,"887":0,"888":0,"889":0,"890":0,"891":0,"892":0,"893":0,"894":0,"895":0,"896":0,"897":0,"898":0,"899":0,"900":0,"901":0,"902":0,"903":0,"904":0,"905":0,"906":0,"907":0,"908":0,"909":0,"910":0,"911":0,"912":0,"913":0,"914":0,"915":0,"916":0,"917":0,"918":0,"919":0,"920":0,"921":0,"922":0,"923":0,"924":0,"925":0,"926":0,"927":0,"928":0,"929":0,"930":0,"931":0,"932":0,"933":0,"934":0,"935":0,"936":0,"937":0,"938":0,"939":0,"940":0,"941":0,"942":0,"943":0,"944":0,"945":0,"946":0,"947":0,"948":0,"949":0,"950":0,"951":0,"952":0,"953":0,"954":0,"955":0,"956":0,"957":0,"958":0,"959":0,"960":0,"961":0,"962":0,"963":0,"964":0,"965":0,"966":0,"967":0,"968":0,"969":0,"970":0,"971":0,"972":0,"973":0,"974":0,"975":0,"976":0,"977":0,"978":0,"979":0,"980":0,"981":0,"982":0,"983":0,"984":0,"985":0,"986":0,"987":0,"988":0,"989":0,"990":0,"991":0,"992":0,"993":0,"994":0,"995":0,"996":0,"997":0,"998":0,"999":0,"1000":0,"1001":0,"1002":0,"1003":0,"1004":0,"1005":0,"1006":0,"1007":0,"1008":0,"1009":0,"1010":0,"1011":0,"1012":0,"1013":0,"1014":0,"1015":0,"1016":0,"1017":0,"1018":0,"1019":0,"1020":0,"1021":0,"1022":0,"1023":0,"1024":0,"1025":0,"1026":0,"1027":0,"1028":0,"1029":0,"1030":0,"1031":0,"1032":0,"1033":0,"1034":0,"1035":0,"1036":0,"1037":0,"1038":0,"1039":0,"1040":0,"1041":0,"1042":0,"1043":0,"1044":0,"1045":0,"1046":0,"1047":0,"1048":0,"1049":0,"1050":0,"1051":0,"1052":0,"1053":0,"1054":0,"1055":0,"1056":0,"1057":0,"1058":0,"1059":0,"1060":0,"1061":0,"1062":0,"1063":0,"1064":0,"1065":0,"1066":0,"1067":0,"1068":0,"1069":0,"1070":0,"1071":0,"1072":0,"1073":0,"1074":0,"1075":0,"1076":0,"1077":0,"1078":0,"1079":0,"1080":0,"1081":0,"1082":0,"1083":0,"1084":0,"1085":0,"1086":0,"1087":0,"1088":0,"1089":0,"1090":0,"1091":0,"1092":0,"1093":0,"1094":0,"1095":0,"1096":0,"1097":0,"1098":0,"1099":0,"1100":0,"1101":0,"1102":0,"1103":0,"1104":0,"1105":0,"1106":0,"1107":0,"1108":0,"1109":0,"1110":0,"1111":0,"1112":0,"1113":0,"1114":0,"1115":0,"1116":0,"1117":0,"1118":0,"1119":0,"1120":0,"1121":0,"1122":0,"1123":0,"1124":0,"1125":0,"1126":0,"1127":0,"1128":0,"1129":0,"1130":0,"1131":0,"1132":0,"1133":0,"1134":0,"1135":0,"1136":0,"1137":0,"1138":0,"1139":0,"1140":0,"1141":0,"1142":0,"1143":0,"1144":0,"1145":0,"1146":0,"1147":0,"1148":0,"1149":0,"1150":0,"1151":0,"1152":0,"1153":0,"1154":0,"1155":0,"1156":0,"1157":0,"1158":0,"1159":0,"1160":0,"1161":0,"1162":0,"1163":0,"1164":0,"1165":0,"1166":0,"1167":0,"1168":0,"1169":0,"1170":0,"1171":0,"1172":0,"1173":0,"1174":0,"1175":0,"1176":0,"1177":0,"1178":0,"1179":0,"1180":0,"1181":0,"1182":0,"1183":0,"1184":0,"1185":0,"1186":0,"1187":0,"1188":0,"1189":0,"1190":0,"1191":0,"1192":0,"1193":0,"1194":0,"1195":0,"1196":0,"1197":0,"1198":0,"1199":0,"1200":0,"1201":0,"1202":0,"1203":0,"1204":0,"1205":0,"1206":0,"1207":0,"1208":0,"1209":0,"1210":0,"1211":0,"1212":0,"1213":0,"1214":0,"1215":0,"1216":0,"1217":0,"1218":0,"1219":0,"1220":0,"1221":0,"1222":0,"1223":0,"1224":0,"1225":0,"1226":0,"1227":0,"1228":0,"1229":0,"1230":0,"1231":0,"1232":0,"1233":0,"1234":0,"1235":0,"1236":0,"1237":0,"1238":0,"1239":0,"1240":0,"1241":0,"1242":0},"imports":{"0":2,"1":4,"2":4,"3":4,"4":4,"5":2,"6":8,"7":8,"8":8,"9":2,"10":2,"11":2,"12":2,"13":0,"14":0,"15":0,"16":0,"17":0,"18":1,"19":8,"20":8,"21":9,"22":10,"23":2,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":0,"34":8,"35":1,"36":2,"37":4,"38":2,"39":2,"40":12,"41":12,"42":19,"43":11,"44":11,"45":0,"46":2,"47":5,"48":5,"49":5,"50":5,"51":5,"52":1,"53":3,"54":3,"55":1,"56":1,"57":2,"58":2,"59":0,"60":0,"61":4,"62":1,"63":1,"64":3,"65":1,"66":1,"67":1,"68":1,"69":0,"70":2,"71":9,"72":3,"73":3,"74":0,"75":0,"76":4,"77":1,"78":15,"79":15,"80":9,"81":3,"82":5,"83":4,"84":38,"85":12,"86":14,"87":14,"88":6,"89":29,"90":3,"91":14,"92":4,"93":0,"94":0,"95":0,"96":0,"97":0,"98":0,"99":0,"100":0,"101":0,"102":0,"103":0,"104":0,"105":1,"106":1,"107":3,"108":3,"109":3,"110":2,"111":2,"112":0,"113":0,"114":0,"115":0,"116":0,"117":0,"118":0,"119":0,"120":0,"121":0,"122":0,"123":0,"124":1,"125":1,"126":1,"127":0,"128":5,"129":3,"130":4,"131":4,"132":3,"133":3,"134":1,"135":1,"136":2,"137":2,"138":2,"139":2,"140":3,"141":1,"142":2,"143":2,"144":2,"145":3,"146":3,"147":3,"148":1,"149":2,"150":3,"151":3,"152":2,"153":1,"154":1,"155":1,"156":1,"157":1,"158":3,"159":2,"160":0,"161":12,"162":5,"163":5,"164":5,"165":2,"166":3,"167":3,"168":6,"169":11,"170":3,"171":3,"172":3,"173":3,"174":3,"175":2,"176":5,"177":2,"178":1,"179":1,"180":0,"181":0,"182":1,"183":1,"184":1,"185":1,"186":1,"187":1,"188":1,"189":1,"190":1,"191":1,"192":0,"193":0,"194":3,"195":3,"196":0,"197":0,"198":0,"199":0,"200":0,"201":0,"202":3,"203":3,"204":6,"205":6,"206":1,"207":1,"208":2,"209":0,"210":0,"211":0,"212":0,"213":0,"214":0,"215":1,"216":1,"217":1,"218":1,"219":3,"220":3,"221":0,"222":0,"223":0,"224":0,"225":0,"226":2,"227":2,"228":2,"229":2,"230":2,"231":3,"232":4,"233":4,"234":4,"235":4,"236":4,"237":4,"238":2,"239":2,"240":2,"241":2,"242":2,"243":0,"244":6,"245":6,"246":0,"247":0,"248":0,"249":9,"250":19,"251":12,"252":12,"253":12,"254":5,"255":7,"256":3,"257":3,"258":0,"259":15,"260":12,"261":12,"262":3,"263":1,"264":2,"265":0,"266":0,"267":0,"268":0,"269":0,"270":0,"271":0,"272":0,"273":0,"274":0,"275":0,"276":0,"277":0,"278":0,"279":0,"280":0,"281":0,"282":0,"283":17,"284":17,"285":17,"286":11,"287":1,"288":7,"289":7,"290":1,"291":4,"292":2,"293":2,"294":2,"295":2,"296":0,"297":0,"298":12,"299":12,"300":16,"301":0,"302":0,"303":0,"304":0,"305":0,"306":0,"307":0,"308":0,"309":0,"310":0,"311":3,"312":9,"313":9,"314":9,"315":9,"316":4,"317":11,"318":13,"319":13,"320":6,"321":0,"322":2,"323":3,"324":1,"325":12,"326":1,"327":4,"328":4,"329":4,"330":3,"331":3,"332":7,"333":9,"334":8,"335":8,"336":1,"337":1,"338":9,"339":9,"340":2,"341":1,"342":1,"343":1,"344":1,"345":5,"346":1,"347":1,"348":3,"349":3,"350":0,"351":0,"352":0,"353":1,"354":2,"355":6,"356":4,"357":6,"358":6,"359":3,"360":3,"361":2,"362":1,"363":18,"364":18,"365":18,"366":12,"367":12,"368":15,"369":15,"370":15,"371":15,"372":15,"373":0,"374":0,"375":0,"376":0,"377":0,"378":0,"379":0,"380":0,"381":0,"382":4,"383":4,"384":4,"385":5,"386":5,"387":5,"388":5,"389":5,"390":5,"391":2,"392":2,"393":2,"394":2,"395":2,"396":13,"397":13,"398":13,"399":13,"400":13,"401":11,"402":11,"403":0,"404":0,"405":0,"406":0,"407":0,"408":0,"409":0,"410":0,"411":0,"412":0,"413":7,"414":7,"415":7,"416":7,"417":7,"418":5,"419":1,"420":1,"421":1,"422":1,"423":1,"424":1,"425":2,"426":3,"427":3,"428":3,"429":3,"430":0,"431":0,"432":0,"433":4,"434":3,"435":3,"436":3,"437":3,"438":3,"439":3,"440":3,"441":3,"442":3,"443":3,"444":3,"445":3,"446":3,"447":3,"448":3,"449":3,"450":0,"451":0,"452":8,"453":2,"454":2,"455":2,"456":2,"457":2,"458":4,"459":4,"460":2,"461":1,"462":1,"463":1,"464":1,"465":0,"466":0,"467":1,"468":1,"469":1,"470":1,"471":1,"472":8,"473":8,"474":8,"475":5,"476":4,"477":3,"478":3,"479":0,"480":0,"481":0,"482":1,"483":2,"484":1,"485":1,"486":0,"487":0,"488":0,"489":5,"490":3,"491":3,"492":3,"493":2,"494":2,"495":7,"496":5,"497":4,"498":2,"499":2,"500":5,"501":3,"502":0,"503":8,"504":0,"505":0,"506":0,"507":0,"508":0,"509":2,"510":3,"511":7,"512":3,"513":3,"514":2,"515":1,"516":2,"517":2,"518":2,"519":1,"520":1,"521":5,"522":5,"523":5,"524":5,"525":5,"526":1,"527":3,"528":4,"529":2,"530":3,"531":4,"532":4,"533":3,"534":5,"535":6,"536":6,"537":6,"538":3,"539":3,"540":1,"541":10,"542":10,"543":10,"544":12,"545":2,"546":2,"547":2,"548":2,"549":2,"550":2,"551":1,"552":4,"553":16,"554":5,"555":11,"556":6,"557":12,"558":3,"559":20,"560":20,"561":7,"562":7,"563":8,"564":8,"565":2,"566":5,"567":13,"568":13,"569":4,"570":4,"571":2,"572":2,"573":5,"574":4,"575":4,"576":6,"577":11,"578":11,"579":13,"580":2,"581":15,"582":15,"583":3,"584":3,"585":8,"586":0,"587":0,"588":0,"589":2,"590":2,"591":2,"592":2,"593":8,"594":8,"595":11,"596":1,"597":2,"598":3,"599":1,"600":1,"601":1,"602":0,"603":3,"604":7,"605":2,"606":6,"607":6,"608":6,"609":6,"610":1,"611":1,"612":5,"613":5,"614":11,"615":16,"616":16,"617":16,"618":10,"619":10,"620":10,"621":3,"622":3,"623":6,"624":6,"625":6,"626":6,"627":6,"628":9,"629":13,"630":2,"631":2,"632":2,"633":15,"634":15,"635":1,"636":8,"637":6,"638":6,"639":2,"640":2,"641":2,"642":2,"643":2,"644":3,"645":3,"646":3,"647":2,"648":18,"649":20,"650":20,"651":20,"652":5,"653":4,"654":7,"655":6,"656":6,"657":6,"658":6,"659":6,"660":6,"661":2,"662":2,"663":2,"664":2,"665":2,"666":2,"667":2,"668":2,"669":2,"670":6,"671":11,"672":0,"673":1,"674":3,"675":8,"676":7,"677":6,"678":6,"679":6,"680":5,"681":5,"682":4,"683":0,"684":3,"685":3,"686":9,"687":9,"688":1,"689":0,"690":4,"691":4,"692":4,"693":4,"694":4,"695":4,"696":4,"697":6,"698":6,"699":6,"700":6,"701":6,"702":6,"703":3,"704":12,"705":4,"706":22,"707":19,"708":19,"709":22,"710":22,"711":22,"712":22,"713":22,"714":1,"715":7,"716":7,"717":2,"718":5,"719":1,"720":3,"721":3,"722":11,"723":6,"724":16,"725":16,"726":16,"727":16,"728":20,"729":19,"730":14,"731":14,"732":14,"733":14,"734":14,"735":14,"736":14,"737":14,"738":14,"739":14,"740":14,"741":14,"742":14,"743":14,"744":11,"745":11,"746":3,"747":3,"748":20,"749":19,"750":7,"751":4,"752":6,"753":13,"754":9,"755":11,"756":11,"757":3,"758":3,"759":10,"760":10,"761":10,"762":10,"763":10,"764":29,"765":0,"766":3,"767":8,"768":0,"769":9,"770":3,"771":7,"772":10,"773":4,"774":4,"775":8,"776":5,"777":5,"778":5,"779":5,"780":4,"781":4,"782":4,"783":2,"784":2,"785":12,"786":12,"787":4,"788":4,"789":2,"790":15,"791":15,"792":0,"793":4,"794":0,"795":0,"796":0,"797":0,"798":13,"799":3,"800":4,"801":2,"802":6,"803":4,"804":7,"805":4,"806":7,"807":6,"808":12,"809":4,"810":0,"811":7,"812":7,"813":7,"814":7,"815":7,"816":7,"817":7,"818":7,"819":7,"820":7,"821":7,"822":7,"823":10,"824":0,"825":3,"826":1,"827":1,"828":1,"829":2,"830":0,"831":2,"832":3,"833":12,"834":7,"835":5,"836":7,"837":1,"838":2,"839":0,"840":0,"841":26,"842":26,"843":26,"844":26,"845":26,"846":1,"847":7,"848":4,"849":1,"850":3,"851":3,"852":5,"853":15,"854":15,"855":4,"856":1,"857":1,"858":3,"859":3,"860":7,"861":4,"862":7,"863":13,"864":13,"865":1,"866":1,"867":1,"868":1,"869":8,"870":4,"871":0,"872":0,"873":4,"874":1,"875":1,"876":9,"877":13,"878":0,"879":2,"880":3,"881":3,"882":2,"883":2,"884":3,"885":4,"886":3,"887":2,"888":3,"889":4,"890":4,"891":1,"892":1,"893":0,"894":0,"895":0,"896":17,"897":4,"898":4,"899":14,"900":5,"901":5,"902":5,"903":5,"904":5,"905":4,"906":4,"907":8,"908":2,"909":2,"910":4,"911":0,"912":1,"913":1,"914":1,"915":4,"916":4,"917":4,"918":0,"919":4,"920":0,"921":10,"922":13,"923":9,"924":8,"925":0,"926":2,"927":14,"928":14,"929":5,"930":1,"931":1,"932":9,"933":12,"934":5,"935":7,"936":7,"937":2,"938":1,"939":1,"940":13,"941":13,"942":13,"943":13,"944":5,"945":5,"946":9,"947":2,"948":2,"949":8,"950":8,"951":0,"952":6,"953":0,"954":2,"955":0,"956":13,"957":13,"958":13,"959":13,"960":13,"961":13,"962":13,"963":11,"964":11,"965":11,"966":13,"967":13,"968":3,"969":1,"970":13,"971":4,"972":11,"973":14,"974":14,"975":14,"976":6,"977":4,"978":4,"979":2,"980":8,"981":8,"982":8,"983":8,"984":8,"985":45,"986":45,"987":45,"988":45,"989":45,"990":45,"991":45,"992":1,"993":1,"994":1,"995":10,"996":3,"997":5,"998":5,"999":10,"1000":8,"1001":0,"1002":4,"1003":17,"1004":1,"1005":1,"1006":0,"1007":3,"1008":3,"1009":3,"1010":7,"1011":0,"1012":7,"1013":5,"1014":14,"1015":14,"1016":14,"1017":14,"1018":14,"1019":14,"1020":1,"1021":10,"1022":2,"1023":3,"1024":1,"1025":0,"1026":0,"1027":0,"1028":1,"1029":1,"1030":3,"1031":6,"1032":2,"1033":2,"1034":3,"1035":9,"1036":9,"1037":9,"1038":2,"1039":2,"1040":0,"1041":8,"1042":5,"1043":0,"1044":5,"1045":13,"1046":13,"1047":1,"1048":2,"1049":2,"1050":8,"1051":8,"1052":0,"1053":0,"1054":0,"1055":0,"1056":0,"1057":0,"1058":3,"1059":5,"1060":8,"1061":2,"1062":2,"1063":12,"1064":7,"1065":4,"1066":4,"1067":0,"1068":0,"1069":0,"1070":3,"1071":1,"1072":5,"1073":5,"1074":5,"1075":5,"1076":5,"1077":5,"1078":0,"1079":0,"1080":0,"1081":0,"1082":7,"1083":7,"1084":1,"1085":7,"1086":12,"1087":14,"1088":7,"1089":7,"1090":7,"1091":7,"1092":4,"1093":4,"1094":5,"1095":0,"1096":0,"1097":4,"1098":2,"1099":2,"1100":6,"1101":6,"1102":0,"1103":0,"1104":2,"1105":4,"1106":4,"1107":4,"1108":4,"1109":0,"1110":17,"1111":17,"1112":17,"1113":17,"1114":17,"1115":17,"1116":17,"1117":17,"1118":17,"1119":17,"1120":17,"1121":0,"1122":1,"1123":1,"1124":0,"1125":1,"1126":3,"1127":5,"1128":5,"1129":0,"1130":1,"1131":1,"1132":1,"1133":3,"1134":1,"1135":6,"1136":3,"1137":2,"1138":2,"1139":5,"1140":6,"1141":6,"1142":2,"1143":0,"1144":3,"1145":4,"1146":4,"1147":4,"1148":2,"1149":1,"1150":5,"1151":3,"1152":5,"1153":0,"1154":0,"1155":3,"1156":11,"1157":1,"1158":1,"1159":1,"1160":0,"1161":0,"1162":0,"1163":1,"1164":1,"1165":1,"1166":0,"1167":1,"1168":7,"1169":9,"1170":9,"1171":9,"1172":1,"1173":4,"1174":4,"1175":2,"1176":4,"1177":4,"1178":4,"1179":4,"1180":5,"1181":5,"1182":1,"1183":0,"1184":0,"1185":1,"1186":1,"1187":0,"1188":0,"1189":1,"1190":1,"1191":1,"1192":1,"1193":0,"1194":4,"1195":2,"1196":5,"1197":5,"1198":2,"1199":3,"1200":1,"1201":0,"1202":3,"1203":3,"1204":3,"1205":6,"1206":6,"1207":4,"1208":1,"1209":1,"1210":2,"1211":1,"1212":1,"1213":0,"1214":6,"1215":6,"1216":6,"1217":6,"1218":6,"1219":6,"1220":3,"1221":4,"1222":4,"1223":0,"1224":0,"1225":2,"1226":2,"1227":4,"1228":4,"1229":4,"1230":2,"1231":5,"1232":0,"1233":4,"1234":4,"1235":2,"1236":1,"1237":8,"1238":5,"1239":3,"1240":4,"1241":2,"1242":2}}