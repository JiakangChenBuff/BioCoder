{"golden":{"0":"\/**\n * An estimate to the root from zeroin C implementation\n *\n * @param ax  Left border of the range\n * @param bx  Right border the root is seeked\n * @param f   Function under investigation\n * @param tol Acceptable tolerance\n * @return root\n *\/\npublic static double zeroinC(double ax, double bx, Function<Double, Double> f, double tol) {\n    double a, b, c;\n    \/* Abscissae, descr. see above\t*\/\n    double fa;\n    \/* f(a)\t\t\t\t*\/\n    double fb;\n    \/* f(b)\t\t\t\t*\/\n    double fc;\n    \/* f(c)\t\t\t\t*\/\n    double EPSILON = Math.ulp(1.0);\n    a = ax;\n    b = bx;\n    fa = f.apply(a);\n    fb = f.apply(b);\n    c = a;\n    fc = fa;\n    \/* Main iteration loop\t*\/\n    for (; ; ) {\n        double prev_step = b - a;\n        \/* Distance from the last but one to the last approximation\t*\/\n        double tol_act;\n        \/* Actual tolerance\t\t*\/\n        double p;\n        \/* Interpolation step is calculated in the form p\/q; division operations is delayed until the last moment *\/\n        double q;\n        double new_step;\n        \/* Step at this iteration *\/\n        \/* Swap data for b to be the best approximation\t*\/\n        if (Math.abs(fc) < Math.abs(fb)) {\n            a = b;\n            b = c;\n            c = a;\n            fa = fb;\n            fb = fc;\n            fc = fa;\n        }\n        tol_act = 2 * EPSILON * Math.abs(b) + tol \/ 2.0;\n        new_step = (c - b) \/ 2.0;\n        \/* Acceptable approx. is found\t*\/\n        if (Math.abs(new_step) <= tol_act || fb == 0.0)\n            return b;\n        \/* Decide if the interpolation can be tried. If prev_step was large enough and was in true direction.\n            Interpolatiom may be tried *\/\n        if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {\n            double t1, cb, t2;\n            cb = c - b;\n            if (a == c) {\n                \/* If we have only two distinct points linear interpolation can only be applied *\/\n                t1 = fb \/ fa;\n                p = cb * t1;\n                q = 1.0 - t1;\n            } else {\n                \/* Quadric inverse interpolation*\/\n                q = fa \/ fc;\n                t1 = fb \/ fc;\n                t2 = fb \/ fa;\n                p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\n                q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\n            }\n            if (p > 0.0)\n                q = -q;\n            else\n                \/* p was calculated with the opposite sign; make p positive*\/\n                p = -p;\n            \/* and assign possible minus to\tq*\/\n            \/* If b+p\/q falls in [b,c] and isn't too large it is accepted\t*\/\n            \/* If p\/q is too large then the\tbissection procedure can reduce [b,c] range to more extent*\/\n            if (p < (0.75 * cb * q - Math.abs(tol_act * q) \/ 2.0) && p < Math.abs(prev_step * q \/ 2.0)) {\n                new_step = p \/ q;\n            }\n        }\n        \/* Adjust the step to be not less than tolerance*\/\n        if (Math.abs(new_step) < tol_act) {\n            if (new_step > 0.0)\n                new_step = tol_act;\n            else\n                new_step = -tol_act;\n        }\n        a = b;\n        fa = fb;\n        \/* Save the previous approx.\t*\/\n        b += new_step;\n        fb = f.apply(b);\n        \/* Do step to a new approxim.\t*\/\n        \/* Adjust c for it to have a sign*\/\n        if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n            c = a;\n            fc = fa;\n        }\n    }\n}","1":"\/\/ Density of the central hypergeometric distribution on its support: store for once as this is needed quite a bit.\nprivate List<Double> logdcDhyper(int m, int n, int k) {\n    List<Double> logdc = new ArrayList<>();\n    for (int element : support) {\n        if (m + n == 0) {\n            logdc.add(0.0);\n            continue;\n        }\n        \/\/ m + n - total number of successes, m - number of successes (reference) k - sample size (forward)\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        Double value = dhyper.logProbability(element);\n        if (value.isNaN()) {\n            value = 0.0;\n        }\n        logdc.add(roundHalfEven(\"0.0000000\", value));\n    }\n    return logdc;\n}","2":"private Double mle(double x) {\n    double eps = Math.ulp(1.0);\n    if (x == lo)\n        return 0.0;\n    if (x == hi)\n        return Double.POSITIVE_INFINITY;\n    double mu = mnhyper(1.0);\n    double root;\n    if (mu > x) {\n        Function<Double, Double> f = t -> mnhyper(t) - x;\n        root = UnirootZeroIn.zeroinC(0, 1, f, Math.pow(eps, 0.25));\n    } else if (mu < x) {\n        Function<Double, Double> f = t -> mnhyper(1.0 \/ t) - x;\n        root = 1.0 \/ UnirootZeroIn.zeroinC(eps, 1, f, Math.pow(eps, 0.25));\n    } else {\n        root = 1.0;\n    }\n    return root;\n}","3":"private Double mnhyper(Double ncp) {\n    if (ncp == 0)\n        return (double) lo;\n    if (ncp.isInfinite())\n        return (double) hi;\n    else {\n        List<Double> dnhyperResult = dnhyper(ncp);\n        List<Double> multiply = new ArrayList<>();\n        for (int i = 0; i < support.size(); i++) {\n            multiply.add(support.get(i) * dnhyperResult.get(i));\n        }\n        double b = multiply.stream().mapToDouble(a -> a).sum();\n        return b;\n    }\n}","4":"private List<Double> dnhyper(Double ncp) {\n    List<Double> result = new ArrayList<>();\n    for (int i = 0; i < support.size(); i++) {\n        result.add(logdc.get(i) + Math.log(ncp) * support.get(i));\n    }\n    double maxResult = Collections.max(result);\n    List<Double> exponentResult = new ArrayList<>();\n    for (double el : result) {\n        exponentResult.add(Math.exp(el - maxResult));\n    }\n    result = new ArrayList<>();\n    double sum = exponentResult.stream().mapToDouble(a -> a).sum();\n    for (double element : exponentResult) {\n        result.add(element \/ sum);\n    }\n    return result;\n}","5":"public String getOddRatio() {\n    Double oddRatio = mle(x);\n    if (oddRatio.isInfinite()) {\n        return \"Inf\";\n    } else if (oddRatio == Math.round(oddRatio)) {\n        return new DecimalFormat(\"0\").format(oddRatio);\n    } else {\n        return String.valueOf(round_as_r(oddRatio));\n    }\n}","6":"public double getPValue() {\n    return round_as_r(PvalueTwoSided);\n}","7":"public List<Double> getLogdc() {\n    logdc = logdcDhyper(m, n, k);\n    return logdc;\n}","8":"public double getPValueGreater() {\n    return round_as_r(PvalueGreater);\n}","9":"public double getPValueLess() {\n    return round_as_r(PvalueLess);\n}","10":"private double round_as_r(double value) {\n    value = roundHalfEven(\"0\", value * RESULT_ROUND_R);\n    value = value \/ RESULT_ROUND_R;\n    value = value == 0.0 ? 0 : (value == 1.0 ? 1 : value);\n    return value;\n}","11":"private double pnhyper(int q, boolean upper_tail) {\n    if (m + n == 0) {\n        return 1.0;\n    }\n    if (upper_tail) {\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        return dhyper.upperCumulativeProbability(q);\n    } else {\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        return dhyper.cumulativeProbability(q);\n    }\n}","12":"\/**\n * Method creates string from elements of specified collection (by appending them with space delimiter)\n * @param collection any collection\n * @param <E> generic type of collection elements\n * @return generated string\n *\/\npublic static <E> String toString(Collection<E> collection) {\n    Iterator<E> it = collection.iterator();\n    if (!it.hasNext())\n        return \"\";\n    StringBuilder sb = new StringBuilder();\n    for (; ; ) {\n        E e = it.next();\n        sb.append(e == collection ? \"(this Collection)\" : e);\n        if (!it.hasNext())\n            return sb.toString();\n        sb.append(' ');\n    }\n}","13":"public static String join(String delim, Object... args) {\n    if (args.length == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < args.length; i++) {\n        sb.append(args[i]);\n        if (i + 1 != args.length) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}","14":"public static String joinNotNull(String delim, Object... args) {\n    if (args.length == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i] == null) {\n            if (i + 1 != args.length && args[i + 1] != null) {\n                sb.append(delim);\n            }\n            continue;\n        }\n        sb.append(args[i]);\n        if (i + 1 != args.length && args[i + 1] != null) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}","15":"public static <K, V> V getOrElse(Map<K, V> map, K key, V or) {\n    V v = map.get(key);\n    if (v == null) {\n        v = or;\n        map.put(key, v);\n    }\n    return v;\n}","16":"public static int toInt(String intStr) {\n    return Integer.parseInt(intStr);\n}","17":"public static double roundHalfEven(String pattern, double value) {\n    return Double.parseDouble(new DecimalFormat(pattern).format(value));\n}","18":"public static String getRoundedValueToPrint(String pattern, double value) {\n    return value == Math.round(value) ? new DecimalFormat(\"0\").format(value) : new DecimalFormat(pattern).format(value).replaceAll(\"0+$\", \"\");\n}","19":"public static String substr(String string, int idx) {\n    if (idx >= 0) {\n        return string.substring(Math.min(string.length(), idx));\n    } else {\n        return string.substring(Math.max(0, string.length() + idx));\n    }\n}","20":"public static String substr(String string, int begin, int len) {\n    if (begin < 0) {\n        begin = string.length() + begin;\n    }\n    if (len > 0) {\n        return string.substring(begin, Math.min(begin + len, string.length()));\n    } else if (len == 0) {\n        return \"\";\n    } else {\n        int end = string.length() + len;\n        if (end < begin) {\n            return \"\";\n        }\n        return string.substring(begin, end);\n    }\n}","21":"public static char charAt(String str, int index) {\n    if (index < 0) {\n        int i = str.length() + index;\n        if (i < 0)\n            return (char) -1;\n        return str.charAt(i);\n    }\n    return str.charAt(index);\n}","22":"public static char charAt(StringBuilder str, int index) {\n    if (index < 0) {\n        int i = str.length() + index;\n        if (i < 0)\n            return (char) -1;\n        return str.charAt(str.length() + index);\n    }\n    return str.charAt(index);\n}","23":"public static int sum(Collection<?> list) {\n    int result = 0;\n    for (Object object : list) {\n        result += toInt(String.valueOf(object));\n    }\n    return result;\n}","24":"public static List<String> globalFind(jregex.Pattern alignedLength, String string) {\n    List<String> result = new LinkedList<>();\n    jregex.Matcher matcher = alignedLength.matcher(string);\n    while (matcher.find()) {\n        result.add(matcher.group(1));\n    }\n    return result;\n}","25":"public static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length) {\n    if (startIndex < 0) {\n        startIndex = record.getReadLength() + startIndex;\n    }\n    byte[] rangeBytes = Arrays.copyOfRange(record.getReadBases(), startIndex, startIndex + length);\n    SequenceUtil.reverseComplement(rangeBytes);\n    return new String(rangeBytes);\n}","26":"public static String reverse(String string) {\n    return new StringBuffer(string).reverse().toString();\n}","27":"public static String complement(String string) {\n    final byte[] bases = htsjdk.samtools.util.StringUtil.stringToBytes(string);\n    complement(bases);\n    return htsjdk.samtools.util.StringUtil.bytesToString(bases);\n}","28":"public static void complement(byte[] bases) {\n    final int lastIndex = bases.length;\n    for (int i = 0; i < lastIndex; i++) {\n        bases[i] = SequenceUtil.complement(bases[i]);\n    }\n}","29":"public static char complement(char character) {\n    byte base = htsjdk.samtools.util.StringUtil.charToByte(character);\n    base = SequenceUtil.complement(base);\n    return htsjdk.samtools.util.StringUtil.byteToChar(base);\n}","30":"public static String stringFromRate(long bps) {\n    int i;\n    char[] prefixes = { ' ', 'K', 'M', 'G', 'T', 'P' };\n    for (i = 1; (bps >= 1000000) && (i < 5); i++) {\n        bps \/= 1000;\n    }\n    return \"\" + bps \/ 1000 + \".\" + bps % 1000 * 10 \/ 1000 + \" \" + prefixes[i] + \"b\/s\";\n}","31":"public static String stringFromSizeFraction(long numerator, long denominator) {\n    int i;\n    String[] unit = { \"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\" };\n    for (i = 0; (denominator >= 10000) && (i < 5); i++) {\n        numerator >>= 10;\n        denominator >>= 10;\n    }\n    return numerator + \"\/\" + denominator + \" \" + unit[i];\n}","32":"public static String stringFromSizeFraction(String numerator, String denominator) {\n    long size1 = 0, size2 = 0;\n    try {\n        size1 = Long.valueOf(numerator).longValue();\n        size2 = Long.valueOf(denominator).longValue();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return stringFromSizeFraction(size1, size2);\n}","33":"public static long[] rightNeighbours(long kmer, int k) {\n    long mask = (1L << (2 * k)) - 1;\n    long[] ans = new long[] { (kmer << 2) & mask, ((kmer << 2) & mask) | 1, ((kmer << 2) & mask) | 2, ((kmer << 2) & mask) | 3 };\n    for (int i = 0; i < ans.length; i++) {\n        long rc = rc(ans[i], k);\n        if (rc < ans[i]) {\n            ans[i] = rc;\n        }\n    }\n    return ans;\n}","34":"public static long rc(long kmer, long k) {\n    kmer = ((kmer & 0x3333333333333333L) << 2) | ((kmer & 0xccccccccccccccccL) >>> 2);\n    kmer = ((kmer & 0x0f0f0f0f0f0f0f0fL) << 4) | ((kmer & 0xf0f0f0f0f0f0f0f0L) >>> 4);\n    kmer = ((kmer & 0x00ff00ff00ff00ffL) << 8) | ((kmer & 0xff00ff00ff00ff00L) >>> 8);\n    kmer = ((kmer & 0x0000ffff0000ffffL) << 16) | ((kmer & 0xffff0000ffff0000L) >>> 16);\n    kmer = ((kmer & 0x00000000ffffffffL) << 32) | ((kmer & 0xffffffff00000000L) >>> 32);\n    kmer = ~kmer;\n    return kmer >>> (64 - 2 * k);\n}","35":"public static long getValue(long value, int color) {\n    long mask = (1L << (color + 1) * POWER) - (1L << color * POWER);\n    return (value & mask) >> (color * POWER);\n}","36":"public static long addValue(long value, int color) {\n    return addValue(value, color, (short) 1);\n}","37":"public static long addValue(long value, int color, short add) {\n    long colorValue = getValue(value, color);\n    long newColorValue = Math.min(colorValue + add, (1L << POWER) - 1);\n    long newValue = setValue(value, color, newColorValue);\n    return newValue;\n}","38":"public static long clearValue(long value, int color) {\n    long mask = (1L << (color + 1) * POWER) - (1L << color * POWER);\n    mask = ~mask;\n    long newValue = value & mask;\n    return newValue;\n}","39":"public static int getColor(long value, double perc) {\n    long first = getValue(value, 0);\n    long second = getValue(value, 1);\n    long third = getValue(value, 2);\n    long sum = first + second + third;\n    if ((double) first \/ sum >= perc) {\n        return 0;\n    } else if ((double) second \/ sum >= perc) {\n        return 1;\n    } else if ((double) third \/ sum >= perc) {\n        return 2;\n    } else {\n        return -1;\n    }\n}","40":"\/\/\n\/\/ Public stuff\n\/\/\n\/\/ Gamma function\n\/**\n * log Gamma function: ln(gamma(alpha)) for alpha>0, accurate to 10 decimal places\n *\n * @param alpha argument\n * @return the log of the gamma function of the given alpha\n *\/\npublic static double lnGamma(final double alpha) {\n    \/\/ Pike MC & Hill ID (1966) Algorithm 291: Logarithm of the gamma function.\n    \/\/ Communications of the Association for Computing Machinery, 9:684\n    double x = alpha, f = 0.0, z;\n    if (x < 7) {\n        f = 1;\n        z = x - 1;\n        while (++z < 7) {\n            f *= z;\n        }\n        x = z;\n        f = -Math.log(f);\n    }\n    z = 1 \/ (x * x);\n    return f + (x - 0.5) * Math.log(x) - x + 0.918938533204673 + (((-0.000595238095238 * z + 0.000793650793651) * z - 0.002777777777778) * z + 0.083333333333333) \/ x;\n}","41":"public static double incompleteGammaQ(final double a, final double x) {\n    return 1.0 - incompleteGamma(x, a, lnGamma(a));\n}","42":"public static double incompleteGammaP(final double a, final double x) {\n    return incompleteGamma(x, a, lnGamma(a));\n}","43":"public static double incompleteGammaP(final double a, final double x, final double lnGammaA) {\n    return incompleteGamma(x, a, lnGammaA);\n}","44":"private static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha) {\n    final double accurate = 1e-8;\n    final double overflow = 1e30;\n    final double factor;\n    double gin;\n    double rn;\n    double a;\n    double b;\n    double an;\n    double dif;\n    double term;\n    double pn0, pn1, pn2, pn3, pn4, pn5;\n    if (x == 0.0) {\n        return 0.0;\n    }\n    if (x < 0.0 || alpha <= 0.0) {\n        throw new IllegalArgumentException(\"Arguments out of bounds\");\n    }\n    factor = Math.exp(alpha * Math.log(x) - x - ln_gamma_alpha);\n    if (x > 1 && x >= alpha) {\n        a = 1 - alpha;\n        b = a + x + 1;\n        term = 0;\n        pn0 = 1;\n        pn1 = x;\n        pn2 = x + 1;\n        pn3 = x * b;\n        gin = pn2 \/ pn3;\n        do {\n            a++;\n            b += 2;\n            term++;\n            an = a * term;\n            pn4 = b * pn2 - an * pn0;\n            pn5 = b * pn3 - an * pn1;\n            if (pn5 != 0) {\n                rn = pn4 \/ pn5;\n                dif = Math.abs(gin - rn);\n                if (dif <= accurate) {\n                    if (dif <= accurate * rn) {\n                        break;\n                    }\n                }\n                gin = rn;\n            }\n            pn0 = pn2;\n            pn1 = pn3;\n            pn2 = pn4;\n            pn3 = pn5;\n            if (Math.abs(pn4) >= overflow) {\n                pn0 \/= overflow;\n                pn1 \/= overflow;\n                pn2 \/= overflow;\n                pn3 \/= overflow;\n            }\n        } while (true);\n        gin = 1 - factor * gin;\n    } else {\n        gin = 1;\n        term = 1;\n        rn = alpha;\n        do {\n            rn++;\n            term *= x \/ rn;\n            gin += term;\n        } while (term > accurate);\n        gin *= factor \/ alpha;\n    }\n    return gin;\n}","45":"public static double covariance(double[] x, double[] y) {\n    return covariance(x, y, mean(x), mean(y), stdev(x), stdev(y));\n}","46":"public static double skewness(double[] x) {\n    double mean = mean(x);\n    double stdev = stdev(x);\n    double skew = 0.0;\n    double len = x.length;\n    for (double xv : x) {\n        double diff = xv - mean;\n        diff \/= stdev;\n        skew += (diff * diff * diff);\n    }\n    skew *= (len \/ ((len - 1) * (len - 2)));\n    return skew;\n}","47":"public static double[] HPDInterval(double proportion, double[] x, int[] indices) {\n    double minRange = Double.MAX_VALUE;\n    int hpdIndex = 0;\n    final int diff = (int) Math.round(proportion * x.length);\n    for (int i = 0; i <= (x.length - diff); i++) {\n        final double minValue = x[indices[i]];\n        final double maxValue = x[indices[i + diff - 1]];\n        final double range = Math.abs(maxValue - minValue);\n        if (range < minRange) {\n            minRange = range;\n            hpdIndex = i;\n        }\n    }\n    return new double[] { x[indices[hpdIndex]], x[indices[hpdIndex + diff - 1]] };\n}","48":"public static double cdf(double z, double[] x) {\n    int[] indices = new int[x.length];\n    HeapSort.sort(x, indices);\n    return cdf(z, x, indices);\n}","49":"public static double geometricMean(double[] x) {\n    double gm = 0;\n    int len = x.length;\n    for (int i = 0; i < len; i++) {\n        gm += Math.log(x[i]);\n    }\n    return Math.exp(gm \/ len);\n}"},"comment_lines":{"0":8,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":5,"13":5,"14":6,"15":0,"16":0,"17":6,"18":0,"19":6,"20":7,"21":5,"22":5,"23":4,"24":5,"25":7,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":5,"41":8,"42":8,"43":9,"44":8,"45":6,"46":5,"47":8,"48":7,"49":0},"tokens":{"0":930,"1":185,"2":202,"3":123,"4":146,"5":76,"6":18,"7":29,"8":17,"9":17,"10":64,"11":107,"12":128,"13":85,"14":139,"15":59,"16":18,"17":25,"18":48,"19":53,"20":110,"21":62,"22":67,"23":41,"24":60,"25":80,"26":19,"27":48,"28":49,"29":50,"30":114,"31":98,"32":83,"33":145,"34":263,"35":51,"36":27,"37":66,"38":57,"39":118,"40":261,"41":33,"42":28,"43":34,"44":493,"45":35,"46":101,"47":163,"48":42,"49":60},"lines":{"0":79,"1":17,"2":16,"3":12,"4":17,"5":9,"6":2,"7":3,"8":2,"9":2,"10":5,"11":11,"12":13,"13":12,"14":18,"15":7,"16":2,"17":2,"18":4,"19":6,"20":15,"21":8,"22":8,"23":6,"24":7,"25":7,"26":2,"27":4,"28":6,"29":4,"30":10,"31":10,"32":14,"33":13,"34":10,"35":3,"36":2,"37":5,"38":5,"39":16,"40":21,"41":2,"42":2,"43":2,"44":84,"45":3,"46":17,"47":17,"48":5,"49":8},"parameters":{"0":4,"1":3,"2":1,"3":1,"4":1,"5":0,"6":0,"7":0,"8":0,"9":0,"10":1,"11":2,"12":1,"13":2,"14":2,"15":3,"16":1,"17":2,"18":2,"19":2,"20":3,"21":2,"22":2,"23":1,"24":2,"25":3,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":2,"34":2,"35":2,"36":2,"37":3,"38":2,"39":2,"40":1,"41":2,"42":2,"43":3,"44":3,"45":2,"46":1,"47":3,"48":2,"49":1},"functions":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":7,"13":7,"14":7,"15":7,"16":7,"17":7,"18":7,"19":7,"20":7,"21":7,"22":7,"23":7,"24":7,"25":7,"26":7,"27":7,"28":7,"29":7,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0},"globals":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0},"imports":{"0":1,"1":5,"2":5,"3":5,"4":5,"5":5,"6":5,"7":5,"8":5,"9":5,"10":5,"11":5,"12":1,"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":0,"31":0,"32":0,"33":1,"34":1,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0}}