{"numParams":{"0":4,"1":3,"2":1,"3":1,"4":1,"5":0,"6":0,"7":0,"8":0,"9":0,"10":1,"11":2,"12":1,"13":2,"14":2,"15":3,"16":1,"17":2,"18":2,"19":2,"20":3,"21":2,"22":2,"23":1,"24":2,"25":3,"26":1,"27":1,"28":1,"29":1,"30":1,"31":2,"32":2,"33":2,"34":2,"35":2,"36":2,"37":3,"38":2,"39":2,"40":1,"41":2,"42":2,"43":3,"44":3,"45":2,"46":1,"47":3,"48":2,"49":1},"numLines":{"0":79,"1":17,"2":16,"3":12,"4":17,"5":9,"6":2,"7":3,"8":2,"9":2,"10":5,"11":11,"12":13,"13":12,"14":18,"15":7,"16":2,"17":2,"18":4,"19":6,"20":15,"21":8,"22":8,"23":6,"24":7,"25":7,"26":2,"27":4,"28":6,"29":4,"30":10,"31":10,"32":14,"33":13,"34":10,"35":3,"36":2,"37":5,"38":5,"39":16,"40":21,"41":2,"42":2,"43":2,"44":84,"45":3,"46":17,"47":17,"48":5,"49":8},"numChars":{"0":3402,"1":731,"2":571,"3":465,"4":605,"5":295,"6":68,"7":86,"8":74,"9":68,"10":212,"11":421,"12":614,"13":336,"14":540,"15":170,"16":79,"17":141,"18":220,"19":228,"20":444,"21":226,"22":252,"23":172,"24":284,"25":374,"26":105,"27":218,"28":189,"29":223,"30":282,"31":327,"32":346,"33":385,"34":535,"35":169,"36":100,"37":263,"38":198,"39":433,"40":799,"41":125,"42":119,"43":140,"44":1818,"45":126,"46":339,"47":611,"48":151,"49":196},"lineStart":{"0":22,"1":58,"2":85,"3":103,"4":117,"5":136,"6":147,"7":151,"8":156,"9":160,"10":164,"11":186,"12":19,"13":40,"14":61,"15":81,"16":90,"17":101,"18":105,"19":118,"20":134,"21":157,"22":173,"23":188,"24":202,"25":219,"26":228,"27":232,"28":238,"29":246,"30":8,"31":20,"32":32,"33":32,"34":62,"35":7,"36":12,"37":16,"38":29,"39":36,"40":46,"41":78,"42":91,"43":105,"44":119,"45":150,"46":190,"47":314,"48":359,"49":382},"lineEnd":{"0":101,"1":75,"2":101,"3":115,"4":134,"5":145,"6":149,"7":154,"8":158,"9":162,"10":169,"11":197,"12":32,"13":52,"14":79,"15":88,"16":92,"17":103,"18":109,"19":124,"20":149,"21":165,"22":181,"23":194,"24":209,"25":226,"26":230,"27":236,"28":244,"29":250,"30":18,"31":30,"32":46,"33":45,"34":72,"35":10,"36":14,"37":21,"38":34,"39":52,"40":67,"41":80,"42":93,"43":107,"44":203,"45":153,"46":207,"47":331,"48":364,"49":390},"returnType":{"0":"double","1":"List<Double>","2":"Double","3":"Double","4":"List<Double>","5":"String","6":"double","7":"List<Double>","8":"double","9":"double","10":"double","11":"double","12":"String","13":"String","14":"String","15":"V","16":"int","17":"double","18":"String","19":"String","20":"String","21":"char","22":"char","23":"int","24":"List<String>","25":"String","26":"String","27":"String","28":"void","29":"char","30":"String","31":"String","32":"String","33":"long[]","34":"long","35":"long","36":"long","37":"long","38":"long","39":"int","40":"double","41":"double","42":"double","43":"double","44":"double","45":"double","46":"double","47":"double[]","48":"double","49":"double"},"params":{"0":["double ax","double bx","Function<Double, Double> f","double tol"],"1":["int m","int n","int k"],"2":["double x"],"3":["Double ncp"],"4":["Double ncp"],"5":[],"6":[],"7":[],"8":[],"9":[],"10":["double value"],"11":["int q","boolean upper_tail"],"12":["Collection<E> collection"],"13":["String delim","Object... args"],"14":["String delim","Object... args"],"15":["Map<K, V> map","K key","V or"],"16":["String intStr"],"17":["String pattern","double value"],"18":["String pattern","double value"],"19":["String string","int idx"],"20":["String string","int begin","int len"],"21":["String str","int index"],"22":["StringBuilder str","int index"],"23":["Collection<?> list"],"24":["jregex.Pattern alignedLength","String string"],"25":["SAMRecord record","int startIndex","int length"],"26":["String string"],"27":["String string"],"28":["byte[] bases"],"29":["char character"],"30":["long bps"],"31":["long numerator","long denominator"],"32":["String numerator","String denominator"],"33":["long kmer","int k"],"34":["long kmer","long k"],"35":["long value","int color"],"36":["long value","int color"],"37":["long value","int color","short add"],"38":["long value","int color"],"39":["long value","double perc"],"40":["final double alpha"],"41":["final double a","final double x"],"42":["final double a","final double x"],"43":["final double a","final double x","final double lnGammaA"],"44":["final double x","final double alpha","final double ln_gamma_alpha"],"45":["double[] x","double[] y"],"46":["double[] x"],"47":["double proportion","double[] x","int[] indices"],"48":["double z","double[] x"],"49":["double[] x"]},"filePath":{"0":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/UnirootZeroIn.java","1":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","2":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","3":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","4":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","5":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","6":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","7":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","8":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","9":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","10":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","11":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/fishertest\/FisherExact.java","12":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","13":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","14":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","15":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","16":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","17":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","18":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","19":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","20":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","21":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","22":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","23":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","24":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","25":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","26":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","27":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","28":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","29":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","30":"\/home\/ubuntu\/repos\/PRIDE-Toolsuite,pride-inspector\/src\/main\/java\/uk\/ac\/ebi\/pride\/toolsuite\/gui\/aspera\/ConversionUtils.java","31":"\/home\/ubuntu\/repos\/PRIDE-Toolsuite,pride-inspector\/src\/main\/java\/uk\/ac\/ebi\/pride\/toolsuite\/gui\/aspera\/ConversionUtils.java","32":"\/home\/ubuntu\/repos\/PRIDE-Toolsuite,pride-inspector\/src\/main\/java\/uk\/ac\/ebi\/pride\/toolsuite\/gui\/aspera\/ConversionUtils.java","33":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/KmerOperations.java","34":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/KmerOperations.java","35":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/ColoredKmerOperations.java","36":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/ColoredKmerOperations.java","37":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/ColoredKmerOperations.java","38":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/ColoredKmerOperations.java","39":"\/home\/ubuntu\/repos\/ctlab,metafast\/src\/algo\/ColoredKmerOperations.java","40":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/GammaFunction.java","41":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/GammaFunction.java","42":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/GammaFunction.java","43":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/GammaFunction.java","44":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/GammaFunction.java","45":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/DiscreteStatistics.java","46":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/DiscreteStatistics.java","47":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/DiscreteStatistics.java","48":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/DiscreteStatistics.java","49":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/DiscreteStatistics.java"},"signature":{"0":"public static double zeroinC(double ax, double bx, Function<Double, Double> f, double tol)","1":"private List<Double> logdcDhyper(int m, int n, int k)","2":"private Double mle(double x)","3":"private Double mnhyper(Double ncp)","4":"private List<Double> dnhyper(Double ncp)","5":"public String getOddRatio()","6":"public double getPValue()","7":"public List<Double> getLogdc()","8":"public double getPValueGreater()","9":"public double getPValueLess()","10":"private double round_as_r(double value)","11":"private double pnhyper(int q, boolean upper_tail)","12":"public static String toString(Collection<E> collection)","13":"public static String join(String delim, Object... args)","14":"public static String joinNotNull(String delim, Object... args)","15":"public static V getOrElse(Map<K, V> map, K key, V or)","16":"public static int toInt(String intStr)","17":"public static double roundHalfEven(String pattern, double value)","18":"public static String getRoundedValueToPrint(String pattern, double value)","19":"public static String substr(String string, int idx)","20":"public static String substr(String string, int begin, int len)","21":"public static char charAt(String str, int index)","22":"public static char charAt(StringBuilder str, int index)","23":"public static int sum(Collection<?> list)","24":"public static List<String> globalFind(jregex.Pattern alignedLength, String string)","25":"public static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length)","26":"public static String reverse(String string)","27":"public static String complement(String string)","28":"public static void complement(byte[] bases)","29":"public static char complement(char character)","30":"public static String stringFromRate(long bps)","31":"public static String stringFromSizeFraction(long numerator, long denominator)","32":"public static String stringFromSizeFraction(String numerator, String denominator)","33":"public static long[] rightNeighbours(long kmer, int k)","34":"public static long rc(long kmer, long k)","35":"public static long getValue(long value, int color)","36":"public static long addValue(long value, int color)","37":"public static long addValue(long value, int color, short add)","38":"public static long clearValue(long value, int color)","39":"public static int getColor(long value, double perc)","40":"public static double lnGamma(final double alpha)","41":"public static double incompleteGammaQ(final double a, final double x)","42":"public static double incompleteGammaP(final double a, final double x)","43":"public static double incompleteGammaP(final double a, final double x, final double lnGammaA)","44":"private static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha)","45":"public static double covariance(double[] x, double[] y)","46":"public static double skewness(double[] x)","47":"public static double[] HPDInterval(double proportion, double[] x, int[] indices)","48":"public static double cdf(double z, double[] x)","49":"public static double geometricMean(double[] x)"},"content":{"0":"\/**\n * An estimate to the root from zeroin C implementation\n *\n * @param ax  Left border of the range\n * @param bx  Right border the root is seeked\n * @param f   Function under investigation\n * @param tol Acceptable tolerance\n * @return root\n *\/\npublic static double zeroinC(double ax, double bx, Function<Double, Double> f, double tol) {\n    double a, b, c;\n    \/* Abscissae, descr. see above\t*\/\n    double fa;\n    \/* f(a)\t\t\t\t*\/\n    double fb;\n    \/* f(b)\t\t\t\t*\/\n    double fc;\n    \/* f(c)\t\t\t\t*\/\n    double EPSILON = Math.ulp(1.0);\n    a = ax;\n    b = bx;\n    fa = f.apply(a);\n    fb = f.apply(b);\n    c = a;\n    fc = fa;\n    \/* Main iteration loop\t*\/\n    for (; ; ) {\n        double prev_step = b - a;\n        \/* Distance from the last but one to the last approximation\t*\/\n        double tol_act;\n        \/* Actual tolerance\t\t*\/\n        double p;\n        \/* Interpolation step is calculated in the form p\/q; division operations is delayed until the last moment *\/\n        double q;\n        double new_step;\n        \/* Step at this iteration *\/\n        \/* Swap data for b to be the best approximation\t*\/\n        if (Math.abs(fc) < Math.abs(fb)) {\n            a = b;\n            b = c;\n            c = a;\n            fa = fb;\n            fb = fc;\n            fc = fa;\n        }\n        tol_act = 2 * EPSILON * Math.abs(b) + tol \/ 2.0;\n        new_step = (c - b) \/ 2.0;\n        \/* Acceptable approx. is found\t*\/\n        if (Math.abs(new_step) <= tol_act || fb == 0.0)\n            return b;\n        \/* Decide if the interpolation can be tried. If prev_step was large enough and was in true direction.\n            Interpolatiom may be tried *\/\n        if (Math.abs(prev_step) >= tol_act && Math.abs(fa) > Math.abs(fb)) {\n            double t1, cb, t2;\n            cb = c - b;\n            if (a == c) {\n                \/* If we have only two distinct points linear interpolation can only be applied *\/\n                t1 = fb \/ fa;\n                p = cb * t1;\n                q = 1.0 - t1;\n            } else {\n                \/* Quadric inverse interpolation*\/\n                q = fa \/ fc;\n                t1 = fb \/ fc;\n                t2 = fb \/ fa;\n                p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));\n                q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);\n            }\n            if (p > 0.0)\n                q = -q;\n            else\n                \/* p was calculated with the opposite sign; make p positive*\/\n                p = -p;\n            \/* and assign possible minus to\tq*\/\n            \/* If b+p\/q falls in [b,c] and isn't too large it is accepted\t*\/\n            \/* If p\/q is too large then the\tbissection procedure can reduce [b,c] range to more extent*\/\n            if (p < (0.75 * cb * q - Math.abs(tol_act * q) \/ 2.0) && p < Math.abs(prev_step * q \/ 2.0)) {\n                new_step = p \/ q;\n            }\n        }\n        \/* Adjust the step to be not less than tolerance*\/\n        if (Math.abs(new_step) < tol_act) {\n            if (new_step > 0.0)\n                new_step = tol_act;\n            else\n                new_step = -tol_act;\n        }\n        a = b;\n        fa = fb;\n        \/* Save the previous approx.\t*\/\n        b += new_step;\n        fb = f.apply(b);\n        \/* Do step to a new approxim.\t*\/\n        \/* Adjust c for it to have a sign*\/\n        if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n            c = a;\n            fc = fa;\n        }\n    }\n}","1":"\/\/ Density of the central hypergeometric distribution on its support: store for once as this is needed quite a bit.\nprivate List<Double> logdcDhyper(int m, int n, int k) {\n    List<Double> logdc = new ArrayList<>();\n    for (int element : support) {\n        if (m + n == 0) {\n            logdc.add(0.0);\n            continue;\n        }\n        \/\/ m + n - total number of successes, m - number of successes (reference) k - sample size (forward)\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        Double value = dhyper.logProbability(element);\n        if (value.isNaN()) {\n            value = 0.0;\n        }\n        logdc.add(roundHalfEven(\"0.0000000\", value));\n    }\n    return logdc;\n}","2":"private Double mle(double x) {\n    double eps = Math.ulp(1.0);\n    if (x == lo)\n        return 0.0;\n    if (x == hi)\n        return Double.POSITIVE_INFINITY;\n    double mu = mnhyper(1.0);\n    double root;\n    if (mu > x) {\n        Function<Double, Double> f = t -> mnhyper(t) - x;\n        root = UnirootZeroIn.zeroinC(0, 1, f, Math.pow(eps, 0.25));\n    } else if (mu < x) {\n        Function<Double, Double> f = t -> mnhyper(1.0 \/ t) - x;\n        root = 1.0 \/ UnirootZeroIn.zeroinC(eps, 1, f, Math.pow(eps, 0.25));\n    } else {\n        root = 1.0;\n    }\n    return root;\n}","3":"private Double mnhyper(Double ncp) {\n    if (ncp == 0)\n        return (double) lo;\n    if (ncp.isInfinite())\n        return (double) hi;\n    else {\n        List<Double> dnhyperResult = dnhyper(ncp);\n        List<Double> multiply = new ArrayList<>();\n        for (int i = 0; i < support.size(); i++) {\n            multiply.add(support.get(i) * dnhyperResult.get(i));\n        }\n        double b = multiply.stream().mapToDouble(a -> a).sum();\n        return b;\n    }\n}","4":"private List<Double> dnhyper(Double ncp) {\n    List<Double> result = new ArrayList<>();\n    for (int i = 0; i < support.size(); i++) {\n        result.add(logdc.get(i) + Math.log(ncp) * support.get(i));\n    }\n    double maxResult = Collections.max(result);\n    List<Double> exponentResult = new ArrayList<>();\n    for (double el : result) {\n        exponentResult.add(Math.exp(el - maxResult));\n    }\n    result = new ArrayList<>();\n    double sum = exponentResult.stream().mapToDouble(a -> a).sum();\n    for (double element : exponentResult) {\n        result.add(element \/ sum);\n    }\n    return result;\n}","5":"public String getOddRatio() {\n    Double oddRatio = mle(x);\n    if (oddRatio.isInfinite()) {\n        return \"Inf\";\n    } else if (oddRatio == Math.round(oddRatio)) {\n        return new DecimalFormat(\"0\").format(oddRatio);\n    } else {\n        return String.valueOf(round_as_r(oddRatio));\n    }\n}","6":"public double getPValue() {\n    return round_as_r(PvalueTwoSided);\n}","7":"public List<Double> getLogdc() {\n    logdc = logdcDhyper(m, n, k);\n    return logdc;\n}","8":"public double getPValueGreater() {\n    return round_as_r(PvalueGreater);\n}","9":"public double getPValueLess() {\n    return round_as_r(PvalueLess);\n}","10":"private double round_as_r(double value) {\n    value = roundHalfEven(\"0\", value * RESULT_ROUND_R);\n    value = value \/ RESULT_ROUND_R;\n    value = value == 0.0 ? 0 : (value == 1.0 ? 1 : value);\n    return value;\n}","11":"private double pnhyper(int q, boolean upper_tail) {\n    if (m + n == 0) {\n        return 1.0;\n    }\n    if (upper_tail) {\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        return dhyper.upperCumulativeProbability(q);\n    } else {\n        HypergeometricDistribution dhyper = new HypergeometricDistribution(m + n, m, k);\n        return dhyper.cumulativeProbability(q);\n    }\n}","12":"\/**\n * Method creates string from elements of specified collection (by appending them with space delimiter)\n * @param collection any collection\n * @param <E> generic type of collection elements\n * @return generated string\n *\/\npublic static <E> String toString(Collection<E> collection) {\n    Iterator<E> it = collection.iterator();\n    if (!it.hasNext())\n        return \"\";\n    StringBuilder sb = new StringBuilder();\n    for (; ; ) {\n        E e = it.next();\n        sb.append(e == collection ? \"(this Collection)\" : e);\n        if (!it.hasNext())\n            return sb.toString();\n        sb.append(' ');\n    }\n}","13":"public static String join(String delim, Object... args) {\n    if (args.length == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < args.length; i++) {\n        sb.append(args[i]);\n        if (i + 1 != args.length) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}","14":"public static String joinNotNull(String delim, Object... args) {\n    if (args.length == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < args.length; i++) {\n        if (args[i] == null) {\n            if (i + 1 != args.length && args[i + 1] != null) {\n                sb.append(delim);\n            }\n            continue;\n        }\n        sb.append(args[i]);\n        if (i + 1 != args.length && args[i + 1] != null) {\n            sb.append(delim);\n        }\n    }\n    return sb.toString();\n}","15":"public static <K, V> V getOrElse(Map<K, V> map, K key, V or) {\n    V v = map.get(key);\n    if (v == null) {\n        v = or;\n        map.put(key, v);\n    }\n    return v;\n}","16":"public static int toInt(String intStr) {\n    return Integer.parseInt(intStr);\n}","17":"public static double roundHalfEven(String pattern, double value) {\n    return Double.parseDouble(new DecimalFormat(pattern).format(value));\n}","18":"public static String getRoundedValueToPrint(String pattern, double value) {\n    return value == Math.round(value) ? new DecimalFormat(\"0\").format(value) : new DecimalFormat(pattern).format(value).replaceAll(\"0+$\", \"\");\n}","19":"public static String substr(String string, int idx) {\n    if (idx >= 0) {\n        return string.substring(Math.min(string.length(), idx));\n    } else {\n        return string.substring(Math.max(0, string.length() + idx));\n    }\n}","20":"public static String substr(String string, int begin, int len) {\n    if (begin < 0) {\n        begin = string.length() + begin;\n    }\n    if (len > 0) {\n        return string.substring(begin, Math.min(begin + len, string.length()));\n    } else if (len == 0) {\n        return \"\";\n    } else {\n        int end = string.length() + len;\n        if (end < begin) {\n            return \"\";\n        }\n        return string.substring(begin, end);\n    }\n}","21":"public static char charAt(String str, int index) {\n    if (index < 0) {\n        int i = str.length() + index;\n        if (i < 0)\n            return (char) -1;\n        return str.charAt(i);\n    }\n    return str.charAt(index);\n}","22":"public static char charAt(StringBuilder str, int index) {\n    if (index < 0) {\n        int i = str.length() + index;\n        if (i < 0)\n            return (char) -1;\n        return str.charAt(str.length() + index);\n    }\n    return str.charAt(index);\n}","23":"public static int sum(Collection<?> list) {\n    int result = 0;\n    for (Object object : list) {\n        result += toInt(String.valueOf(object));\n    }\n    return result;\n}","24":"public static List<String> globalFind(jregex.Pattern alignedLength, String string) {\n    List<String> result = new LinkedList<>();\n    jregex.Matcher matcher = alignedLength.matcher(string);\n    while (matcher.find()) {\n        result.add(matcher.group(1));\n    }\n    return result;\n}","25":"public static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length) {\n    if (startIndex < 0) {\n        startIndex = record.getReadLength() + startIndex;\n    }\n    byte[] rangeBytes = Arrays.copyOfRange(record.getReadBases(), startIndex, startIndex + length);\n    SequenceUtil.reverseComplement(rangeBytes);\n    return new String(rangeBytes);\n}","26":"public static String reverse(String string) {\n    return new StringBuffer(string).reverse().toString();\n}","27":"public static String complement(String string) {\n    final byte[] bases = htsjdk.samtools.util.StringUtil.stringToBytes(string);\n    complement(bases);\n    return htsjdk.samtools.util.StringUtil.bytesToString(bases);\n}","28":"public static void complement(byte[] bases) {\n    final int lastIndex = bases.length;\n    for (int i = 0; i < lastIndex; i++) {\n        bases[i] = SequenceUtil.complement(bases[i]);\n    }\n}","29":"public static char complement(char character) {\n    byte base = htsjdk.samtools.util.StringUtil.charToByte(character);\n    base = SequenceUtil.complement(base);\n    return htsjdk.samtools.util.StringUtil.byteToChar(base);\n}","30":"public static String stringFromRate(long bps) {\n    int i;\n    char[] prefixes = { ' ', 'K', 'M', 'G', 'T', 'P' };\n    for (i = 1; (bps >= 1000000) && (i < 5); i++) {\n        bps \/= 1000;\n    }\n    return \"\" + bps \/ 1000 + \".\" + bps % 1000 * 10 \/ 1000 + \" \" + prefixes[i] + \"b\/s\";\n}","31":"public static String stringFromSizeFraction(long numerator, long denominator) {\n    int i;\n    String[] unit = { \"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\" };\n    for (i = 0; (denominator >= 10000) && (i < 5); i++) {\n        numerator >>= 10;\n        denominator >>= 10;\n    }\n    return numerator + \"\/\" + denominator + \" \" + unit[i];\n}","32":"public static String stringFromSizeFraction(String numerator, String denominator) {\n    long size1 = 0, size2 = 0;\n    try {\n        size1 = Long.valueOf(numerator).longValue();\n        size2 = Long.valueOf(denominator).longValue();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return stringFromSizeFraction(size1, size2);\n}","33":"public static long[] rightNeighbours(long kmer, int k) {\n    long mask = (1L << (2 * k)) - 1;\n    long[] ans = new long[] { (kmer << 2) & mask, ((kmer << 2) & mask) | 1, ((kmer << 2) & mask) | 2, ((kmer << 2) & mask) | 3 };\n    for (int i = 0; i < ans.length; i++) {\n        long rc = rc(ans[i], k);\n        if (rc < ans[i]) {\n            ans[i] = rc;\n        }\n    }\n    return ans;\n}","34":"public static long rc(long kmer, long k) {\n    kmer = ((kmer & 0x3333333333333333L) << 2) | ((kmer & 0xccccccccccccccccL) >>> 2);\n    kmer = ((kmer & 0x0f0f0f0f0f0f0f0fL) << 4) | ((kmer & 0xf0f0f0f0f0f0f0f0L) >>> 4);\n    kmer = ((kmer & 0x00ff00ff00ff00ffL) << 8) | ((kmer & 0xff00ff00ff00ff00L) >>> 8);\n    kmer = ((kmer & 0x0000ffff0000ffffL) << 16) | ((kmer & 0xffff0000ffff0000L) >>> 16);\n    kmer = ((kmer & 0x00000000ffffffffL) << 32) | ((kmer & 0xffffffff00000000L) >>> 32);\n    kmer = ~kmer;\n    return kmer >>> (64 - 2 * k);\n}","35":"public static long getValue(long value, int color) {\n    long mask = (1L << (color + 1) * POWER) - (1L << color * POWER);\n    return (value & mask) >> (color * POWER);\n}","36":"public static long addValue(long value, int color) {\n    return addValue(value, color, (short) 1);\n}","37":"public static long addValue(long value, int color, short add) {\n    long colorValue = getValue(value, color);\n    long newColorValue = Math.min(colorValue + add, (1L << POWER) - 1);\n    long newValue = setValue(value, color, newColorValue);\n    return newValue;\n}","38":"public static long clearValue(long value, int color) {\n    long mask = (1L << (color + 1) * POWER) - (1L << color * POWER);\n    mask = ~mask;\n    long newValue = value & mask;\n    return newValue;\n}","39":"public static int getColor(long value, double perc) {\n    long first = getValue(value, 0);\n    long second = getValue(value, 1);\n    long third = getValue(value, 2);\n    long sum = first + second + third;\n    if ((double) first \/ sum >= perc) {\n        return 0;\n    } else if ((double) second \/ sum >= perc) {\n        return 1;\n    } else if ((double) third \/ sum >= perc) {\n        return 2;\n    } else {\n        return -1;\n    }\n}","40":"\/\/\n\/\/ Public stuff\n\/\/\n\/\/ Gamma function\n\/**\n * log Gamma function: ln(gamma(alpha)) for alpha>0, accurate to 10 decimal places\n *\n * @param alpha argument\n * @return the log of the gamma function of the given alpha\n *\/\npublic static double lnGamma(final double alpha) {\n    \/\/ Pike MC & Hill ID (1966) Algorithm 291: Logarithm of the gamma function.\n    \/\/ Communications of the Association for Computing Machinery, 9:684\n    double x = alpha, f = 0.0, z;\n    if (x < 7) {\n        f = 1;\n        z = x - 1;\n        while (++z < 7) {\n            f *= z;\n        }\n        x = z;\n        f = -Math.log(f);\n    }\n    z = 1 \/ (x * x);\n    return f + (x - 0.5) * Math.log(x) - x + 0.918938533204673 + (((-0.000595238095238 * z + 0.000793650793651) * z - 0.002777777777778) * z + 0.083333333333333) \/ x;\n}","41":"public static double incompleteGammaQ(final double a, final double x) {\n    return 1.0 - incompleteGamma(x, a, lnGamma(a));\n}","42":"public static double incompleteGammaP(final double a, final double x) {\n    return incompleteGamma(x, a, lnGamma(a));\n}","43":"public static double incompleteGammaP(final double a, final double x, final double lnGammaA) {\n    return incompleteGamma(x, a, lnGammaA);\n}","44":"private static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha) {\n    final double accurate = 1e-8;\n    final double overflow = 1e30;\n    final double factor;\n    double gin;\n    double rn;\n    double a;\n    double b;\n    double an;\n    double dif;\n    double term;\n    double pn0, pn1, pn2, pn3, pn4, pn5;\n    if (x == 0.0) {\n        return 0.0;\n    }\n    if (x < 0.0 || alpha <= 0.0) {\n        throw new IllegalArgumentException(\"Arguments out of bounds\");\n    }\n    factor = Math.exp(alpha * Math.log(x) - x - ln_gamma_alpha);\n    if (x > 1 && x >= alpha) {\n        a = 1 - alpha;\n        b = a + x + 1;\n        term = 0;\n        pn0 = 1;\n        pn1 = x;\n        pn2 = x + 1;\n        pn3 = x * b;\n        gin = pn2 \/ pn3;\n        do {\n            a++;\n            b += 2;\n            term++;\n            an = a * term;\n            pn4 = b * pn2 - an * pn0;\n            pn5 = b * pn3 - an * pn1;\n            if (pn5 != 0) {\n                rn = pn4 \/ pn5;\n                dif = Math.abs(gin - rn);\n                if (dif <= accurate) {\n                    if (dif <= accurate * rn) {\n                        break;\n                    }\n                }\n                gin = rn;\n            }\n            pn0 = pn2;\n            pn1 = pn3;\n            pn2 = pn4;\n            pn3 = pn5;\n            if (Math.abs(pn4) >= overflow) {\n                pn0 \/= overflow;\n                pn1 \/= overflow;\n                pn2 \/= overflow;\n                pn3 \/= overflow;\n            }\n        } while (true);\n        gin = 1 - factor * gin;\n    } else {\n        gin = 1;\n        term = 1;\n        rn = alpha;\n        do {\n            rn++;\n            term *= x \/ rn;\n            gin += term;\n        } while (term > accurate);\n        gin *= factor \/ alpha;\n    }\n    return gin;\n}","45":"public static double covariance(double[] x, double[] y) {\n    return covariance(x, y, mean(x), mean(y), stdev(x), stdev(y));\n}","46":"public static double skewness(double[] x) {\n    double mean = mean(x);\n    double stdev = stdev(x);\n    double skew = 0.0;\n    double len = x.length;\n    for (double xv : x) {\n        double diff = xv - mean;\n        diff \/= stdev;\n        skew += (diff * diff * diff);\n    }\n    skew *= (len \/ ((len - 1) * (len - 2)));\n    return skew;\n}","47":"public static double[] HPDInterval(double proportion, double[] x, int[] indices) {\n    double minRange = Double.MAX_VALUE;\n    int hpdIndex = 0;\n    final int diff = (int) Math.round(proportion * x.length);\n    for (int i = 0; i <= (x.length - diff); i++) {\n        final double minValue = x[indices[i]];\n        final double maxValue = x[indices[i + diff - 1]];\n        final double range = Math.abs(maxValue - minValue);\n        if (range < minRange) {\n            minRange = range;\n            hpdIndex = i;\n        }\n    }\n    return new double[] { x[indices[hpdIndex]], x[indices[hpdIndex + diff - 1]] };\n}","48":"public static double cdf(double z, double[] x) {\n    int[] indices = new int[x.length];\n    HeapSort.sort(x, indices);\n    return cdf(z, x, indices);\n}","49":"public static double geometricMean(double[] x) {\n    double gm = 0;\n    int len = x.length;\n    for (int i = 0; i < len; i++) {\n        gm += Math.log(x[i]);\n    }\n    return Math.exp(gm \/ len);\n}"},"comment":{"0":"\/**\n     * An estimate to the root from zeroin C implementation\n     *\n     * @param ax  Left border of the range\n     * @param bx  Right border the root is seeked\n     * @param f   Function under investigation\n     * @param tol Acceptable tolerance\n     * @return root\n     *\/","1":"","2":"","3":"","4":"","5":"","6":"","7":"","8":"","9":"","10":"","11":"","12":"\/**\n     * Method creates string from elements of specified collection (by appending them with space delimiter)\n     * @param collection any collection\n     * @param <E> generic type of collection elements\n     * @return generated string\n     *\/","13":"\/**\n     * Method creates string from arguments by appending them with specified delimiter\n     * @param delim specified delimiter\n     * @param args array of arguments\n     * @return generated string\n     *\/","14":"\/**\n     * Method creates string from arguments by appending them with specified delimiter.\n     * If element from args is null, it replaced by delimiter.\n     * @param delim specified delimiter\n     * @param args array of arguments\n     * @return generated string\n     *\/","15":"","16":"","17":"\/**\n     * Method return double rounded by specified pattern with HALF_EVEN round\n     * (the same as in Perl)\n     * @param pattern string contains pattern like \"0.000\"\n     * @param value double value to round\n     * @return rounded double\n     *\/","18":"","19":"\/**\n     * Method creates substring of string begin from specified idx.\n     * If idx is negative, it returns substring, counted from the right end of string.\n     * @param string sequence to substring\n     * @param idx begin index of substring\n     * @return generated substring\n     *\/","20":"\/**\n     * Method creates substring of string begin from specified idx and of specified length.\n     * If begin or len is negative, it returns substring, counted from the right end of string.\n     * @param string sequence to substring\n     * @param begin begin index of substring\n     * @param len length of substring\n     * @return generated substring\n     *\/","21":"\/**\n     * Method finds character on specified index in String. If index is negative, it counts index from right end of string.\n     * @param str String where to search character\n     * @param index position in sequence\n     * @return founded character on specified position\n     *\/","22":"\/**\n     * Method finds character on specified index in StringBuilder. If index is negative, it counts index from right end of string.\n     * @param str StringBuilder where to search character\n     * @param index position in sequence\n     * @return founded character on specified position\n     *\/","23":"\/**\n     * Method calculates sum from integer values of Objects in collection.\n     * @param list any collection\n     * @return sum of values from collection\n     *\/","24":"\/**\n     * Method founds all results of matching Pattern in the string\n     * @param alignedLength pattern to apply to string\n     * @param string string to find specified pattern\n     * @return List of strings (founded parts, that matches pattern)\n     *\/","25":"\/**\n     * Method returns reverse complemented sequence for the part of the record. Can work with 3' and 5' ends\n     * (if start index < 0, then it will found the index in the end of sequence by adding the length of record).\n     * @param record read from SAM file to process\n     * @param startIndex index where start the sequence\n     * @param length length of pert of sequence\n     * @return reverse complemented part of record\n     *\/","26":"","27":"","28":"","29":"","30":"","31":"","32":"","33":"","34":"","35":"","36":"","37":"","38":"","39":"","40":"\/**\n     * log Gamma function: ln(gamma(alpha)) for alpha>0, accurate to 10 decimal places\n     *\n     * @param alpha argument\n     * @return the log of the gamma function of the given alpha\n     *\/","41":"\/**\n     * Incomplete Gamma function Q(a,x)\n     * (a cleanroom implementation of Numerical Recipes gammq(a,x);\n     * in Mathematica this function is called GammaRegularized)\n     *\n     * @param a parameter\n     * @param x argument\n     * @return function value\n     *\/","42":"\/**\n     * Incomplete Gamma function P(a,x) = 1-Q(a,x)\n     * (a cleanroom implementation of Numerical Recipes gammp(a,x);\n     * in Mathematica this function is 1-GammaRegularized)\n     *\n     * @param a parameter\n     * @param x argument\n     * @return function value\n     *\/","43":"\/**\n     * Incomplete Gamma function P(a,x) = 1-Q(a,x)\n     * (a cleanroom implementation of Numerical Recipes gammp(a,x);\n     * in Mathematica this function is 1-GammaRegularized)\n     *\n     * @param a        parameter\n     * @param x        argument\n     * @param lnGammaA precomputed lnGamma(a)\n     * @return function value\n     *\/","44":"\/**\n     * Returns the incomplete gamma ratio I(x,alpha) where x is the upper\n     * limit of the integration and alpha is the shape parameter.\n     *\n     * @param x              upper limit of integration\n     * @param alpha          shape parameter\n     * @param ln_gamma_alpha the log gamma function for alpha\n     * @return the incomplete gamma ratio\n     *\/","45":"\/**\n     * compute covariance\n     *\n     * @param x list of numbers\n     * @param y list of numbers\n     * @return covariance of x and y\n     *\/","46":"\/**\n     * compute fisher skewness\n     *\n     * @param x list of numbers\n     * @return skewness of x\n     *\/","47":"\/**\n     * Determine the highest posterior density for a list of values.\n     * The HPD is the smallest interval containing the required amount of elements.\n     *\n     * @param proportion of elements inside the interval\n     * @param x          values\n     * @param indices    index sorting x\n     * @return the interval, an array of {low, high} values.\n     *\/","48":"\/**\n     * compute the cumulative probability Pr(x <= z) for a given z\n     * and a distribution of x\n     *\n     * @param z threshold value\n     * @param x discrete distribution (an unordered list of numbers)\n     * @return cumulative probability\n     *\/","49":""},"numCommentLines":{"0":8,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":5,"13":5,"14":6,"15":0,"16":0,"17":6,"18":0,"19":6,"20":7,"21":5,"22":5,"23":4,"24":5,"25":7,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":5,"41":8,"42":8,"43":9,"44":8,"45":6,"46":5,"47":8,"48":7,"49":0},"numCommentChars":{"0":277,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":245,"13":208,"14":272,"15":0,"16":0,"17":249,"18":0,"19":287,"20":360,"21":282,"22":296,"23":165,"24":256,"25":439,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":198,"41":271,"42":277,"43":337,"44":363,"45":145,"46":110,"47":362,"48":255,"49":0},"packageName":{"0":"com.astrazeneca.vardict.data.fishertest","1":"com.astrazeneca.vardict.data.fishertest","2":"com.astrazeneca.vardict.data.fishertest","3":"com.astrazeneca.vardict.data.fishertest","4":"com.astrazeneca.vardict.data.fishertest","5":"com.astrazeneca.vardict.data.fishertest","6":"com.astrazeneca.vardict.data.fishertest","7":"com.astrazeneca.vardict.data.fishertest","8":"com.astrazeneca.vardict.data.fishertest","9":"com.astrazeneca.vardict.data.fishertest","10":"com.astrazeneca.vardict.data.fishertest","11":"com.astrazeneca.vardict.data.fishertest","12":"com.astrazeneca.vardict","13":"com.astrazeneca.vardict","14":"com.astrazeneca.vardict","15":"com.astrazeneca.vardict","16":"com.astrazeneca.vardict","17":"com.astrazeneca.vardict","18":"com.astrazeneca.vardict","19":"com.astrazeneca.vardict","20":"com.astrazeneca.vardict","21":"com.astrazeneca.vardict","22":"com.astrazeneca.vardict","23":"com.astrazeneca.vardict","24":"com.astrazeneca.vardict","25":"com.astrazeneca.vardict","26":"com.astrazeneca.vardict","27":"com.astrazeneca.vardict","28":"com.astrazeneca.vardict","29":"com.astrazeneca.vardict","30":"uk.ac.ebi.pride.toolsuite.gui.aspera","31":"uk.ac.ebi.pride.toolsuite.gui.aspera","32":"uk.ac.ebi.pride.toolsuite.gui.aspera","33":"algo","34":"algo","35":"algo","36":"algo","37":"algo","38":"algo","39":"algo","40":"beast.base.util","41":"beast.base.util","42":"beast.base.util","43":"beast.base.util","44":"beast.base.util","45":"beast.base.util","46":"beast.base.util","47":"beast.base.util","48":"beast.base.util","49":"beast.base.util"},"repoName":{"0":"AstraZeneca-NGS,VarDictJava","1":"AstraZeneca-NGS,VarDictJava","2":"AstraZeneca-NGS,VarDictJava","3":"AstraZeneca-NGS,VarDictJava","4":"AstraZeneca-NGS,VarDictJava","5":"AstraZeneca-NGS,VarDictJava","6":"AstraZeneca-NGS,VarDictJava","7":"AstraZeneca-NGS,VarDictJava","8":"AstraZeneca-NGS,VarDictJava","9":"AstraZeneca-NGS,VarDictJava","10":"AstraZeneca-NGS,VarDictJava","11":"AstraZeneca-NGS,VarDictJava","12":"AstraZeneca-NGS,VarDictJava","13":"AstraZeneca-NGS,VarDictJava","14":"AstraZeneca-NGS,VarDictJava","15":"AstraZeneca-NGS,VarDictJava","16":"AstraZeneca-NGS,VarDictJava","17":"AstraZeneca-NGS,VarDictJava","18":"AstraZeneca-NGS,VarDictJava","19":"AstraZeneca-NGS,VarDictJava","20":"AstraZeneca-NGS,VarDictJava","21":"AstraZeneca-NGS,VarDictJava","22":"AstraZeneca-NGS,VarDictJava","23":"AstraZeneca-NGS,VarDictJava","24":"AstraZeneca-NGS,VarDictJava","25":"AstraZeneca-NGS,VarDictJava","26":"AstraZeneca-NGS,VarDictJava","27":"AstraZeneca-NGS,VarDictJava","28":"AstraZeneca-NGS,VarDictJava","29":"AstraZeneca-NGS,VarDictJava","30":"PRIDE-Toolsuite,pride-inspector","31":"PRIDE-Toolsuite,pride-inspector","32":"PRIDE-Toolsuite,pride-inspector","33":"ctlab,metafast","34":"ctlab,metafast","35":"ctlab,metafast","36":"ctlab,metafast","37":"ctlab,metafast","38":"ctlab,metafast","39":"ctlab,metafast","40":"CompEvol,beast2","41":"CompEvol,beast2","42":"CompEvol,beast2","43":"CompEvol,beast2","44":"CompEvol,beast2","45":"CompEvol,beast2","46":"CompEvol,beast2","47":"CompEvol,beast2","48":"CompEvol,beast2","49":"CompEvol,beast2"},"imports":{"0":[],"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"13":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"14":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"15":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"16":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"17":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"18":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"19":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"20":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"21":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"22":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"23":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"24":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"25":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"26":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"27":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"28":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"29":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[]},"additionalImports":{"0":{},"1":{},"2":{},"3":{},"4":{},"5":{},"6":{},"7":{},"8":{},"9":{},"10":{},"11":{},"12":{},"13":{},"14":{},"15":{},"16":{},"17":{},"18":{},"19":{},"20":{},"21":{},"22":{},"23":{},"24":{},"25":{},"26":{},"27":{},"28":{},"29":{},"30":{},"31":{},"32":{},"33":{},"34":{},"35":{},"36":{},"37":{},"38":{},"39":{},"40":{},"41":{},"42":{},"43":{},"44":{},"45":{},"46":{},"47":{},"48":{},"49":{}},"intraClassFieldsUsed":{"0":"","1":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","2":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","3":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","4":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","5":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","6":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","7":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","8":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","9":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","10":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate void calculatePValue();\nprivate double pnhyper(int q, boolean upper_tail);\n","11":"private List<Double> logdc;\nprivate int m;\nprivate int n;\nprivate int k;\nprivate int x;\nprivate int lo;\nprivate int hi;\nprivate double PvalueLess;\nprivate double PvalueGreater;\nprivate double PvalueTwoSided;\nprivate List<Integer> support;\npublic static double RESULT_ROUND_R = 1E5;\nprivate List<Double> logdcDhyper(int m, int n, int k);\nprivate Double mle(double x);\nprivate Double mnhyper(Double ncp);\nprivate List<Double> dnhyper(Double ncp);\npublic String getOddRatio();\npublic double getPValue();\npublic List<Double> getLogdc();\npublic double getPValueGreater();\npublic double getPValueLess();\nprivate double round_as_r(double value);\nprivate void calculatePValue();\n","12":"public static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","13":"public static String toString(Collection<E> collection);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","14":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","15":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","16":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","17":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","18":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","19":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","20":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","21":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","22":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","23":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","24":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","25":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","26":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","27":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","28":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static char complement(char character);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","29":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region);\n","30":"public static String stringFromSizeFraction(long numerator, long denominator);\npublic static String stringFromSizeFraction(String numerator, String denominator);\n","31":"public static String stringFromRate(long bps);\npublic static String stringFromSizeFraction(String numerator, String denominator);\n","32":"public static String stringFromRate(long bps);\npublic static String stringFromSizeFraction(long numerator, long denominator);\n","33":"public static long[] possibleNeighbours(long kmerRepr, int k);\npublic static long[] calcNeighbours(long kmer, int k);\npublic static long[] leftNeighbours(long kmerRepr, int k);\npublic static long rc(long kmer, long k);\n","34":"public static long[] possibleNeighbours(long kmerRepr, int k);\npublic static long[] calcNeighbours(long kmer, int k);\npublic static long[] rightNeighbours(long kmer, int k);\npublic static long[] leftNeighbours(long kmerRepr, int k);\n","35":"private static final int POWER = 20;\npublic static long addValue(long value, int color);\npublic static long addValue(long value, int color, short add);\npublic static long setValue(long value, int color, long newColorValue);\npublic static long clearValue(long value, int color);\npublic static int getColor(long value, double perc);\n","36":"private static final int POWER = 20;\npublic static long getValue(long value, int color);\npublic static long addValue(long value, int color, short add);\npublic static long setValue(long value, int color, long newColorValue);\npublic static long clearValue(long value, int color);\npublic static int getColor(long value, double perc);\n","37":"private static final int POWER = 20;\npublic static long getValue(long value, int color);\npublic static long addValue(long value, int color);\npublic static long setValue(long value, int color, long newColorValue);\npublic static long clearValue(long value, int color);\npublic static int getColor(long value, double perc);\n","38":"private static final int POWER = 20;\npublic static long getValue(long value, int color);\npublic static long addValue(long value, int color);\npublic static long addValue(long value, int color, short add);\npublic static long setValue(long value, int color, long newColorValue);\npublic static int getColor(long value, double perc);\n","39":"private static final int POWER = 20;\npublic static long getValue(long value, int color);\npublic static long addValue(long value, int color);\npublic static long addValue(long value, int color, short add);\npublic static long setValue(long value, int color, long newColorValue);\npublic static long clearValue(long value, int color);\n","40":"public static double incompleteGammaQ(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x, final double lnGammaA);\nprivate static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha);\n","41":"public static double lnGamma(final double alpha);\npublic static double incompleteGammaP(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x, final double lnGammaA);\nprivate static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha);\n","42":"public static double lnGamma(final double alpha);\npublic static double incompleteGammaQ(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x, final double lnGammaA);\nprivate static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha);\n","43":"public static double lnGamma(final double alpha);\npublic static double incompleteGammaQ(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x);\nprivate static double incompleteGamma(final double x, final double alpha, final double ln_gamma_alpha);\n","44":"public static double lnGamma(final double alpha);\npublic static double incompleteGammaQ(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x);\npublic static double incompleteGammaP(final double a, final double x, final double lnGammaA);\n","45":"public static double mean(double[] x);\npublic static double median(double[] x, int[] indices);\npublic static double meanSquaredError(double[] x, double trueValue);\npublic static double median(double[] x);\npublic static double variance(double[] x, double mean);\npublic static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev);\npublic static double skewness(double[] x);\npublic static double stdev(double[] x);\npublic static double variance(double[] x);\npublic static double varianceSampleMean(double[] x, double mean);\npublic static double varianceSampleMean(double[] x);\npublic static double quantile(double q, double[] x, int[] indices);\npublic static double quantile(double q, double[] x);\npublic static double quantile(double q, double[] x, int count);\npublic static double[] HPDInterval(double proportion, double[] x, int[] indices);\npublic static double cdf(double z, double[] x, int[] indices);\npublic static double cdf(double z, double[] x);\npublic static double max(double[] x);\npublic static double min(double[] x);\npublic static double geometricMean(double[] x);\n","46":"public static double mean(double[] x);\npublic static double median(double[] x, int[] indices);\npublic static double meanSquaredError(double[] x, double trueValue);\npublic static double median(double[] x);\npublic static double variance(double[] x, double mean);\npublic static double covariance(double[] x, double[] y);\npublic static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev);\npublic static double stdev(double[] x);\npublic static double variance(double[] x);\npublic static double varianceSampleMean(double[] x, double mean);\npublic static double varianceSampleMean(double[] x);\npublic static double quantile(double q, double[] x, int[] indices);\npublic static double quantile(double q, double[] x);\npublic static double quantile(double q, double[] x, int count);\npublic static double[] HPDInterval(double proportion, double[] x, int[] indices);\npublic static double cdf(double z, double[] x, int[] indices);\npublic static double cdf(double z, double[] x);\npublic static double max(double[] x);\npublic static double min(double[] x);\npublic static double geometricMean(double[] x);\n","47":"public static double mean(double[] x);\npublic static double median(double[] x, int[] indices);\npublic static double meanSquaredError(double[] x, double trueValue);\npublic static double median(double[] x);\npublic static double variance(double[] x, double mean);\npublic static double covariance(double[] x, double[] y);\npublic static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev);\npublic static double skewness(double[] x);\npublic static double stdev(double[] x);\npublic static double variance(double[] x);\npublic static double varianceSampleMean(double[] x, double mean);\npublic static double varianceSampleMean(double[] x);\npublic static double quantile(double q, double[] x, int[] indices);\npublic static double quantile(double q, double[] x);\npublic static double quantile(double q, double[] x, int count);\npublic static double cdf(double z, double[] x, int[] indices);\npublic static double cdf(double z, double[] x);\npublic static double max(double[] x);\npublic static double min(double[] x);\npublic static double geometricMean(double[] x);\n","48":"public static double mean(double[] x);\npublic static double median(double[] x, int[] indices);\npublic static double meanSquaredError(double[] x, double trueValue);\npublic static double median(double[] x);\npublic static double variance(double[] x, double mean);\npublic static double covariance(double[] x, double[] y);\npublic static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev);\npublic static double skewness(double[] x);\npublic static double stdev(double[] x);\npublic static double variance(double[] x);\npublic static double varianceSampleMean(double[] x, double mean);\npublic static double varianceSampleMean(double[] x);\npublic static double quantile(double q, double[] x, int[] indices);\npublic static double quantile(double q, double[] x);\npublic static double quantile(double q, double[] x, int count);\npublic static double[] HPDInterval(double proportion, double[] x, int[] indices);\npublic static double cdf(double z, double[] x, int[] indices);\npublic static double max(double[] x);\npublic static double min(double[] x);\npublic static double geometricMean(double[] x);\n","49":"public static double mean(double[] x);\npublic static double median(double[] x, int[] indices);\npublic static double meanSquaredError(double[] x, double trueValue);\npublic static double median(double[] x);\npublic static double variance(double[] x, double mean);\npublic static double covariance(double[] x, double[] y);\npublic static double covariance(double[] x, double[] y, double xmean, double ymean, double xstdev, double ystdev);\npublic static double skewness(double[] x);\npublic static double stdev(double[] x);\npublic static double variance(double[] x);\npublic static double varianceSampleMean(double[] x, double mean);\npublic static double varianceSampleMean(double[] x);\npublic static double quantile(double q, double[] x, int[] indices);\npublic static double quantile(double q, double[] x);\npublic static double quantile(double q, double[] x, int count);\npublic static double[] HPDInterval(double proportion, double[] x, int[] indices);\npublic static double cdf(double z, double[] x, int[] indices);\npublic static double cdf(double z, double[] x);\npublic static double max(double[] x);\npublic static double min(double[] x);\n"}}