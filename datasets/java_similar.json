{"golden":{"0":"public String buildHGVSText(AminoAcidCode code) {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(anno.getSymbolAndAnnotation(code));\n    }\n    return builder.toString();\n}","1":"public void setOrCheckLane(final int lane) {\n    if (laneIsSet()) {\n        if (this.lane != lane) {\n            throw new PicardException(\"Lane number mismatch for \" + this + \" : \" + this.lane + \" != \" + lane);\n        }\n    } else {\n        this.lane = lane;\n    }\n}","2":"\/**\n * Entry point to run command line argument validation only.\n *\/\n@Override\npublic Object instanceMain(final String[] argv) {\n    if (targetCommandLineProgram instanceof PicardCommandLineProgramExecutor) {\n        return ((PicardCommandLineProgramExecutor) targetCommandLineProgram).validateArgs(argv);\n    } else {\n        \/\/ just call parseArgs and then return\n        return targetCommandLineProgram.parseArgs(argv);\n    }\n}","3":"\/**\n * Add a value to be stored in the histogram\n * @param d Data to be added to the histogram\n *\/\npublic void add(final Double d) {\n    if (d.isNaN()) {\n        return;\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","4":"public void setOrCheckY(final int y) {\n    if (yIsSet()) {\n        if (this.y != y) {\n            throw new PicardException(\"Y value mismatch for \" + this + \" : \" + this.y + \" != \" + y);\n        }\n    } else {\n        this.y = y;\n    }\n}","5":"public void setOrCheckX(final int x) {\n    if (xIsSet()) {\n        if (this.x != x) {\n            throw new PicardException(\"X value mismatch for \" + this + \" : \" + this.x + \" != \" + x);\n        }\n    } else {\n        this.x = x;\n    }\n}","6":"public void setOrCheckTile(final int tile) {\n    if (tileIsSet()) {\n        if (this.tile != tile) {\n            throw new PicardException(\"Tile number mismatch for \" + this + \" : \" + this.tile + \" != \" + tile);\n        }\n    } else {\n        this.tile = tile;\n    }\n}","7":"public void add(final Double d, final int count) {\n    if (count < 1) {\n        throw new GATKException(\"Cannot add non-positive counts to Histogram.\");\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey, count);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","8":"protected boolean ignoreAlignment(final SAMRecord sam) {\n    if (maxGaps == -1)\n        return false;\n    int gaps = 0;\n    for (final CigarElement el : sam.getCigar().getCigarElements()) {\n        if (el.getOperator() == CigarOperator.I || el.getOperator() == CigarOperator.D) {\n            gaps++;\n        }\n    }\n    return gaps > maxGaps;\n}","9":"public HaplotypeMap withoutChromosomes(final Set<String> chroms) {\n    final HaplotypeMap out = new HaplotypeMap(getHeader());\n    for (final HaplotypeBlock block : this.haplotypeBlocks) {\n        if (!chroms.contains(block.getFirstSnp().getChrom())) {\n            out.addHaplotype(block);\n        }\n    }\n    return out;\n}","10":"public String buildEffectText() {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(Joiner.on(\"+\").join(anno.getEffects()));\n    }\n    return builder.toString();\n}","11":"private byte[][] parseBaseCalls(final InfiniumFileTOC toc) throws IOException {\n    stream.skipBytes(toc.getOffset());\n    final int arrayLen = Integer.reverseBytes(stream.readInt());\n    final byte[][] curBaseCalls = new byte[arrayLen][2];\n    for (int i = 0; i < arrayLen; i++) {\n        byte[] baseCallBytes = curBaseCalls[i];\n        for (int j = 0; j < baseCallBytes.length; j++) {\n            baseCallBytes[j] = stream.readByte();\n            if (baseCallBytes[j] == 0) {\n                baseCallBytes[j] = NO_CALL_CHAR;\n            }\n        }\n    }\n    return curBaseCalls;\n}","12":"private static List<dbSNPNormalized> cleanResults(List<dbSNPNormalized> snpList) {\n    Collections.sort(snpList);\n    int value = snpList.size() > 0 ? snpList.get(0).getConfidence() : Integer.MIN_VALUE;\n    List<dbSNPNormalized> topResult = new ArrayList<dbSNPNormalized>();\n    Set<Integer> seen = new HashSet<Integer>();\n    for (dbSNPNormalized snp : snpList) {\n        if (value == snp.getConfidence() && !seen.contains(snp.getRsID())) {\n            topResult.add(snp);\n            seen.add(snp.getRsID());\n        }\n    }\n    return topResult;\n}","13":"public double getDefaultScore() {\n    Object[] scoresArray = scores.values().toArray();\n    Object[] scoresArrayValue = ((Map<SearchEngineScoreCvTermReference, Number>) scoresArray[0]).values().toArray();\n    double scoreValue = -1;\n    for (Object aScoresArrayValue : scoresArrayValue) {\n        if (aScoresArrayValue != null) {\n            scoreValue = ((Double) aScoresArrayValue);\n            return scoreValue;\n        }\n    }\n    return scoreValue;\n}","14":"private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) {\n    if (!s1.getReadName().equals(s2.getReadName())) {\n        throw new PicardException(\"Read names do not match: \" + s1.getReadName() + \" : \" + s2.getReadName());\n    }\n    catalogDuplicateDifferences(s1, s2);\n    final AlignmentComparison comp = compareAlignmentRecords(s1, s2);\n    comparisonMetric.updateMetric(comp);\n    if (samComparisonArgumentCollection.COMPARE_MQ) {\n        compareAndUpdateMappingQualityConcordance(s1, s2);\n    }\n}","15":"public static byte getOrientationByte(final boolean read1NegativeStrand, final boolean read2NegativeStrand) {\n    if (read1NegativeStrand) {\n        if (read2NegativeStrand)\n            return ReadEnds.RR;\n        else\n            return ReadEnds.RF;\n    } else {\n        if (read2NegativeStrand)\n            return ReadEnds.FR;\n        else\n            return ReadEnds.FF;\n    }\n}","16":"public static int getNumIndelBases(SAMRecord read) {\n    int numIndelBases = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndelBases += element.getLength();\n        }\n    }\n    return numIndelBases;\n}","17":"public double median(final double[] data) {\n    final int len = data.length;\n    final int mid = len \/ 2;\n    if (data.length % 2 == 0) {\n        return (data[mid] + data[mid - 1]) \/ 2d;\n    } else {\n        return data[mid];\n    }\n}","18":"private static ImmutableList<String> parseHeader(String line) {\n    ImmutableList.Builder<String> extraHeaderBuilder = new ImmutableList.Builder<String>();\n    Iterator<String> it = Splitter.on('\\t').split(line.trim().substring(1)).iterator();\n    for (int i = 0; it.hasNext(); ++i) if (i < 6)\n        it.next();\n    else\n        extraHeaderBuilder.add(it.next());\n    return extraHeaderBuilder.build();\n}","19":"public DoubleMatrix2D getS() {\n    double[][] S = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            S[i][j] = 0.0;\n        }\n        S[i][i] = this.s[i];\n    }\n    return DoubleFactory2D.dense.make(S);\n}","20":"@Override\npublic synchronized BitSet getFingerprint(IAtomContainer mol) throws CDKException {\n    if (!has2DCoordinates(mol)) {\n        StructureDiagramGenerator structureDiagramGenerator = new StructureDiagramGenerator();\n        structureDiagramGenerator.setMolecule(mol, true);\n        if (isConnected(mol)) {\n            structureDiagramGenerator.generateCoordinates();\n            mol = structureDiagramGenerator.getMolecule();\n        } else {\n            LOGGER.debug(\"Disconnected components needs to be layout separately\");\n        }\n    }\n    return fingerprinter.getBitFingerprint(mol).asBitSet();\n}","21":"private void deleteObject(File folder, String aFileName) {\n    String fileName = aFileName + extension;\n    if (new File(folder, fileName).exists()) {\n        boolean deleted = new File(folder, fileName).delete();\n        if (!deleted) {\n            JOptionPane.showMessageDialog(null, \"Failed to delete the file \\'\" + new File(folder, fileName).getAbsolutePath() + \"\\'.\\n\" + \"Please delete the file manually.\", \"File Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}","22":"@Deprecated\nstatic boolean wouldBeSymbolicAllele(byte[] bases) {\n    if (bases.length <= 1)\n        return false;\n    else {\n        return bases[0] == Allele.SYMBOLIC_ALLELE_START || bases[bases.length - 1] == Allele.SYMBOLIC_ALLELE_END || wouldBeBreakpoint(bases) || wouldBeSingleBreakend(bases);\n    }\n}","23":"private int compareCoordinates(final SAMRecord samRecord1, final SAMRecord samRecord2) {\n    final int refIndex1 = header.getSequenceIndex(samRecord1.getReferenceName());\n    final int refIndex2 = header.getSequenceIndex(samRecord2.getReferenceName());\n    if (refIndex1 == -1) {\n        return refIndex2 == -1 ? 0 : 1;\n    } else if (refIndex2 == -1) {\n        return -1;\n    }\n    final int cmp = refIndex1 - refIndex2;\n    if (cmp != 0) {\n        return cmp;\n    }\n    return samRecord1.getAlignmentStart() - samRecord2.getAlignmentStart();\n}","24":"public String phred64ToPhred33(String phred64) {\n    StringBuffer phred33 = new StringBuffer();\n    for (int i = 0; i < phred64.length(); i++) {\n        phred33.append((char) (phred64.charAt(i) - PHRED33_TO_PHRED64_DIFF));\n    }\n    return phred33.toString();\n}","25":"public int rank() {\n    double eps = Math.pow(2.0, -52.0);\n    double tol = Math.max(m, n) * s[0] * eps;\n    int r = 0;\n    for (int i = 0; i < s.length; i++) {\n        if (s[i] > tol) {\n            r++;\n        }\n    }\n    return r;\n}","26":"private static byte[] getReadBases(final SAMRecord read) {\n    if (!read.getReadNegativeStrandFlag()) {\n        return read.getReadBases();\n    } else {\n        final byte[] reverseComplementedBases = new byte[read.getReadBases().length];\n        System.arraycopy(read.getReadBases(), 0, reverseComplementedBases, 0, reverseComplementedBases.length);\n        SequenceUtil.reverseComplement(reverseComplementedBases);\n        return reverseComplementedBases;\n    }\n}","27":"public void addAll(final List<T> objects, final List<? extends Locatable> intervals) {\n    if (objects == null) {\n        throw new IllegalArgumentException(\"null objects\");\n    }\n    if (intervals == null) {\n        throw new IllegalArgumentException(\"null intervals\");\n    }\n    if (objects.size() != intervals.size()) {\n        throw new IllegalArgumentException(\"Objects and intervals must be the same size but were \" + objects.size() + \" and \" + intervals.size());\n    }\n    for (int i = 0; i < objects.size(); ++i) {\n        addLhs(objects.get(i), intervals.get(i));\n    }\n}","28":"public static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region) {\n    String firstPart = \"There was Exception while processing \" + place + \" on \" + placeDef;\n    String secondPart = \". The processing will be continued from the next \" + place + \".\";\n    if (region != null) {\n        System.err.println(firstPart + \" on region \" + region.printRegion() + secondPart);\n        exception.printStackTrace();\n    } else {\n        System.err.println(firstPart + \" but region is undefined\" + secondPart);\n        exception.printStackTrace();\n    }\n    int currentCount = instance().conf.exceptionCounter.incrementAndGet();\n    if (currentCount > Configuration.MAX_EXCEPTION_COUNT) {\n        System.err.println(\"VarDictJava fails (there were \" + instance().conf.exceptionCounter.get() + \" continued exceptions during the run).\");\n        throw new RuntimeException(exception);\n    }\n}","29":"public final void shuffle(int[] array, int numberOfShuffles) {\n    int i, j, temp, l = array.length;\n    for (int shuffle = 0; shuffle < numberOfShuffles; shuffle++) {\n        do {\n            i = nextInt(l);\n            j = nextInt(l);\n        } while (i != j);\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","30":"private void initialize(double[][] components) {\n    int n = components.length;\n    rows = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) rows[i][j] = components[i][j];\n    }\n    initialize();\n}","31":"public boolean liesInIntron(GenomePosition pos) {\n    for (int i = 0; i + 1 < transcript.getExonRegions().size(); ++i) {\n        GenomeInterval intronRegion = transcript.intronRegion(i);\n        if (intronRegion.contains(pos))\n            return true;\n    }\n    return false;\n}","32":"public ImmutableSet<String> getParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.getFather() != null)\n            parentNames.add(member.getFather().getName());\n        if (member.getMother() != null)\n            parentNames.add(member.getMother().getName());\n    }\n    return parentNames.build();\n}","33":"public final void permute(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","34":"\/**\n * @return True if we have more clusters to read\n *\/\npublic boolean hasNext() {\n    final boolean more = parsers[0].hasNext();\n    if (!more) {\n        for (int i = 1; i < parsers.length; i++) {\n            if (parsers[i].hasNext()) {\n                throw new PicardException(\"Unequal length Illumina files in \" + basecallDirectory + \", lane \" + lane + \". Failing parser: \" + parsers[i].getClass().getName());\n            }\n        }\n    }\n    return more;\n}","35":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<Integer, Integer> object1, Map<Integer, Integer> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","36":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<IAtom, IAtom> object1, Map<IAtom, IAtom> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","37":"private static final List<ReadDescriptor> readStructureStringToDescriptors(final String readStructure) {\n    final Matcher fullMatcher = FullPattern.matcher(readStructure);\n    if (!fullMatcher.matches()) {\n        throw new IllegalArgumentException(readStructure + \" cannot be parsed as a ReadStructure! \" + ReadStructureMsg);\n    }\n    final Matcher subMatcher = SubPattern.matcher(readStructure);\n    final List<ReadDescriptor> descriptors = new ArrayList<>();\n    while (subMatcher.find()) {\n        final ReadDescriptor rd = new ReadDescriptor(Integer.parseInt(subMatcher.group(1)), ReadType.valueOf(subMatcher.group(2)));\n        descriptors.add(rd);\n    }\n    return descriptors;\n}","38":"protected double[][] productComponents(double a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) newComponents[i][j] = a * components[i][j];\n    }\n    return newComponents;\n}","39":"public ImmutableSet<String> getAffectedMaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isMale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","40":"public ImmutableSet<String> getAffectedFemaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isFemale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","41":"@Override\npublic Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer, boolean getNoneAssesments) {\n    Map<IAtom, IStereoAndConformation> chiralities = new HashMap<>();\n    WedgeStereoLifter lifter = new WedgeStereoLifter();\n    for (IAtom atom : atomContainer.atoms()) {\n        IStereoAndConformation chirality = getChirality2D(lifter, atom, atomContainer);\n        if (getNoneAssesments || chirality != NONE) {\n            chiralities.put(atom, chirality);\n        }\n    }\n    return chiralities;\n}","42":"public final void shuffle(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","43":"public static int getNumIndels(SAMRecord read) {\n    int numIndels = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndels += 1;\n        }\n    }\n    return numIndels;\n}","44":"private double[] forwardSubstitution(double[] c) {\n    int n = rows.length;\n    double[] answer = new double[n];\n    for (int i = 0; i < n; i++) {\n        answer[i] = c[permutation[i]];\n        for (int j = 0; j <= i - 1; j++) answer[i] -= rows[i][j] * answer[j];\n    }\n    return answer;\n}","45":"\/**\n * constructor taking a pattern source\n *\n * @param patterns a pattern of a microsatellite locus\n *\/\n@Override\npublic double pairwiseDistance(int taxon1, int taxon2) {\n    int[] pattern = patterns.getPattern(0);\n    int state1 = pattern[taxon1];\n    int state2 = pattern[taxon2];\n    double distance = 0.0;\n    if (!dataType.isAmbiguousCode(state1) && !dataType.isAmbiguousCode(state2))\n        distance = Math.abs(state1 - state2);\n    return distance;\n}","46":"protected double[][] subtractComponents(Matrix a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) newComponents[i][j] = components[i][j] - a.components[i][j];\n    }\n    return newComponents;\n}","47":"public static void reverseComplementSqArray(final byte[] sqArray) {\n    final int lastIndex = sqArray.length - 1;\n    int i, j;\n    for (i = 0, j = lastIndex; i < j; ++i, --j) {\n        final byte tmp = complementSqValue(sqArray[i]);\n        sqArray[i] = complementSqValue(sqArray[j]);\n        sqArray[j] = tmp;\n    }\n    if (sqArray.length % 2 == 1) {\n        sqArray[i] = complementSqValue(sqArray[i]);\n    }\n}","48":"\/**\n * Check if given SAMRecord violates sort order relative to previous SAMRecord.\n * @return True if sort order is unsorted, if this is the first record, or if previous <= rec.\n *\/\npublic boolean isSorted(final SAMRecord rec) {\n    if (comparator == null) {\n        return true;\n    }\n    boolean ret = true;\n    if (prev != null) {\n        ret = comparator.fileOrderCompare(prev, rec) <= 0;\n    }\n    prev = rec;\n    return ret;\n}","49":"private static <T> BiFunction<Set<T>, Set<T>, Set<T>> mergeSetsAccountingForSingletons() {\n    return (newValue, oldValue) -> {\n        final Set<T> mutableSet = oldValue.size() == 1 ? new HashSet<>() : oldValue;\n        mutableSet.addAll(oldValue);\n        mutableSet.addAll(newValue);\n        return mutableSet;\n    };\n}"},"comment_lines":{"0":2,"1":2,"2":2,"3":3,"4":2,"5":2,"6":2,"7":4,"8":3,"9":3,"10":2,"11":6,"12":7,"13":4,"14":2,"15":2,"16":2,"17":2,"18":2,"19":3,"20":5,"21":5,"22":3,"23":5,"24":2,"25":2,"26":3,"27":5,"28":8,"29":2,"30":2,"31":2,"32":2,"33":2,"34":2,"35":5,"36":5,"37":5,"38":3,"39":2,"40":2,"41":5,"42":2,"43":2,"44":3,"45":4,"46":3,"47":4,"48":3,"49":2},"tokens":{"0":91,"1":74,"2":82,"3":111,"4":71,"5":71,"6":71,"7":106,"8":89,"9":83,"10":87,"11":150,"12":151,"13":106,"14":132,"15":95,"16":92,"17":70,"18":92,"19":89,"20":116,"21":101,"22":89,"23":149,"24":78,"25":85,"26":110,"27":131,"28":185,"29":94,"30":72,"31":72,"32":84,"33":71,"34":115,"35":122,"36":126,"37":133,"38":88,"39":102,"40":102,"41":146,"42":70,"43":84,"44":92,"45":117,"46":93,"47":121,"48":107,"49":78},"lines":{"0":10,"1":8,"2":8,"3":10,"4":8,"5":8,"6":8,"7":10,"8":9,"9":9,"10":10,"11":15,"12":16,"13":11,"14":11,"15":8,"16":10,"17":8,"18":9,"19":9,"20":13,"21":11,"22":9,"23":14,"24":8,"25":10,"26":9,"27":14,"28":17,"29":11,"30":8,"31":8,"32":9,"33":8,"34":11,"35":12,"36":12,"37":14,"38":9,"39":11,"40":11,"41":12,"42":8,"43":10,"44":9,"45":13,"46":9,"47":12,"48":10,"49":9},"parameters":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":2,"8":1,"9":1,"10":0,"11":1,"12":1,"13":0,"14":2,"15":2,"16":1,"17":1,"18":1,"19":0,"20":1,"21":2,"22":1,"23":2,"24":1,"25":0,"26":1,"27":2,"28":4,"29":2,"30":1,"31":1,"32":0,"33":1,"34":0,"35":2,"36":2,"37":1,"38":1,"39":0,"40":0,"41":2,"42":1,"43":1,"44":1,"45":2,"46":1,"47":1,"48":1,"49":0},"functions":{"0":1,"1":2,"2":2,"3":2,"4":2,"5":2,"6":2,"7":2,"8":2,"9":3,"10":1,"11":2,"12":3,"13":3,"14":4,"15":2,"16":0,"17":0,"18":0,"19":1,"20":1,"21":3,"22":0,"23":0,"24":0,"25":1,"26":2,"27":0,"28":7,"29":0,"30":0,"31":0,"32":0,"33":0,"34":2,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":6,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0},"globals":{"0":0,"1":0,"2":0,"3":0,"4":0,"5":0,"6":0,"7":0,"8":0,"9":0,"10":0,"11":0,"12":0,"13":0,"14":0,"15":0,"16":0,"17":0,"18":0,"19":0,"20":0,"21":0,"22":0,"23":0,"24":0,"25":0,"26":0,"27":0,"28":0,"29":0,"30":0,"31":0,"32":0,"33":0,"34":0,"35":0,"36":0,"37":0,"38":0,"39":0,"40":0,"41":0,"42":0,"43":0,"44":0,"45":0,"46":0,"47":0,"48":0,"49":0},"imports":{"0":1,"1":0,"2":0,"3":2,"4":0,"5":0,"6":0,"7":2,"8":3,"9":0,"10":1,"11":4,"12":3,"13":0,"14":3,"15":0,"16":2,"17":1,"18":2,"19":0,"20":1,"21":2,"22":2,"23":2,"24":0,"25":0,"26":0,"27":1,"28":1,"29":2,"30":0,"31":0,"32":1,"33":2,"34":4,"35":2,"36":2,"37":3,"38":0,"39":1,"40":1,"41":2,"42":2,"43":2,"44":0,"45":0,"46":0,"47":0,"48":0,"49":1}}