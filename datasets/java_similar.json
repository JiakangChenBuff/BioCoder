{"numParams":{"0":1,"1":1,"2":1,"3":1,"4":1,"5":1,"6":1,"7":2,"8":1,"9":1,"10":0,"11":1,"12":1,"13":0,"14":2,"15":2,"16":1,"17":1,"18":1,"19":0,"20":1,"21":2,"22":1,"23":2,"24":1,"25":0,"26":1,"27":2,"28":4,"29":2,"30":1,"31":1,"32":0,"33":1,"34":0,"35":2,"36":2,"37":1,"38":1,"39":0,"40":0,"41":2,"42":1,"43":1,"44":1,"45":2,"46":1,"47":1,"48":1,"49":0},"numLines":{"0":10,"1":8,"2":8,"3":10,"4":8,"5":8,"6":8,"7":10,"8":9,"9":9,"10":10,"11":15,"12":16,"13":11,"14":11,"15":8,"16":10,"17":8,"18":9,"19":9,"20":13,"21":11,"22":9,"23":14,"24":8,"25":10,"26":9,"27":14,"28":17,"29":11,"30":8,"31":8,"32":9,"33":8,"34":11,"35":12,"36":12,"37":14,"38":9,"39":11,"40":11,"41":12,"42":8,"43":10,"44":9,"45":13,"46":9,"47":12,"48":10,"49":9},"numChars":{"0":415,"1":268,"2":430,"3":424,"4":237,"5":237,"6":268,"7":414,"8":344,"9":323,"10":404,"11":583,"12":550,"13":456,"14":519,"15":381,"16":347,"17":233,"18":405,"19":255,"20":610,"21":471,"22":306,"23":545,"24":261,"25":235,"26":465,"27":580,"28":923,"29":349,"30":235,"31":277,"32":417,"33":239,"34":463,"35":473,"36":465,"37":688,"38":300,"39":509,"40":513,"41":539,"42":239,"43":313,"44":290,"45":459,"46":318,"47":412,"48":433,"49":322},"lineStart":{"0":79,"1":110,"2":24,"3":42,"4":160,"5":135,"6":85,"7":59,"8":385,"9":353,"10":64,"11":458,"12":280,"13":158,"14":415,"15":66,"16":181,"17":356,"18":77,"19":474,"20":70,"21":459,"22":244,"23":67,"24":29,"25":515,"26":275,"27":111,"28":261,"29":492,"30":173,"31":200,"32":65,"33":465,"34":93,"35":49,"36":50,"37":196,"38":285,"39":95,"40":79,"41":102,"42":479,"43":229,"44":154,"45":17,"46":426,"47":135,"48":44,"49":94},"lineEnd":{"0":89,"1":118,"2":32,"3":52,"4":168,"5":143,"6":93,"7":69,"8":394,"9":362,"10":74,"11":473,"12":296,"13":169,"14":426,"15":74,"16":191,"17":364,"18":86,"19":483,"20":83,"21":470,"22":253,"23":81,"24":37,"25":525,"26":284,"27":125,"28":278,"29":503,"30":181,"31":208,"32":74,"33":473,"34":104,"35":61,"36":62,"37":210,"38":294,"39":106,"40":90,"41":114,"42":487,"43":239,"44":163,"45":30,"46":435,"47":147,"48":54,"49":103},"returnType":{"0":"String","1":"void","2":"Object","3":"void","4":"void","5":"void","6":"void","7":"void","8":"boolean","9":"HaplotypeMap","10":"String","11":"byte[][]","12":"List<dbSNPNormalized>","13":"double","14":"void","15":"byte","16":"int","17":"double","18":"ImmutableList<String>","19":"DoubleMatrix2D","20":"BitSet","21":"void","22":"boolean","23":"int","24":"String","25":"int","26":"byte[]","27":"void","28":"void","29":"void","30":"void","31":"boolean","32":"ImmutableSet<String>","33":"void","34":"boolean","35":"int","36":"int","37":"List<ReadDescriptor>","38":"double[][]","39":"ImmutableSet<String>","40":"ImmutableSet<String>","41":"Map<IAtom,IStereoAndConformation>","42":"void","43":"int","44":"double[]","45":"double","46":"double[][]","47":"void","48":"boolean","49":"BiFunction<Set<T>,Set<T>,Set<T>>"},"params":{"0":["AminoAcidCode code"],"1":["final int lane"],"2":["final String[] argv"],"3":["final Double d"],"4":["final int y"],"5":["final int x"],"6":["final int tile"],"7":["final Double d","final int count"],"8":["final SAMRecord sam"],"9":["final Set<String> chroms"],"10":[],"11":["final InfiniumFileTOC toc"],"12":["List<dbSNPNormalized> snpList"],"13":[],"14":["final SAMRecord s1","final SAMRecord s2"],"15":["final boolean read1NegativeStrand","final boolean read2NegativeStrand"],"16":["SAMRecord read"],"17":["final double[] data"],"18":["String line"],"19":[],"20":["IAtomContainer mol"],"21":["File folder","String aFileName"],"22":["byte[] bases"],"23":["final SAMRecord samRecord1","final SAMRecord samRecord2"],"24":["String phred64"],"25":[],"26":["final SAMRecord read"],"27":["final List<T> objects","final List<? extends Locatable> intervals"],"28":["Exception exception","String place","String placeDef","Region region"],"29":["int[] array","int numberOfShuffles"],"30":["double[][] components"],"31":["GenomePosition pos"],"32":[],"33":["int[] array"],"34":[],"35":["Map<Integer, Integer> object1","Map<Integer, Integer> object2"],"36":["Map<IAtom, IAtom> object1","Map<IAtom, IAtom> object2"],"37":["final String readStructure"],"38":["double a"],"39":[],"40":[],"41":["IAtomContainer atomContainer","boolean getNoneAssesments"],"42":["int[] array"],"43":["SAMRecord read"],"44":["double[] c"],"45":["int taxon1","int taxon2"],"46":["Matrix a"],"47":["final byte[] sqArray"],"48":["final SAMRecord rec"],"49":[]},"filePath":{"0":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/annotation\/VariantAnnotationsTextGenerator.java","1":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/ClusterData.java","2":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/cmdline\/CommandLineArgumentValidator.java","3":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/utils\/Histogram.java","4":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/ClusterData.java","5":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/ClusterData.java","6":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/ClusterData.java","7":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/utils\/Histogram.java","8":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/sam\/SamAlignmentMerger.java","9":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/fingerprint\/HaplotypeMap.java","10":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/annotation\/VariantAnnotationsTextGenerator.java","11":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/arrays\/illumina\/InfiniumGTCFile.java","12":"\/home\/ubuntu\/repos\/rockt,SETH\/src\/main\/java\/de\/hu\/berlin\/wbi\/objects\/MutationMention.java","13":"\/home\/ubuntu\/repos\/PRIDE-Utilities,ms-data-core-api\/src\/main\/java\/uk\/ac\/ebi\/pride\/utilities\/data\/core\/Score.java","14":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/sam\/util\/SamComparison.java","15":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/sam\/markduplicates\/util\/ReadEnds.java","16":"\/home\/ubuntu\/repos\/mozack,abra\/src\/main\/java\/abra\/SAMRecordUtils.java","17":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/utils\/MannWhitneyU.java","18":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/pedigree\/PedFileReader.java","19":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/RobustSingularValueDecomposition.java","20":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/fingerprints\/FingerprintGenerator.java","21":"\/home\/ubuntu\/repos\/compomics,compomics-utilities\/src\/main\/java\/com\/compomics\/util\/pride\/PrideObjectsFactory.java","22":"\/home\/ubuntu\/repos\/samtools,htsjdk\/src\/main\/java\/htsjdk\/variant\/variantcontext\/Allele.java","23":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/utils\/read\/HeaderlessSAMRecordCoordinateComparator.java","24":"\/home\/ubuntu\/repos\/mozack,abra\/src\/main\/java\/abra\/QualityConverter.java","25":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/RobustSingularValueDecomposition.java","26":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/util\/ClippingUtility.java","27":"\/home\/ubuntu\/repos\/samtools,htsjdk\/src\/main\/java\/htsjdk\/samtools\/util\/OverlapDetector.java","28":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/Utils.java","29":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/MersenneTwisterFast.java","30":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/LUPDecomposition.java","31":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/reference\/TranscriptSequenceOntologyDecorator.java","32":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/pedigree\/PedigreeQueryDecorator.java","33":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/MersenneTwisterFast.java","34":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/IlluminaDataProvider.java","35":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/org\/openscience\/smsd\/algorithm\/ventofoggia\/Map1ValueComparator.java","36":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/org\/openscience\/smsd\/algorithm\/ventofoggia\/Map2ValueComparator.java","37":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/illumina\/parser\/ReadStructure.java","38":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/Matrix.java","39":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/pedigree\/PedigreeQueryDecorator.java","40":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/pedigree\/PedigreeQueryDecorator.java","41":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/stereo\/tools\/Chirality2DTool.java","42":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/util\/MersenneTwisterFast.java","43":"\/home\/ubuntu\/repos\/mozack,abra\/src\/main\/java\/abra\/SAMRecordUtils.java","44":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/LUPDecomposition.java","45":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/evolution\/distance\/SMMDistance.java","46":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/matrixalgebra\/Matrix.java","47":"\/home\/ubuntu\/repos\/samtools,htsjdk\/src\/main\/java\/htsjdk\/samtools\/SQTagUtil.java","48":"\/home\/ubuntu\/repos\/samtools,htsjdk\/src\/main\/java\/htsjdk\/samtools\/SAMSortOrderChecker.java","49":"\/home\/ubuntu\/repos\/samtools,htsjdk\/src\/main\/java\/htsjdk\/samtools\/util\/OverlapDetector.java"},"signature":{"0":"public String buildHGVSText(AminoAcidCode code)","1":"public void setOrCheckLane(final int lane)","2":"public Object instanceMain(final String[] argv)","3":"public void add(final Double d)","4":"public void setOrCheckY(final int y)","5":"public void setOrCheckX(final int x)","6":"public void setOrCheckTile(final int tile)","7":"public void add(final Double d, final int count)","8":"protected boolean ignoreAlignment(final SAMRecord sam)","9":"public HaplotypeMap withoutChromosomes(final Set<String> chroms)","10":"public String buildEffectText()","11":"private byte[][] parseBaseCalls(final InfiniumFileTOC toc) throws IOException","12":"private static List<dbSNPNormalized> cleanResults(List<dbSNPNormalized> snpList)","13":"public double getDefaultScore()","14":"private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2)","15":"public static byte getOrientationByte(final boolean read1NegativeStrand, final boolean read2NegativeStrand)","16":"public static int getNumIndelBases(SAMRecord read)","17":"public double median(final double[] data)","18":"private static ImmutableList<String> parseHeader(String line)","19":"public DoubleMatrix2D getS()","20":"public synchronized BitSet getFingerprint(IAtomContainer mol) throws CDKException","21":"private void deleteObject(File folder, String aFileName)","22":" static boolean wouldBeSymbolicAllele(byte[] bases)","23":"private int compareCoordinates(final SAMRecord samRecord1, final SAMRecord samRecord2)","24":"public String phred64ToPhred33(String phred64)","25":"public int rank()","26":"private static byte[] getReadBases(final SAMRecord read)","27":"public void addAll(final List<T> objects, final List<? extends Locatable> intervals)","28":"public static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region)","29":"public final void shuffle(int[] array, int numberOfShuffles)","30":"private void initialize(double[][] components)","31":"public boolean liesInIntron(GenomePosition pos)","32":"public ImmutableSet<String> getParentNames()","33":"public final void permute(int[] array)","34":"public boolean hasNext()","35":"public int compare(Map<Integer, Integer> object1, Map<Integer, Integer> object2)","36":"public int compare(Map<IAtom, IAtom> object1, Map<IAtom, IAtom> object2)","37":"private static final List<ReadDescriptor> readStructureStringToDescriptors(final String readStructure)","38":"protected double[][] productComponents(double a)","39":"public ImmutableSet<String> getAffectedMaleParentNames()","40":"public ImmutableSet<String> getAffectedFemaleParentNames()","41":"public Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer, boolean getNoneAssesments)","42":"public final void shuffle(int[] array)","43":"public static int getNumIndels(SAMRecord read)","44":"private double[] forwardSubstitution(double[] c)","45":"public double pairwiseDistance(int taxon1, int taxon2)","46":"protected double[][] subtractComponents(Matrix a)","47":"public static void reverseComplementSqArray(final byte[] sqArray)","48":"public boolean isSorted(final SAMRecord rec)","49":"private static BiFunction<Set<T>, Set<T>, Set<T>> mergeSetsAccountingForSingletons()"},"content":{"0":"public String buildHGVSText(AminoAcidCode code) {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(anno.getSymbolAndAnnotation(code));\n    }\n    return builder.toString();\n}","1":"public void setOrCheckLane(final int lane) {\n    if (laneIsSet()) {\n        if (this.lane != lane) {\n            throw new PicardException(\"Lane number mismatch for \" + this + \" : \" + this.lane + \" != \" + lane);\n        }\n    } else {\n        this.lane = lane;\n    }\n}","2":"\/**\n * Entry point to run command line argument validation only.\n *\/\n@Override\npublic Object instanceMain(final String[] argv) {\n    if (targetCommandLineProgram instanceof PicardCommandLineProgramExecutor) {\n        return ((PicardCommandLineProgramExecutor) targetCommandLineProgram).validateArgs(argv);\n    } else {\n        \/\/ just call parseArgs and then return\n        return targetCommandLineProgram.parseArgs(argv);\n    }\n}","3":"\/**\n * Add a value to be stored in the histogram\n * @param d Data to be added to the histogram\n *\/\npublic void add(final Double d) {\n    if (d.isNaN()) {\n        return;\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","4":"public void setOrCheckY(final int y) {\n    if (yIsSet()) {\n        if (this.y != y) {\n            throw new PicardException(\"Y value mismatch for \" + this + \" : \" + this.y + \" != \" + y);\n        }\n    } else {\n        this.y = y;\n    }\n}","5":"public void setOrCheckX(final int x) {\n    if (xIsSet()) {\n        if (this.x != x) {\n            throw new PicardException(\"X value mismatch for \" + this + \" : \" + this.x + \" != \" + x);\n        }\n    } else {\n        this.x = x;\n    }\n}","6":"public void setOrCheckTile(final int tile) {\n    if (tileIsSet()) {\n        if (this.tile != tile) {\n            throw new PicardException(\"Tile number mismatch for \" + this + \" : \" + this.tile + \" != \" + tile);\n        }\n    } else {\n        this.tile = tile;\n    }\n}","7":"public void add(final Double d, final int count) {\n    if (count < 1) {\n        throw new GATKException(\"Cannot add non-positive counts to Histogram.\");\n    }\n    long binKey = getBinnedValue(d);\n    if (isValidBinKey(binKey)) {\n        dataList.add((int) binKey, count);\n    } else {\n        throw new GATKException(\"Histogram values are suspiciously extreme.  Failed to add \" + d + \" to the Histogram.\");\n    }\n}","8":"protected boolean ignoreAlignment(final SAMRecord sam) {\n    if (maxGaps == -1)\n        return false;\n    int gaps = 0;\n    for (final CigarElement el : sam.getCigar().getCigarElements()) {\n        if (el.getOperator() == CigarOperator.I || el.getOperator() == CigarOperator.D) {\n            gaps++;\n        }\n    }\n    return gaps > maxGaps;\n}","9":"public HaplotypeMap withoutChromosomes(final Set<String> chroms) {\n    final HaplotypeMap out = new HaplotypeMap(getHeader());\n    for (final HaplotypeBlock block : this.haplotypeBlocks) {\n        if (!chroms.contains(block.getFirstSnp().getChrom())) {\n            out.addHaplotype(block);\n        }\n    }\n    return out;\n}","10":"public String buildEffectText() {\n    StringBuilder builder = new StringBuilder();\n    for (Annotation anno : getAnnotations()) {\n        if (builder.length() != 0)\n            builder.append(',');\n        if (altCount > 1)\n            builder.append(StringUtil.concatenate(\"alt\", alleleID + 1, \":\"));\n        builder.append(Joiner.on(\"+\").join(anno.getEffects()));\n    }\n    return builder.toString();\n}","11":"private byte[][] parseBaseCalls(final InfiniumFileTOC toc) throws IOException {\n    stream.skipBytes(toc.getOffset());\n    final int arrayLen = Integer.reverseBytes(stream.readInt());\n    final byte[][] curBaseCalls = new byte[arrayLen][2];\n    for (int i = 0; i < arrayLen; i++) {\n        byte[] baseCallBytes = curBaseCalls[i];\n        for (int j = 0; j < baseCallBytes.length; j++) {\n            baseCallBytes[j] = stream.readByte();\n            if (baseCallBytes[j] == 0) {\n                baseCallBytes[j] = NO_CALL_CHAR;\n            }\n        }\n    }\n    return curBaseCalls;\n}","12":"private static List<dbSNPNormalized> cleanResults(List<dbSNPNormalized> snpList) {\n    Collections.sort(snpList);\n    int value = snpList.size() > 0 ? snpList.get(0).getConfidence() : Integer.MIN_VALUE;\n    List<dbSNPNormalized> topResult = new ArrayList<dbSNPNormalized>();\n    Set<Integer> seen = new HashSet<Integer>();\n    for (dbSNPNormalized snp : snpList) {\n        if (value == snp.getConfidence() && !seen.contains(snp.getRsID())) {\n            topResult.add(snp);\n            seen.add(snp.getRsID());\n        }\n    }\n    return topResult;\n}","13":"public double getDefaultScore() {\n    Object[] scoresArray = scores.values().toArray();\n    Object[] scoresArrayValue = ((Map<SearchEngineScoreCvTermReference, Number>) scoresArray[0]).values().toArray();\n    double scoreValue = -1;\n    for (Object aScoresArrayValue : scoresArrayValue) {\n        if (aScoresArrayValue != null) {\n            scoreValue = ((Double) aScoresArrayValue);\n            return scoreValue;\n        }\n    }\n    return scoreValue;\n}","14":"private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) {\n    if (!s1.getReadName().equals(s2.getReadName())) {\n        throw new PicardException(\"Read names do not match: \" + s1.getReadName() + \" : \" + s2.getReadName());\n    }\n    catalogDuplicateDifferences(s1, s2);\n    final AlignmentComparison comp = compareAlignmentRecords(s1, s2);\n    comparisonMetric.updateMetric(comp);\n    if (samComparisonArgumentCollection.COMPARE_MQ) {\n        compareAndUpdateMappingQualityConcordance(s1, s2);\n    }\n}","15":"public static byte getOrientationByte(final boolean read1NegativeStrand, final boolean read2NegativeStrand) {\n    if (read1NegativeStrand) {\n        if (read2NegativeStrand)\n            return ReadEnds.RR;\n        else\n            return ReadEnds.RF;\n    } else {\n        if (read2NegativeStrand)\n            return ReadEnds.FR;\n        else\n            return ReadEnds.FF;\n    }\n}","16":"public static int getNumIndelBases(SAMRecord read) {\n    int numIndelBases = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndelBases += element.getLength();\n        }\n    }\n    return numIndelBases;\n}","17":"public double median(final double[] data) {\n    final int len = data.length;\n    final int mid = len \/ 2;\n    if (data.length % 2 == 0) {\n        return (data[mid] + data[mid - 1]) \/ 2d;\n    } else {\n        return data[mid];\n    }\n}","18":"private static ImmutableList<String> parseHeader(String line) {\n    ImmutableList.Builder<String> extraHeaderBuilder = new ImmutableList.Builder<String>();\n    Iterator<String> it = Splitter.on('\\t').split(line.trim().substring(1)).iterator();\n    for (int i = 0; it.hasNext(); ++i) if (i < 6)\n        it.next();\n    else\n        extraHeaderBuilder.add(it.next());\n    return extraHeaderBuilder.build();\n}","19":"public DoubleMatrix2D getS() {\n    double[][] S = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            S[i][j] = 0.0;\n        }\n        S[i][i] = this.s[i];\n    }\n    return DoubleFactory2D.dense.make(S);\n}","20":"@Override\npublic synchronized BitSet getFingerprint(IAtomContainer mol) throws CDKException {\n    if (!has2DCoordinates(mol)) {\n        StructureDiagramGenerator structureDiagramGenerator = new StructureDiagramGenerator();\n        structureDiagramGenerator.setMolecule(mol, true);\n        if (isConnected(mol)) {\n            structureDiagramGenerator.generateCoordinates();\n            mol = structureDiagramGenerator.getMolecule();\n        } else {\n            LOGGER.debug(\"Disconnected components needs to be layout separately\");\n        }\n    }\n    return fingerprinter.getBitFingerprint(mol).asBitSet();\n}","21":"private void deleteObject(File folder, String aFileName) {\n    String fileName = aFileName + extension;\n    if (new File(folder, fileName).exists()) {\n        boolean deleted = new File(folder, fileName).delete();\n        if (!deleted) {\n            JOptionPane.showMessageDialog(null, \"Failed to delete the file \\'\" + new File(folder, fileName).getAbsolutePath() + \"\\'.\\n\" + \"Please delete the file manually.\", \"File Error\", JOptionPane.ERROR_MESSAGE);\n        }\n    }\n}","22":"@Deprecated\nstatic boolean wouldBeSymbolicAllele(byte[] bases) {\n    if (bases.length <= 1)\n        return false;\n    else {\n        return bases[0] == Allele.SYMBOLIC_ALLELE_START || bases[bases.length - 1] == Allele.SYMBOLIC_ALLELE_END || wouldBeBreakpoint(bases) || wouldBeSingleBreakend(bases);\n    }\n}","23":"private int compareCoordinates(final SAMRecord samRecord1, final SAMRecord samRecord2) {\n    final int refIndex1 = header.getSequenceIndex(samRecord1.getReferenceName());\n    final int refIndex2 = header.getSequenceIndex(samRecord2.getReferenceName());\n    if (refIndex1 == -1) {\n        return refIndex2 == -1 ? 0 : 1;\n    } else if (refIndex2 == -1) {\n        return -1;\n    }\n    final int cmp = refIndex1 - refIndex2;\n    if (cmp != 0) {\n        return cmp;\n    }\n    return samRecord1.getAlignmentStart() - samRecord2.getAlignmentStart();\n}","24":"public String phred64ToPhred33(String phred64) {\n    StringBuffer phred33 = new StringBuffer();\n    for (int i = 0; i < phred64.length(); i++) {\n        phred33.append((char) (phred64.charAt(i) - PHRED33_TO_PHRED64_DIFF));\n    }\n    return phred33.toString();\n}","25":"public int rank() {\n    double eps = Math.pow(2.0, -52.0);\n    double tol = Math.max(m, n) * s[0] * eps;\n    int r = 0;\n    for (int i = 0; i < s.length; i++) {\n        if (s[i] > tol) {\n            r++;\n        }\n    }\n    return r;\n}","26":"private static byte[] getReadBases(final SAMRecord read) {\n    if (!read.getReadNegativeStrandFlag()) {\n        return read.getReadBases();\n    } else {\n        final byte[] reverseComplementedBases = new byte[read.getReadBases().length];\n        System.arraycopy(read.getReadBases(), 0, reverseComplementedBases, 0, reverseComplementedBases.length);\n        SequenceUtil.reverseComplement(reverseComplementedBases);\n        return reverseComplementedBases;\n    }\n}","27":"public void addAll(final List<T> objects, final List<? extends Locatable> intervals) {\n    if (objects == null) {\n        throw new IllegalArgumentException(\"null objects\");\n    }\n    if (intervals == null) {\n        throw new IllegalArgumentException(\"null intervals\");\n    }\n    if (objects.size() != intervals.size()) {\n        throw new IllegalArgumentException(\"Objects and intervals must be the same size but were \" + objects.size() + \" and \" + intervals.size());\n    }\n    for (int i = 0; i < objects.size(); ++i) {\n        addLhs(objects.get(i), intervals.get(i));\n    }\n}","28":"public static void printExceptionAndContinue(Exception exception, String place, String placeDef, Region region) {\n    String firstPart = \"There was Exception while processing \" + place + \" on \" + placeDef;\n    String secondPart = \". The processing will be continued from the next \" + place + \".\";\n    if (region != null) {\n        System.err.println(firstPart + \" on region \" + region.printRegion() + secondPart);\n        exception.printStackTrace();\n    } else {\n        System.err.println(firstPart + \" but region is undefined\" + secondPart);\n        exception.printStackTrace();\n    }\n    int currentCount = instance().conf.exceptionCounter.incrementAndGet();\n    if (currentCount > Configuration.MAX_EXCEPTION_COUNT) {\n        System.err.println(\"VarDictJava fails (there were \" + instance().conf.exceptionCounter.get() + \" continued exceptions during the run).\");\n        throw new RuntimeException(exception);\n    }\n}","29":"public final void shuffle(int[] array, int numberOfShuffles) {\n    int i, j, temp, l = array.length;\n    for (int shuffle = 0; shuffle < numberOfShuffles; shuffle++) {\n        do {\n            i = nextInt(l);\n            j = nextInt(l);\n        } while (i != j);\n        temp = array[j];\n        array[j] = array[i];\n        array[i] = temp;\n    }\n}","30":"private void initialize(double[][] components) {\n    int n = components.length;\n    rows = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) rows[i][j] = components[i][j];\n    }\n    initialize();\n}","31":"public boolean liesInIntron(GenomePosition pos) {\n    for (int i = 0; i + 1 < transcript.getExonRegions().size(); ++i) {\n        GenomeInterval intronRegion = transcript.intronRegion(i);\n        if (intronRegion.contains(pos))\n            return true;\n    }\n    return false;\n}","32":"public ImmutableSet<String> getParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.getFather() != null)\n            parentNames.add(member.getFather().getName());\n        if (member.getMother() != null)\n            parentNames.add(member.getMother().getName());\n    }\n    return parentNames.build();\n}","33":"public final void permute(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","34":"\/**\n * @return True if we have more clusters to read\n *\/\npublic boolean hasNext() {\n    final boolean more = parsers[0].hasNext();\n    if (!more) {\n        for (int i = 1; i < parsers.length; i++) {\n            if (parsers[i].hasNext()) {\n                throw new PicardException(\"Unequal length Illumina files in \" + basecallDirectory + \", lane \" + lane + \". Failing parser: \" + parsers[i].getClass().getName());\n            }\n        }\n    }\n    return more;\n}","35":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<Integer, Integer> object1, Map<Integer, Integer> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","36":"\/**\n * @param object1\n * @param object2\n * @return\n *\/\n@Override\npublic int compare(Map<IAtom, IAtom> object1, Map<IAtom, IAtom> object2) {\n    int size1 = object1.size();\n    int size2 = object2.size();\n    int compare = Integer.signum(Integer.valueOf(size1).compareTo(size2));\n    if (sortOrder == SortOrder.ASCENDING) {\n        return compare;\n    } else {\n        return compare * (-1);\n    }\n    \/\/return size2 - size1;  assumes you want biggest to smallest;\n}","37":"private static final List<ReadDescriptor> readStructureStringToDescriptors(final String readStructure) {\n    final Matcher fullMatcher = FullPattern.matcher(readStructure);\n    if (!fullMatcher.matches()) {\n        throw new IllegalArgumentException(readStructure + \" cannot be parsed as a ReadStructure! \" + ReadStructureMsg);\n    }\n    final Matcher subMatcher = SubPattern.matcher(readStructure);\n    final List<ReadDescriptor> descriptors = new ArrayList<>();\n    while (subMatcher.find()) {\n        final ReadDescriptor rd = new ReadDescriptor(Integer.parseInt(subMatcher.group(1)), ReadType.valueOf(subMatcher.group(2)));\n        descriptors.add(rd);\n    }\n    return descriptors;\n}","38":"protected double[][] productComponents(double a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) newComponents[i][j] = a * components[i][j];\n    }\n    return newComponents;\n}","39":"public ImmutableSet<String> getAffectedMaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isMale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","40":"public ImmutableSet<String> getAffectedFemaleParentNames() {\n    ImmutableSet.Builder<String> parentNames = new ImmutableSet.Builder<String>();\n    for (Person member : pedigree.getMembers()) {\n        if (member.isAffected() && member.isFemale()) {\n            if (member.getFather() != null)\n                parentNames.add(member.getFather().getName());\n            if (member.getMother() != null)\n                parentNames.add(member.getMother().getName());\n        }\n    }\n    return parentNames.build();\n}","41":"@Override\npublic Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer, boolean getNoneAssesments) {\n    Map<IAtom, IStereoAndConformation> chiralities = new HashMap<>();\n    WedgeStereoLifter lifter = new WedgeStereoLifter();\n    for (IAtom atom : atomContainer.atoms()) {\n        IStereoAndConformation chirality = getChirality2D(lifter, atom, atomContainer);\n        if (getNoneAssesments || chirality != NONE) {\n            chiralities.put(atom, chirality);\n        }\n    }\n    return chiralities;\n}","42":"public final void shuffle(int[] array) {\n    int l = array.length;\n    for (int i = 0; i < l; i++) {\n        int index = nextInt(l - i) + i;\n        int temp = array[index];\n        array[index] = array[i];\n        array[i] = temp;\n    }\n}","43":"public static int getNumIndels(SAMRecord read) {\n    int numIndels = 0;\n    for (CigarElement element : read.getCigar().getCigarElements()) {\n        if ((element.getOperator() == CigarOperator.D) || (element.getOperator() == CigarOperator.I)) {\n            numIndels += 1;\n        }\n    }\n    return numIndels;\n}","44":"private double[] forwardSubstitution(double[] c) {\n    int n = rows.length;\n    double[] answer = new double[n];\n    for (int i = 0; i < n; i++) {\n        answer[i] = c[permutation[i]];\n        for (int j = 0; j <= i - 1; j++) answer[i] -= rows[i][j] * answer[j];\n    }\n    return answer;\n}","45":"\/**\n * constructor taking a pattern source\n *\n * @param patterns a pattern of a microsatellite locus\n *\/\n@Override\npublic double pairwiseDistance(int taxon1, int taxon2) {\n    int[] pattern = patterns.getPattern(0);\n    int state1 = pattern[taxon1];\n    int state2 = pattern[taxon2];\n    double distance = 0.0;\n    if (!dataType.isAmbiguousCode(state1) && !dataType.isAmbiguousCode(state2))\n        distance = Math.abs(state1 - state2);\n    return distance;\n}","46":"protected double[][] subtractComponents(Matrix a) {\n    int n = this.rows();\n    int m = this.columns();\n    double[][] newComponents = new double[n][m];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) newComponents[i][j] = components[i][j] - a.components[i][j];\n    }\n    return newComponents;\n}","47":"public static void reverseComplementSqArray(final byte[] sqArray) {\n    final int lastIndex = sqArray.length - 1;\n    int i, j;\n    for (i = 0, j = lastIndex; i < j; ++i, --j) {\n        final byte tmp = complementSqValue(sqArray[i]);\n        sqArray[i] = complementSqValue(sqArray[j]);\n        sqArray[j] = tmp;\n    }\n    if (sqArray.length % 2 == 1) {\n        sqArray[i] = complementSqValue(sqArray[i]);\n    }\n}","48":"\/**\n * Check if given SAMRecord violates sort order relative to previous SAMRecord.\n * @return True if sort order is unsorted, if this is the first record, or if previous <= rec.\n *\/\npublic boolean isSorted(final SAMRecord rec) {\n    if (comparator == null) {\n        return true;\n    }\n    boolean ret = true;\n    if (prev != null) {\n        ret = comparator.fileOrderCompare(prev, rec) <= 0;\n    }\n    prev = rec;\n    return ret;\n}","49":"private static <T> BiFunction<Set<T>, Set<T>, Set<T>> mergeSetsAccountingForSingletons() {\n    return (newValue, oldValue) -> {\n        final Set<T> mutableSet = oldValue.size() == 1 ? new HashSet<>() : oldValue;\n        mutableSet.addAll(oldValue);\n        mutableSet.addAll(newValue);\n        return mutableSet;\n    };\n}"},"comment":{"0":"\/**\n\t * @return String with the effect text, comma separated if {@link #getAnnotations} returns more than one element\n\t *\/","1":"\/**\n     * Either set this value if not already set, or if already set, throw an exception if new value != current value.\n     *\/","2":"\/**\n     * Entry point to run command line argument validation only.\n     *\/","3":"\/**\n     * Add a value to be stored in the histogram\n     * @param d Data to be added to the histogram\n     *\/","4":"\/**\n     * Either set this value if not already set, or if already set, throw an exception if new value != current value.\n     *\/","5":"\/**\n     * Either set this value if not already set, or if already set, throw an exception if new value != current value.\n     *\/","6":"\/**\n     * Either set this value if not already set, or if already set, throw an exception if new value != current value.\n     *\/","7":"\/**\n     * Add multiple copies of the same value into the histogram to be stored in the histogram\n     * @param d Data to be added to the histogram\n     * @param count number of repetitions of the value to add to the histogram\n     *\/","8":"\/**\n     * For now, we ignore only those alignments that have more than {@link #maxGaps} insertions\n     * or deletions.\n     *\/","9":"\/**\n     * Returns a copy of this haplotype map that excludes haplotypes on the chromosomes provided.\n     * @param chroms a set of zero or more chromosome names\n     *\/","10":"\/**\n\t * @return String with the effect text, comma separated if {@link #getAnnotations} returns more than one element\n\t *\/","11":"\/**\n     * Utility method for parsing out the basecalls. (- for no call)\n     *\n     * @param toc The table of contents record for parsing the basecalls.\n     * @return A string array containing all of the basecall values.\n     * @throws IOException is thrown when there is a problem reading the stream.\n     *\/","12":"\/**\n     * Sometimes one SNP mention can be normalized to the same dbSNP identifier\n     * several times. As some information is stored redundant.\n     * Therefore we have to remove some duplicates from the list and\n     * also we return only the results with highest score (no impact for evaluation)\n     * @param snpList   List of SNPs to be cleansed\n     * @return Cleansed SNP list\n     *\/","13":"\/**\r\n     * Get the Default score for Search Engine\r\n     * <p\/>\r\n     * * @return score\r\n     *\/","14":"\/**\n     * Compare the mapping information for two SAMRecords.  Makes comparison of alignments, and also catalogs duplicate marking differences.\n     *\/","15":"\/**\n     * Returns a single byte that encodes the orientation of the two reads in a pair.\n     *\/","16":"\/**\n\t *  Returns total length of deletions and insertions for the input read. \n\t *\/","17":"\/**\n     * Finds or calculates the median value of a sorted array of double.\n     *\/","18":"\/**\n\t * Parse header and return extra header fields, <code>line<\/code> must start with <code>'#'<\/code>.\n\t *\/","19":"\/**\n    Returns the diagonal matrix of singular values.\n    @return     S\n    *\/","20":"\/**\n     *\n     * @param mol\n     * @return\n     * @throws CDKException\n     *\/","21":"\/**\n     * Deletes the given file.\n     *\n     * @param folder the folder where the file is located\n     * @param fileName the name of the file to delete\n     *\/","22":"\/**\n     * @param bases  bases representing an allele\n     * @return true if the bases represent a symbolic allele, including breakpoints and breakends\n     *\/","23":"\/**\n     * Compare the coordinates of two reads. If a read is paired and unmapped, use its mate mapping\n     * as its position.\n     *\n     * @return negative if samRecord1 < samRecord2,  0 if equal, else positive\n     *\/","24":"\/**\n\t * Convert from phred64 to phred33\n\t *\/","25":"\/**\n    Returns the effective numerical matrix rank, which is the number of nonnegligible singular values.\n    *\/","26":"\/**\n     * Returns an array of bytes representing the bases in the read,\n     * reverse complementing them if the read is on the negative strand\n     *\/","27":"\/**\n     * Adds all items to the overlap detector.\n     *\n     * The order of the lists matters only in the sense that it needs to be the same for the intervals\n     * and the corresponding objects.\n     *\/","28":"\/**\n     * Method calls on cycles where position and records are processing to skip number of Exceptions set in\n     * Configuration.MAX_EXCEPTION_COUNT to try continue work if not critical exception occurs and get partial results.\n     * Each Exception printed in STDERR. If limit of exceptions reaches, VarDict stops with last re-throwed Exception.\n     * @param exception exception to check on limit exceeded\n     * @param place characterizes designation of the place where Exception occurs (position, SAM record, etc)\n     * @param placeDef specific place (chromosome, name of record, etc)\n     * @param region region from BED file\/-R option\n     *\/","29":"\/**\n     * Shuffles an array. Shuffles numberOfShuffles times\n     *\/","30":"\/**\n\t * @param components double[][]  components obtained from constructor methods.\n\t *\/","31":"\/**\n\t * @return <code>true<\/code> if <code>pos<\/code> lies within an intron of {@link #transcript}\n\t *\/","32":"\/**\n\t * @return set with the name of the parents\n\t *\/","33":"\/**\n     * Returns a uniform random permutation of int objects in array\n     *\/","34":"\/**\n     * @return True if we have more clusters to read\n     *\/","35":"\/**\n     *\n     * @param object1\n     * @param object2\n     * @return\n     *\/","36":"\/**\n     *\n     * @param object1\n     * @param object2\n     * @return\n     *\/","37":"\/**\n     * Converts readStructureString into a List<ReadDescriptor>\n     * @param readStructure A string of the format <number of bases><type><number of bases><type>...<number of bases><type> describing\n     * a read structure\n     * @return A List<ReadDescriptor> corresponding to the input string\n     *\/","38":"\/**\n\t * @param a double\n\t * @return double[][]\n\t *\/","39":"\/**\n\t * @return set with the name of the parents from affected males.\n\t *\/","40":"\/**\n\t * @return set with the name of the parents from affected females.\n\t *\/","41":"\/**\n     *\n     * @param atomContainer\n     * @param getNoneAssesments\n     * @return\n     *\/","42":"\/**\n     * Shuffles an array.\n     *\/","43":"\/**\n\t * Return the number of insertions and deletions in a SAMRecord \n\t *\/","44":"\/**\n\t * @param c double[]\n\t * @return double[]\n\t *\/","45":"\/**\r\n     * constructor taking a pattern source\r\n     *\r\n     * @param patterns a pattern of a microsatellite locus\r\n     *\/","46":"\/**\n\t * @param a MatrixAlgebra.Matrix\n\t * @return double[][]\n\t *\/","47":"\/**\n     * Reverses and complements the sqValues in place.\n     * @param sqArray Array of SQ-values, with 2nd-best base in high-order 2 bits, and probability diff\n     * in low-order 6 bits.\n     *\/","48":"\/**\n     * Check if given SAMRecord violates sort order relative to previous SAMRecord.\n     * @return True if sort order is unsorted, if this is the first record, or if previous <= rec.\n     *\/","49":"\/**\n     * merge two Sets, assumes sets of size 1 are immutale\n     *\/"},"numCommentLines":{"0":2,"1":2,"2":2,"3":3,"4":2,"5":2,"6":2,"7":4,"8":3,"9":3,"10":2,"11":6,"12":7,"13":4,"14":2,"15":2,"16":2,"17":2,"18":2,"19":3,"20":5,"21":5,"22":3,"23":5,"24":2,"25":2,"26":3,"27":5,"28":8,"29":2,"30":2,"31":2,"32":2,"33":2,"34":2,"35":5,"36":5,"37":5,"38":3,"39":2,"40":2,"41":5,"42":2,"43":2,"44":3,"45":4,"46":3,"47":4,"48":3,"49":2},"numCommentChars":{"0":122,"1":129,"2":76,"3":110,"4":129,"5":129,"6":129,"7":234,"8":128,"9":169,"10":122,"11":311,"12":393,"13":97,"14":152,"15":97,"16":83,"17":84,"18":109,"19":80,"20":79,"21":161,"22":159,"23":221,"24":44,"25":113,"26":152,"27":206,"28":653,"29":69,"30":88,"31":103,"32":53,"33":79,"34":64,"35":77,"36":77,"37":306,"38":51,"39":74,"40":76,"41":93,"42":37,"43":74,"44":51,"45":124,"46":65,"47":198,"48":194,"49":70},"packageName":{"0":"de.charite.compbio.jannovar.annotation","1":"picard.illumina.parser","2":"org.broadinstitute.hellbender.cmdline","3":"org.broadinstitute.hellbender.utils","4":"picard.illumina.parser","5":"picard.illumina.parser","6":"picard.illumina.parser","7":"org.broadinstitute.hellbender.utils","8":"picard.sam","9":"picard.fingerprint","10":"de.charite.compbio.jannovar.annotation","11":"picard.arrays.illumina","12":"de.hu.berlin.wbi.objects","13":"uk.ac.ebi.pride.utilities.data.core","14":"picard.sam.util","15":"picard.sam.markduplicates.util","16":"abra","17":"org.broadinstitute.hellbender.utils","18":"de.charite.compbio.jannovar.pedigree","19":"beast.base.math.matrixalgebra","20":"uk.ac.ebi.reactionblast.fingerprints","21":"com.compomics.util.pride","22":"htsjdk.variant.variantcontext","23":"org.broadinstitute.hellbender.utils.read","24":"abra","25":"beast.base.math.matrixalgebra","26":"picard.util","27":"htsjdk.samtools.util","28":"com.astrazeneca.vardict","29":"beast.base.util","30":"beast.base.math.matrixalgebra","31":"de.charite.compbio.jannovar.reference","32":"de.charite.compbio.jannovar.pedigree","33":"beast.base.util","34":"picard.illumina.parser","35":"org.openscience.smsd.algorithm.ventofoggia","36":"org.openscience.smsd.algorithm.ventofoggia","37":"picard.illumina.parser","38":"beast.base.math.matrixalgebra","39":"de.charite.compbio.jannovar.pedigree","40":"de.charite.compbio.jannovar.pedigree","41":"uk.ac.ebi.reactionblast.stereo.tools","42":"beast.base.util","43":"abra","44":"beast.base.math.matrixalgebra","45":"beast.base.evolution.distance","46":"beast.base.math.matrixalgebra","47":"htsjdk.samtools","48":"htsjdk.samtools","49":"htsjdk.samtools.util"},"repoName":{"0":"charite,jannovar","1":"broadinstitute,picard","2":"broadinstitute,gatk","3":"broadinstitute,gatk","4":"broadinstitute,picard","5":"broadinstitute,picard","6":"broadinstitute,picard","7":"broadinstitute,gatk","8":"broadinstitute,picard","9":"broadinstitute,picard","10":"charite,jannovar","11":"broadinstitute,picard","12":"rockt,SETH","13":"PRIDE-Utilities,ms-data-core-api","14":"broadinstitute,picard","15":"broadinstitute,picard","16":"mozack,abra","17":"broadinstitute,gatk","18":"charite,jannovar","19":"CompEvol,beast2","20":"asad,ReactionDecoder","21":"compomics,compomics-utilities","22":"samtools,htsjdk","23":"broadinstitute,gatk","24":"mozack,abra","25":"CompEvol,beast2","26":"broadinstitute,picard","27":"samtools,htsjdk","28":"AstraZeneca-NGS,VarDictJava","29":"CompEvol,beast2","30":"CompEvol,beast2","31":"charite,jannovar","32":"charite,jannovar","33":"CompEvol,beast2","34":"broadinstitute,picard","35":"asad,ReactionDecoder","36":"asad,ReactionDecoder","37":"broadinstitute,picard","38":"CompEvol,beast2","39":"charite,jannovar","40":"charite,jannovar","41":"asad,ReactionDecoder","42":"CompEvol,beast2","43":"mozack,abra","44":"CompEvol,beast2","45":"CompEvol,beast2","46":"CompEvol,beast2","47":"samtools,htsjdk","48":"samtools,htsjdk","49":"samtools,htsjdk"},"imports":{"0":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class StringUtil {\n    public static String concatenate(Object... values)\n}\n","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/impl\/util\/StringUtil.java","methodCount":1,"lineCount":3}],"1":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"2":[{"fieldCount":1,"classCount":1,"methodsOnly":"public class GATKException {\n    private static final long serialVersionUID = 0L;;\n    public GATKException(String msg);\n    public GATKException(String message, Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/exceptions\/GATKException.java","methodCount":2,"lineCount":5}],"3":[{"fieldCount":1,"classCount":1,"methodsOnly":"public class GATKException {\n    private static final long serialVersionUID = 0L;;\n    public GATKException(String msg);\n    public GATKException(String message, Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/exceptions\/GATKException.java","methodCount":2,"lineCount":5}],"4":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"5":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"6":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"7":[{"fieldCount":1,"classCount":1,"methodsOnly":"public class GATKException {\n    private static final long serialVersionUID = 0L;;\n    public GATKException(String msg);\n    public GATKException(String message, Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,gatk\/src\/main\/java\/org\/broadinstitute\/hellbender\/exceptions\/GATKException.java","methodCount":2,"lineCount":5}],"8":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"9":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4},{"fieldCount":0,"classCount":1,"methodsOnly":"public class VcfUtils {\n    public static boolean isVariantFile(final File file)\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/vcf\/VcfUtils.java","methodCount":1,"lineCount":3}],"10":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class StringUtil {\n    public static String concatenate(Object... values)\n}\n","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/impl\/util\/StringUtil.java","methodCount":1,"lineCount":3}],"11":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"12":[{"fieldCount":2,"classCount":1,"methodsOnly":"public class MutationExtractor {\n    \/**\n * This method simple fills the two mappings between amino acid one letter code and the amino acid three letter code\n *\n * build a mapping from three-letter code to one-letter code\n *\/\npublic static Map<String, String> populateAminoAcidThreeToOneLookupMap = null;;\n    \/**\n * This method simple fills the two mappings between amino acid name and the amino acid one-letter code\n *\n * build a mapping from amino acid full name to one-letter code\n *\/\npublic static Map<String, String> populateAminoAcidNameToOneLookupMap = null;;\n    public abstract Map<Mutation, Set<int[]>> extractMutations(String rawText) throws MutationException\n    protected void warn(String message)\n    protected void error(String message)\n}\n","filePath":"\/home\/ubuntu\/repos\/rockt,SETH\/src\/main\/java\/edu\/uchsc\/ccp\/nlp\/ei\/mutation\/MutationExtractor.java","methodCount":3,"lineCount":7},{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/rockt,SETH\/src\/main\/java\/seth\/ner\/wrapper\/Type.java","methodCount":0,"lineCount":0}],"13":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class MapUtils {\n    private MapUtils();\n    public static Map<T, V> createMapFromMap(Map<T, V> map)\n    public static void replaceValuesInMap(Map<T, V> from, Map<T, V> to)\n}\n","filePath":"\/home\/ubuntu\/repos\/PRIDE-Utilities,ms-data-core-api\/src\/main\/java\/uk\/ac\/ebi\/pride\/utilities\/data\/utils\/MapUtils.java","methodCount":3,"lineCount":5}],"14":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4},{"fieldCount":11,"classCount":1,"methodsOnly":"public class SamComparisonMetric {\n    \/**\n * Left file used in comparison\n *\/\npublic String LEFT_FILE;;\n    \/**\n * Right file used in comparison\n *\/\npublic String RIGHT_FILE;;\n    \/**\n * The number of primary records for which mappings match in files.  If running in strict alignment mode, this counts only records\n * which are mapped in both files with the same alignment start positions and strands.  If running with LENIENT_LOW_MQ_ALIGNMENT=true, then\n * all records which are mapped in both files with mapping quality at most equal to LOW_MQ_THRESHOLD are counted as matching. If\n * running with LENIENT_255_MQ_ALIGNMENT=true, all records which are mapped in both files with mapping quality 255 are counted as matches.\n *\/\npublic int MAPPINGS_MATCH;;\n    \/**\n * The number of primary records which are mapped in both files but do not meet criteria to be counted in MAPPINGS_MATCH.\n *\/\npublic int MAPPINGS_DIFFER;;\n    \/**\n * The number of primary records which are not mapped in either file.\n *\/\npublic int UNMAPPED_BOTH;;\n    \/**\n * The number of primary records which are mapped in right file and found but not mapped in left file\n *\/\npublic int UNMAPPED_LEFT;;\n    \/**\n * The number of primary records which are mapped in left file and found but not mapped in right file\n *\/\npublic int UNMAPPED_RIGHT;;\n    \/**\n * The number of primary records which are found in right file but not found in left file\n *\/\npublic int MISSING_LEFT;;\n    \/**\n * The number of primary records which are found in left file but not found in right file\n *\/\npublic int MISSING_RIGHT;;\n    \/**\n * The number of primary records for which duplicate markings are different.  If running in strict duplicate\n * marking mode, any primary alignment which is marked as a duplicate in one file but not in the other will\n * be counted.  If running with LENIENT_DUP=true, we allow for swaps between duplicate and non-duplicate fragments\n * in the same duplicate set to reduce the number of fragments with different duplicate marking.  Note that this\n * metric is counted on a per read basis, so a paired end fragment which differs in duplicate marking between the two\n * files will increment this metric by 2.\n *\/\npublic int DUPLICATE_MARKINGS_DIFFER;;\n    \/**\n * Whether or not to consider the two input files equal.  The two input files are considered equal iff\n * MAPPINGS_DIFFER == UNMAPPED_LEFT == UNMAPPED_RIGHT == MISSING_LEFT == MISSING_RIGHT == DUPLICATE_MARKINGS_DIFFER == 0 &&\n * the headers have been compared to be equal.  Note that the header comparison result can be dependent on whether\n * the tool is run with LENIENT_HEADER true or false.\n *\/\npublic boolean ARE_EQUAL;;\n    public boolean allVisitedAlignmentsEqual()\n    public void updateMetric(final SamComparison.AlignmentComparison comp)\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/sam\/SamComparisonMetric.java","methodCount":2,"lineCount":15}],"15":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PhysicalLocationShort {\n    public void setX(final int x)\n    public void setY(final int y)\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/sam\/util\/PhysicalLocationShort.java","methodCount":2,"lineCount":4}],"16":[],"17":[],"18":[],"19":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class MathUtils {\n    public static double hypot(double a, double b)\n}\n","filePath":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/MathUtils.java","methodCount":1,"lineCount":3}],"20":[{"fieldCount":0,"classCount":1,"methodsOnly":"public interface IFingerprintGenerator {\n     BitSet getFingerprint(IAtomContainer mol) throws CDKException\n}\n","filePath":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/fingerprints\/interfaces\/IFingerprintGenerator.java","methodCount":1,"lineCount":3}],"21":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class SerializationUtils {\n    public SerializationUtils();\n    public static void writeObject(Object object, File destinationFile) throws IOException\n    public static Object readObject(File serializedFile) throws IOException, ClassNotFoundException\n}\n","filePath":"\/home\/ubuntu\/repos\/compomics,compomics-utilities\/src\/main\/java\/com\/compomics\/util\/io\/file\/SerializationUtils.java","methodCount":3,"lineCount":5}],"22":[],"23":[],"24":[],"25":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class MathUtils {\n    public static double hypot(double a, double b)\n}\n","filePath":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/math\/MathUtils.java","methodCount":1,"lineCount":3}],"26":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"27":[],"28":[{"fieldCount":6,"classCount":1,"methodsOnly":"public class Region {\n    \/**\n * Chromosome name\n *\/\npublic final String chr;;\n    \/**\n * Region start position\n *\/\npublic final int start;;\n    \/**\n * Region end position\n *\/\npublic final int end;;\n    \/**\n * Gene name\n *\/\npublic final String gene;;\n    \/**\n * Position to start looking for variants (for amplicon based calling)\n *\/\npublic final int insertStart;;\n    \/**\n * Position to end looking for variants (for amplicon based calling)\n *\/\npublic final int insertEnd;;\n    public Region(String chr, int start, int end, String gene);\n    public Region(String chr, int start, int end, String gene, int insertStart, int insertEnd);\n    public static Region newModifiedRegion(Region region, int changedStart, int changedEnd)\n    public boolean equals(Object o)\n    public int hashCode()\n    public String toString()\n    public String printRegion()\n}\n","filePath":"\/home\/ubuntu\/repos\/AstraZeneca-NGS,VarDictJava\/src\/main\/java\/com\/astrazeneca\/vardict\/data\/Region.java","methodCount":7,"lineCount":15}],"29":[],"30":[],"31":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/Immutable.java","methodCount":0,"lineCount":0}],"32":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/Immutable.java","methodCount":0,"lineCount":0}],"33":[],"34":[{"fieldCount":0,"classCount":1,"methodsOnly":"public class PicardException {\n    public PicardException(final String message);\n    public PicardException(final String message, final Throwable throwable);\n}\n","filePath":"\/home\/ubuntu\/repos\/broadinstitute,picard\/src\/main\/java\/picard\/PicardException.java","methodCount":2,"lineCount":4}],"35":[],"36":[],"37":[],"38":[],"39":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/Immutable.java","methodCount":0,"lineCount":0}],"40":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/charite,jannovar\/jannovar-core\/src\/main\/java\/de\/charite\/compbio\/jannovar\/Immutable.java","methodCount":0,"lineCount":0}],"41":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/stereo\/IStereoAndConformation.java","methodCount":0,"lineCount":0},{"fieldCount":0,"classCount":1,"methodsOnly":"public interface ChiralityTool {\n    public Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer)\n    public Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer, boolean getNoneAssignments)\n}\n","filePath":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/stereo\/compare\/ChiralityTool.java","methodCount":2,"lineCount":4},{"fieldCount":1,"classCount":1,"methodsOnly":"public class WedgeStereoLifter {\n    private final List<WedgeRule> rules;;\n    public WedgeStereoLifter();\n    private WedgeRule getRule(IBond.Stereo[] stereos)\n    public IStereoElement lift(IAtom atom, IAtomContainer atomContainer)\n    private double getFullAngle(IAtom centralAtom, IAtom partner1, IAtom partner2)\n}\n","filePath":"\/home\/ubuntu\/repos\/asad,ReactionDecoder\/src\/main\/java\/uk\/ac\/ebi\/reactionblast\/stereo\/wedge\/WedgeStereoLifter.java","methodCount":4,"lineCount":7}],"42":[],"43":[],"44":[],"45":[{"fieldCount":0,"classCount":0,"methodsOnly":"","filePath":"\/home\/ubuntu\/repos\/CompEvol,beast2\/src\/beast\/base\/core\/Description.java","methodCount":0,"lineCount":0}],"46":[],"47":[],"48":[],"49":[]},"additionalImports":{"0":"{'Annotation': 'public class Annotation {\\n    private static final ImmutableSet<VariantEffect> EMPTY_VARIANT_EFFECTS = Sets.immutableEnumSet(EnumSet.noneOf(VariantEffect.class));;\\n    private static final ImmutableSet<AnnotationMessage> EMPTY_ANNOTATION_MESSAGES = Sets.immutableEnumSet(EnumSet.noneOf(AnnotationMessage.class));;\\n    \/**\\n * This line is added to the output of a VCF file annotated by Jannovar and describes the new field for the INFO\\n * section entitled EFFECT, which decribes the effects of variants (splicing,missense,stoploss, etc).\\n *\/\\npublic static final String INFO_EFFECT = \"\" + \"variant effect (UTR5,UTR3,intronic,splicing,missense,stoploss,stopgain,\" + \"startloss,duplication,frameshift-insertion,frameshift-deletion,non-frameshift-deletion,\" + \"non-frameshift-insertion,synonymous)\";;\\n    \/**\\n * This line is added to the output of a VCF file annotated by Jannovar and describes the new field for the INFO\\n * section entitled HGVS, which provides the HGVS encoded variant corresponding to the chromosomal variant in the\\n * original VCF file.\\n *\/\\npublic static final String INFO_HGVS = \"HGVS Nomenclature\";;\\n    \/**\\n * The DESCRIPTION string to use in the VCF header for VCFVariantAnnotation objects\\n *\/\\npublic static final String VCF_ANN_DESCRIPTION_STRING = \"Functional annotations:\\'Allele|Annotation|\" + \"Annotation_Impact|Gene_Name|Gene_ID|Feature_Type|Feature_ID|Transcript_BioType|Rank|HGVS.c|HGVS.p|\" + \"cDNA.pos \/ cDNA.length|CDS.pos \/ CDS.length|AA.pos \/ AA.length|Distance|ERRORS \/ WARNINGS \/ INFO\\'\";;\\n    \/**\\n * the annotated {@link GenomeVariant}\\n *\/\\nprivate final GenomeVariant change;;\\n    \/**\\n * variant types, sorted by internal pathogenicity score\\n *\/\\nprivate final ImmutableSet<VariantEffect> effects;;\\n    \/**\\n * errors and warnings\\n *\/\\nprivate final ImmutableSet<AnnotationMessage> messages;;\\n    \/**\\n * location of the annotation, <code>null<\/code> if not even nearby a {@link TranscriptModel}\\n *\/\\nprivate final AnnotationLocation annoLoc;;\\n    \/**\\n * Chromosome\/genome-level change, to be prepended with \"g.\"\\n *\/\\nprivate final NucleotideChange genomicNTChange;;\\n    \/**\\n * CDS-level {@link NucleotideChange} for coding transcripts (to be prependend with \"c.\") and transcript level for\\n * non-coding transcripts (to be prepended with \"n.\")\\n *\/\\nprivate final NucleotideChange cdsNTChange;;\\n    \/**\\n * change on the protein level\\n *\/\\nprivate final ProteinChange proteinChange;;\\n    \/**\\n * the transcript, <code>null<\/code> for {@link VariantEffect#INTERGENIC_VARIANT} annotations\\n *\/\\nprivate final TranscriptModel transcript;;\\n    public Annotation(Collection<AnnotationMessage> messages);\\n    public Annotation(TranscriptModel transcript, GenomeVariant change, Collection<VariantEffect> effects, AnnotationLocation annoLoc, NucleotideChange genomicNTChange, NucleotideChange cdsNTChange, ProteinChange proteinChange);\\n    public Annotation(TranscriptModel transcript, GenomeVariant change, Collection<VariantEffect> varTypes, AnnotationLocation annoLoc, NucleotideChange genomicNTChange, NucleotideChange cdsNTChange, ProteinChange proteinChange, Collection<AnnotationMessage> messages);\\n    public GenomeVariant getGenomeVariant()\\n    public ImmutableSet<VariantEffect> getEffects()\\n    public ImmutableSet<AnnotationMessage> getMessages()\\n    public AnnotationLocation getAnnoLoc()\\n    public NucleotideChange getGenomicNTChange()\\n    public String getGenomicNTChangeStr()\\n    public NucleotideChange getCDSNTChange()\\n    public String getCDSNTChangeStr()\\n    public ProteinChange getProteinChange()\\n    public String getProteinChangeStr(AminoAcidCode code)\\n    public String getProteinChangeStr()\\n    public TranscriptModel getTranscript()\\n    public PutativeImpact getPutativeImpact()\\n    public String toVCFAnnoString(String alt, boolean escape, AminoAcidCode code)\\n    public String toVCFAnnoString(String alt, AminoAcidCode code)\\n    public String getGeneSymbol()\\n    public String getSymbolAndAnnotation(AminoAcidCode code)\\n    public VariantEffect getMostPathogenicVarType()\\n    public String getChrName()\\n    public int getChr()\\n    public int getPos()\\n    public String getRef()\\n    public String getAlt()\\n    public int compareTo(Annotation other)\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n}\\n'}","1":"{}","2":"{'PicardCommandLineProgramExecutor': 'public class PicardCommandLineProgramExecutor {\\n    \/\/ Our wrapped Picard command line program, to which we forward subsequent calls.\\nfinal private picard.cmdline.CommandLineProgram picardCommandLineProgram;;\\n    public PicardCommandLineProgramExecutor(final picard.cmdline.CommandLineProgram picardCommandLineProgram);\\n    protected boolean validateArgs(final String[] argv)\\n    public Object instanceMain(final String[] argv)\\n    protected Object doWork()\\n}\\n'}","3":"{}","4":"{}","5":"{}","6":"{}","7":"{}","8":"{}","9":"{'HaplotypeBlock': 'public class HaplotypeBlock {\\n    private final double maf;;\\n    private final Map<String, Snp> snpsByName = new HashMap<>();;\\n    private final double[] haplotypeFrequencies = new double[3];;\\n    private Snp firstSnp;;\\n    private String chrom;;\\n    private int start;;\\n    private int end;;\\n    public HaplotypeBlock(final double maf);\\n    public double[] getHaplotypeFrequencies()\\n    public void addSnp(final Snp snp)\\n    public Snp getSnp(final String name)\\n    public Snp getFirstSnp()\\n    public boolean contains(final Snp snp)\\n    public int size()\\n    public Collection<Snp> getSnps()\\n    public double getHaplotypeFrequency(final int i)\\n    public double getMaf()\\n    public DiploidGenotype getSnpGenotype(final Snp snp, final DiploidHaplotype haplotype)\\n    public DiploidHaplotype getDiploidHaplotype(final Snp snp, final DiploidGenotype gt)\\n    public int compareTo(final HaplotypeBlock that)\\n    public boolean equals(final Object o)\\n    public int hashCode()\\n    public String toString()\\n}\\n', 'HaplotypeMap': 'public class HaplotypeMap {\\n    public static final String HET_GENOTYPE_FOR_PHASING = \"HetGenotypeForPhasing\";;\\n    public static final String SYNTHETIC_PHASESET_PREFIX = \"Synthetic\";;\\n    public static final String PHASESET_PREFIX = \"PhaseSet\";;\\n    private final List<HaplotypeBlock> haplotypeBlocks = new ArrayList<>();;\\n    private final Map<Snp, HaplotypeBlock> haplotypesBySnp = new HashMap<>();;\\n    private final Map<String, HaplotypeBlock> haplotypesBySnpName = new HashMap<>();;\\n    private final Map<String, HaplotypeBlock> haplotypesBySnpLocus = new HashMap<>();;\\n    private final Map<String, Snp> snpsByPosition = new HashMap<>();;\\n    private IntervalList intervals;;\\n    private SAMFileHeader header;;\\n    private void fromVcf(final File file)\\n    private void fromHaplotypes(final Collection<HaplotypeBlock> haplotypes)\\n    private static String anchorFromVc(final VariantContext vc)\\n    private void fromHaplotypeDatabase(final File file)\\n    private HaplotypeMapFileEntry makeHaplotypeMapFileEntry(final String chrom, final int pos, final String name, final byte major, final byte minor, final double maf, final String anchorSnp, final List<String> fingerprintPanels)\\n    public HaplotypeMap(final SAMFileHeader header);\\n    public HaplotypeMap(final File file);\\n    public HaplotypeMap(final Collection<HaplotypeBlock> haplotypeBlocks);\\n    private void initialize(final SAMFileHeader header)\\n    public void addHaplotype(final HaplotypeBlock haplotypeBlock)\\n    public HaplotypeBlock getHaplotype(final Snp snp)\\n    public HaplotypeBlock getHaplotype(final String snpName)\\n    public HaplotypeBlock getHaplotype(final String chrom, final int pos)\\n    public List<HaplotypeBlock> getHaplotypes()\\n    public Snp getSnp(final String chrom, final int pos)\\n    public Set<Snp> getAllSnps()\\n    public IntervalList getIntervalList()\\n    private String toKey(final String chrom, final int pos)\\n    public HaplotypeMap withoutChromosomes(final Set<String> chroms)\\n    public void writeAsVcf(final File output, final File refFile) throws FileNotFoundException\\n    public Collection<VariantContext> asVcf(final ReferenceSequenceFile ref)\\n    public void writeToFile(final File file)\\n    public SAMFileHeader getHeader()\\n}\\n'}","10":"{'Annotation': 'public class Annotation {\\n    private static final ImmutableSet<VariantEffect> EMPTY_VARIANT_EFFECTS = Sets.immutableEnumSet(EnumSet.noneOf(VariantEffect.class));;\\n    private static final ImmutableSet<AnnotationMessage> EMPTY_ANNOTATION_MESSAGES = Sets.immutableEnumSet(EnumSet.noneOf(AnnotationMessage.class));;\\n    \/**\\n * This line is added to the output of a VCF file annotated by Jannovar and describes the new field for the INFO\\n * section entitled EFFECT, which decribes the effects of variants (splicing,missense,stoploss, etc).\\n *\/\\npublic static final String INFO_EFFECT = \"\" + \"variant effect (UTR5,UTR3,intronic,splicing,missense,stoploss,stopgain,\" + \"startloss,duplication,frameshift-insertion,frameshift-deletion,non-frameshift-deletion,\" + \"non-frameshift-insertion,synonymous)\";;\\n    \/**\\n * This line is added to the output of a VCF file annotated by Jannovar and describes the new field for the INFO\\n * section entitled HGVS, which provides the HGVS encoded variant corresponding to the chromosomal variant in the\\n * original VCF file.\\n *\/\\npublic static final String INFO_HGVS = \"HGVS Nomenclature\";;\\n    \/**\\n * The DESCRIPTION string to use in the VCF header for VCFVariantAnnotation objects\\n *\/\\npublic static final String VCF_ANN_DESCRIPTION_STRING = \"Functional annotations:\\'Allele|Annotation|\" + \"Annotation_Impact|Gene_Name|Gene_ID|Feature_Type|Feature_ID|Transcript_BioType|Rank|HGVS.c|HGVS.p|\" + \"cDNA.pos \/ cDNA.length|CDS.pos \/ CDS.length|AA.pos \/ AA.length|Distance|ERRORS \/ WARNINGS \/ INFO\\'\";;\\n    \/**\\n * the annotated {@link GenomeVariant}\\n *\/\\nprivate final GenomeVariant change;;\\n    \/**\\n * variant types, sorted by internal pathogenicity score\\n *\/\\nprivate final ImmutableSet<VariantEffect> effects;;\\n    \/**\\n * errors and warnings\\n *\/\\nprivate final ImmutableSet<AnnotationMessage> messages;;\\n    \/**\\n * location of the annotation, <code>null<\/code> if not even nearby a {@link TranscriptModel}\\n *\/\\nprivate final AnnotationLocation annoLoc;;\\n    \/**\\n * Chromosome\/genome-level change, to be prepended with \"g.\"\\n *\/\\nprivate final NucleotideChange genomicNTChange;;\\n    \/**\\n * CDS-level {@link NucleotideChange} for coding transcripts (to be prependend with \"c.\") and transcript level for\\n * non-coding transcripts (to be prepended with \"n.\")\\n *\/\\nprivate final NucleotideChange cdsNTChange;;\\n    \/**\\n * change on the protein level\\n *\/\\nprivate final ProteinChange proteinChange;;\\n    \/**\\n * the transcript, <code>null<\/code> for {@link VariantEffect#INTERGENIC_VARIANT} annotations\\n *\/\\nprivate final TranscriptModel transcript;;\\n    public Annotation(Collection<AnnotationMessage> messages);\\n    public Annotation(TranscriptModel transcript, GenomeVariant change, Collection<VariantEffect> effects, AnnotationLocation annoLoc, NucleotideChange genomicNTChange, NucleotideChange cdsNTChange, ProteinChange proteinChange);\\n    public Annotation(TranscriptModel transcript, GenomeVariant change, Collection<VariantEffect> varTypes, AnnotationLocation annoLoc, NucleotideChange genomicNTChange, NucleotideChange cdsNTChange, ProteinChange proteinChange, Collection<AnnotationMessage> messages);\\n    public GenomeVariant getGenomeVariant()\\n    public ImmutableSet<VariantEffect> getEffects()\\n    public ImmutableSet<AnnotationMessage> getMessages()\\n    public AnnotationLocation getAnnoLoc()\\n    public NucleotideChange getGenomicNTChange()\\n    public String getGenomicNTChangeStr()\\n    public NucleotideChange getCDSNTChange()\\n    public String getCDSNTChangeStr()\\n    public ProteinChange getProteinChange()\\n    public String getProteinChangeStr(AminoAcidCode code)\\n    public String getProteinChangeStr()\\n    public TranscriptModel getTranscript()\\n    public PutativeImpact getPutativeImpact()\\n    public String toVCFAnnoString(String alt, boolean escape, AminoAcidCode code)\\n    public String toVCFAnnoString(String alt, AminoAcidCode code)\\n    public String getGeneSymbol()\\n    public String getSymbolAndAnnotation(AminoAcidCode code)\\n    public VariantEffect getMostPathogenicVarType()\\n    public String getChrName()\\n    public int getChr()\\n    public int getPos()\\n    public String getRef()\\n    public String getAlt()\\n    public int compareTo(Annotation other)\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n}\\n'}","11":"{'InfiniumFileTOC': 'public class InfiniumFileTOC {\\n    private short tableOfContentsId;;\\n    private int offset;;\\n     short getTableOfContentsId()\\n     void setTableOfContentsId(short tableOfContentsId)\\n    public int getOffset()\\n    public void setOffset(int offset)\\n}\\n'}","12":"{'dbSNPNormalized': 'public class dbSNPNormalized {\\n    \/**\\n * {@link MutationMention} mention is derived using a specific uniprotfeature\\n *\/\\nprivate UniprotFeature feature = null;;\\n    private final EnumSet<MatchOptions> matchType;;\\n    public EnumSet<MatchOptions> getMatchType()\\n    public dbSNPNormalized(dbSNP dbsnp, EnumSet<MatchOptions> matchType, UniprotFeature feature);\\n    public int getConfidence()\\n    public String toString()\\n    public boolean isAlleleOrder()\\n    public boolean isExactPosition()\\n    public boolean isMethioneMatch()\\n    public boolean isFeatureMatch()\\n    public UniprotFeature getFeature()\\n    public boolean isPsm()\\n    public int compareTo(dbSNPNormalized that)\\n}\\n'}","13":"{}","14":"{}","15":"{}","16":"{}","17":"{}","18":"{}","19":"{}","20":"{}","21":"{}","22":"{}","23":"{}","24":"{}","25":"{}","26":"{}","27":"{'Locatable': 'public interface Locatable {\\n     String getContig()\\n     int getStart()\\n     int getEnd()\\n     int getLengthOnReference()\\n     boolean overlaps(Locatable other)\\n     boolean withinDistanceOf(Locatable other, int distance)\\n     boolean contains(Locatable other)\\n     boolean contigsMatch(Locatable other)\\n}\\n'}","28":"{}","29":"{}","30":"{}","31":"{'GenomePosition': 'public class GenomePosition {\\n    private static final long serialVersionUID = 2L;;\\n    \/**\\n * reference dictionary to use for coordinate translation\\n *\/\\nprivate final ReferenceDictionary refDict;;\\n    \/**\\n * the strand that the position is located on\\n *\/\\nprivate final Strand strand;;\\n    \/**\\n * the chromosome number, as index in chromosome dictionary\\n *\/\\nprivate final int chr;;\\n    \/**\\n * the position on the chromosome\\n *\/\\nprivate final int pos;;\\n    public GenomePosition(ReferenceDictionary refDict, Strand strand, int chr, int pos);\\n    public GenomePosition(ReferenceDictionary refDict, Strand strand, int chr, int pos, PositionType positionType);\\n    public GenomePosition(GenomePosition other);\\n    public GenomePosition(GenomePosition other, Strand strand);\\n    public ReferenceDictionary getRefDict()\\n    public Strand getStrand()\\n    public int getChr()\\n    public int getPos()\\n    public GenomePosition withStrand(Strand strand)\\n    public boolean isLt(GenomePosition other)\\n    public boolean isLeq(GenomePosition other)\\n    public boolean isGt(GenomePosition other)\\n    public boolean isGeq(GenomePosition other)\\n    public boolean isEq(GenomePosition other)\\n    public int differenceTo(GenomePosition pos)\\n    public int differenceTo(GenomeInterval itv)\\n    public GenomePosition shifted(int delta)\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n    public int compareTo(GenomePosition other)\\n}\\n', 'GenomeInterval': 'public class GenomeInterval {\\n    private static final long serialVersionUID = 2L;;\\n    \/**\\n * reference dictionary to use for coordinate translation\\n *\/\\nfinal ReferenceDictionary refDict;;\\n    \/**\\n * the strand that the position is located on\\n *\/\\nprivate final Strand strand;;\\n    \/**\\n * the chromosome number, as index in chromosome dictionary\\n *\/\\nprivate final int chr;;\\n    \/**\\n * the begin position on the chromosome\\n *\/\\nprivate final int beginPos;;\\n    \/**\\n * the end position on the chromosome\\n *\/\\nprivate final int endPos;;\\n    public GenomeInterval(ReferenceDictionary refDict, Strand strand, int chr, int beginPos, int endPos);\\n    public GenomeInterval(ReferenceDictionary refDict, Strand strand, int chr, int beginPos, int endPos, PositionType positionType);\\n    public GenomeInterval(GenomePosition pos, int length);\\n    public ReferenceDictionary getRefDict()\\n    public Strand getStrand()\\n    public int getChr()\\n    public int getBeginPos()\\n    public int getEndPos()\\n    public GenomeInterval withStrand(Strand strand)\\n    public GenomePosition getGenomeBeginPos()\\n    public GenomePosition getGenomeEndPos()\\n    public int length()\\n    public GenomeInterval intersection(GenomeInterval other)\\n    public GenomeInterval union(GenomeInterval other)\\n    public boolean isLeftOf(GenomePosition pos)\\n    public boolean isRightOf(GenomePosition pos)\\n    public boolean isLeftOfGap(GenomePosition pos)\\n    private GenomePosition ensureSameStrand(GenomePosition pos)\\n    public boolean isRightOfGap(GenomePosition pos)\\n    public boolean contains(GenomePosition pos)\\n    public boolean contains(GenomeInterval other)\\n    public GenomeInterval withMorePadding(int padding)\\n    public GenomeInterval withMorePadding(int paddingUpstream, int paddingDownstream)\\n    public boolean overlapsWith(GenomeInterval other)\\n    private GenomeInterval ensureSameStrand(GenomeInterval other)\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n    public int compareTo(GenomeInterval other)\\n}\\n'}","32":"{'Person': \"public class Person {\\n    \/**\\n * the individual's name\\n *\/\\nprivate final String name;;\\n    \/**\\n * the individual's father, or <code>null<\/code> if father is not in pedigree\\n *\/\\nprivate final Person father;;\\n    \/**\\n * the individual's mother, or <code>null<\/code> if mother is not in pedigree\\n *\/\\nprivate final Person mother;;\\n    \/**\\n * the individual's sex\\n *\/\\nprivate final Sex sex;;\\n    \/**\\n * the individual's disease state\\n *\/\\nprivate final Disease disease;;\\n    \/**\\n * extra fields from the PED file\\n *\/\\nprivate final ImmutableList<String> extraFields;;\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease, Collection<String> extraFields);\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease);\\n     Person(PedPerson pedPerson, PedFileContents pedFileContents, HashMap<String, Person> existing);\\n    public String getName()\\n    public Person getFather()\\n    public Person getMother()\\n    public Sex getSex()\\n    public Disease getDisease()\\n    public ImmutableList<String> getExtraFields()\\n    public boolean isFounder()\\n    public boolean isMale()\\n    public boolean isFemale()\\n    public boolean isAffected()\\n    public boolean isUnaffected()\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n}\\n\"}","33":"{}","34":"{}","35":"{}","36":"{}","37":"{'ReadDescriptor': 'public class ReadDescriptor {\\n    public final int length;;\\n    public final ReadType type;;\\n    public ReadDescriptor(final int length, final ReadType type);\\n    public String toString()\\n    public boolean equals(final Object other)\\n    public int hashCode()\\n}\\n'}","38":"{}","39":"{'Person': \"public class Person {\\n    \/**\\n * the individual's name\\n *\/\\nprivate final String name;;\\n    \/**\\n * the individual's father, or <code>null<\/code> if father is not in pedigree\\n *\/\\nprivate final Person father;;\\n    \/**\\n * the individual's mother, or <code>null<\/code> if mother is not in pedigree\\n *\/\\nprivate final Person mother;;\\n    \/**\\n * the individual's sex\\n *\/\\nprivate final Sex sex;;\\n    \/**\\n * the individual's disease state\\n *\/\\nprivate final Disease disease;;\\n    \/**\\n * extra fields from the PED file\\n *\/\\nprivate final ImmutableList<String> extraFields;;\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease, Collection<String> extraFields);\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease);\\n     Person(PedPerson pedPerson, PedFileContents pedFileContents, HashMap<String, Person> existing);\\n    public String getName()\\n    public Person getFather()\\n    public Person getMother()\\n    public Sex getSex()\\n    public Disease getDisease()\\n    public ImmutableList<String> getExtraFields()\\n    public boolean isFounder()\\n    public boolean isMale()\\n    public boolean isFemale()\\n    public boolean isAffected()\\n    public boolean isUnaffected()\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n}\\n\"}","40":"{'Person': \"public class Person {\\n    \/**\\n * the individual's name\\n *\/\\nprivate final String name;;\\n    \/**\\n * the individual's father, or <code>null<\/code> if father is not in pedigree\\n *\/\\nprivate final Person father;;\\n    \/**\\n * the individual's mother, or <code>null<\/code> if mother is not in pedigree\\n *\/\\nprivate final Person mother;;\\n    \/**\\n * the individual's sex\\n *\/\\nprivate final Sex sex;;\\n    \/**\\n * the individual's disease state\\n *\/\\nprivate final Disease disease;;\\n    \/**\\n * extra fields from the PED file\\n *\/\\nprivate final ImmutableList<String> extraFields;;\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease, Collection<String> extraFields);\\n    public Person(String name, Person father, Person mother, Sex sex, Disease disease);\\n     Person(PedPerson pedPerson, PedFileContents pedFileContents, HashMap<String, Person> existing);\\n    public String getName()\\n    public Person getFather()\\n    public Person getMother()\\n    public Sex getSex()\\n    public Disease getDisease()\\n    public ImmutableList<String> getExtraFields()\\n    public boolean isFounder()\\n    public boolean isMale()\\n    public boolean isFemale()\\n    public boolean isAffected()\\n    public boolean isUnaffected()\\n    public String toString()\\n    public int hashCode()\\n    public boolean equals(Object obj)\\n}\\n\"}","41":"{}","42":"{}","43":"{}","44":"{}","45":"{}","46":"{'Matrix': 'public class Matrix {\\n    protected double[][] components;;\\n    protected LUPDecomposition lupDecomposition = null;;\\n    public Matrix(double[][] a);\\n    public Matrix(double[] a, int n, int m);\\n    public Matrix(int n, int m) throws NegativeArraySizeException;\\n    public void accumulate(Matrix a) throws IllegalDimension\\n    public Matrix add(Matrix a) throws IllegalDimension\\n    protected double[][] addComponents(Matrix a)\\n    public void clear()\\n    public int columns()\\n    public double component(int n, int m)\\n    public double determinant() throws IllegalDimension\\n    public boolean isPD() throws IllegalDimension\\n    public boolean equals(Matrix a)\\n    public Matrix inverse() throws ArithmeticException\\n    public boolean isSquare()\\n    protected LUPDecomposition lupDecomposition() throws IllegalDimension\\n    public Matrix product(double a)\\n    public Vector product(Vector v) throws IllegalDimension\\n    public Matrix product(Matrix a) throws IllegalDimension\\n    protected double[][] productComponents(double a)\\n    protected double[][] productComponents(Matrix a)\\n    public Matrix productWithTransposed(Matrix a) throws IllegalDimension\\n    protected double[][] productWithTransposedComponents(Matrix a)\\n    public int rows()\\n    protected Vector secureProduct(Vector v)\\n    protected Matrix secureProduct(Matrix a)\\n    protected Matrix secureSubtract(Matrix a)\\n    public Matrix subtract(Matrix a) throws IllegalDimension\\n    protected double[][] subtractComponents(Matrix a)\\n    public double[][] toComponents()\\n    public String toString()\\n    public String toStringOctave()\\n    public Matrix transpose()\\n    public SymmetricMatrix transposedProduct()\\n    public Matrix transposedProduct(Matrix a) throws IllegalDimension\\n    protected double[][] transposedProductComponents(Matrix a)\\n}\\n'}","47":"{}","48":"{'SAMRecord': 'public class SAMRecord {\\n    private final static Log LOG = Log.getInstance(SAMRecord.class);;\\n    public static final long serialVersionUID = 1L;;\\n    \/**\\n * Alignment score for a good alignment, but where computing a Phred-score is not feasible.\\n *\/\\npublic static final int UNKNOWN_MAPPING_QUALITY = 255;;\\n    \/**\\n * Alignment score for an unaligned read.\\n *\/\\npublic static final int NO_MAPPING_QUALITY = 0;;\\n    \/**\\n * If a read has this reference name, it is unaligned, but not all unaligned reads have\\n * this reference name (see above).\\n *\/\\npublic static final String NO_ALIGNMENT_REFERENCE_NAME = \"*\";;\\n    \/**\\n * If a read has this reference index, it is unaligned, but not all unaligned reads have\\n * this reference index (see above).\\n *\/\\npublic static final int NO_ALIGNMENT_REFERENCE_INDEX = -1;;\\n    \/**\\n * Cigar string for an unaligned read.\\n *\/\\npublic static final String NO_ALIGNMENT_CIGAR = \"*\";;\\n    \/**\\n * If a read has reference name \"*\", it will have this value for position.\\n *\/\\npublic static final int NO_ALIGNMENT_START = GenomicIndexUtil.UNSET_GENOMIC_LOCATION;;\\n    \/**\\n * This should rarely be used, since a read with no sequence doesn\\'t make much sense.\\n *\/\\npublic static final byte[] NULL_SEQUENCE = new byte[0];;\\n    public static final String NULL_SEQUENCE_STRING = \"*\";;\\n    \/**\\n * This should rarely be used, since all reads should have quality scores.\\n *\/\\npublic static final byte[] NULL_QUALS = new byte[0];;\\n    public static final String NULL_QUALS_STRING = \"*\";;\\n    \/**\\n * abs(insertSize) must be <= this\\n *\/\\npublic static final int MAX_INSERT_SIZE = Integer.MAX_VALUE;;\\n    \/**\\n * Tags that are known to need the reverse complement if the read is reverse complemented.\\n *\/\\n@SuppressWarnings(\"deprecated\")\\npublic static final List<String> TAGS_TO_REVERSE_COMPLEMENT = Arrays.asList(SAMTag.E2.name(), SAMTag.SQ.name());;\\n    \/**\\n * Tags that are known to need the reverse if the read is reverse complemented.\\n *\/\\npublic static final List<String> TAGS_TO_REVERSE = Arrays.asList(SAMTag.OQ.name(), SAMTag.U2.name());;\\n    private String mReadName = null;;\\n    private byte[] mReadBases = NULL_SEQUENCE;;\\n    private byte[] mBaseQualities = NULL_QUALS;;\\n    private String mReferenceName = NO_ALIGNMENT_REFERENCE_NAME;;\\n    private int mAlignmentStart = NO_ALIGNMENT_START;;\\n    private transient int mAlignmentEnd = NO_ALIGNMENT_START;;\\n    private int mMappingQuality = NO_MAPPING_QUALITY;;\\n    private String mCigarString = NO_ALIGNMENT_CIGAR;;\\n    private Cigar mCigar = null;;\\n    private List<AlignmentBlock> mAlignmentBlocks = null;;\\n    private int mFlags = 0;;\\n    private String mMateReferenceName = NO_ALIGNMENT_REFERENCE_NAME;;\\n    private int mMateAlignmentStart = 0;;\\n    private int mInferredInsertSize = 0;;\\n    private SAMBinaryTagAndValue mAttributes = null;;\\n    protected Integer mReferenceIndex = null;;\\n    protected Integer mMateReferenceIndex = null;;\\n    \/**\\n * Some attributes (e.g. CIGAR) are not decoded immediately.  Use this to decide how to validate when decoded.\\n *\/\\nprivate ValidationStringency mValidationStringency = ValidationStringency.SILENT;;\\n    \/**\\n * File source of this record. May be null. Note that this field is not serializable (and therefore marked\\n * as transient) due to encapsulated stream objects within it -- so serializing a SAMRecord will cause its\\n * file source to be lost (if it had one).\\n *\/\\nprivate transient SAMFileSource mFileSource;;\\n    private SAMFileHeader mHeader = null;;\\n    \/**\\n * Transient Map of attributes for use by anyone.\\n *\/\\nprivate transient Map<Object, Object> transientAttributes;;\\n    public SAMRecord(final SAMFileHeader header);\\n    public String getReadName()\\n    public int getReadNameLength()\\n    public void setReadName(final String value)\\n    public String getReadString()\\n    public void setReadString(final String value)\\n    public byte[] getReadBases()\\n    public void setReadBases(final byte[] value)\\n    public int getReadLength()\\n    public String getBaseQualityString()\\n    public void setBaseQualityString(final String value)\\n    public byte[] getBaseQualities()\\n    public void setBaseQualities(final byte[] value)\\n    public byte[] getOriginalBaseQualities()\\n    public void setOriginalBaseQualities(final byte[] oq)\\n    private static boolean hasReferenceName(final Integer referenceIndex, final String referenceName)\\n    private boolean hasReferenceName()\\n    private boolean hasMateReferenceName()\\n    public String getReferenceName()\\n    public void setReferenceName(final String referenceName)\\n    public Integer getReferenceIndex()\\n    public void setReferenceIndex(final int referenceIndex)\\n    public String getMateReferenceName()\\n    public void setMateReferenceName(final String mateReferenceName)\\n    public Integer getMateReferenceIndex()\\n    public void setMateReferenceIndex(final int mateReferenceIndex)\\n    protected static Integer resolveIndexFromName(final String referenceName, final SAMFileHeader header, final boolean strict)\\n    protected static String resolveNameFromIndex(final int referenceIndex, final SAMFileHeader header)\\n    public int getAlignmentStart()\\n    public void setAlignmentStart(final int value)\\n    public int getAlignmentEnd()\\n    public int getUnclippedStart()\\n    public int getUnclippedEnd()\\n    public int getReferencePositionAtReadPosition(final int position)\\n    public static int getReferencePositionAtReadPosition(final SAMRecord rec, final int position)\\n    public int getReadPositionAtReferencePosition(final int pos)\\n    public int getReadPositionAtReferencePosition(final int pos, final boolean returnLastBaseIfDeleted)\\n    public static int getReadPositionAtReferencePosition(final SAMRecord rec, final int pos, final boolean returnLastBaseIfDeleted)\\n    public int getMateAlignmentStart()\\n    public void setMateAlignmentStart(final int mateAlignmentStart)\\n    public int getInferredInsertSize()\\n    public void setInferredInsertSize(final int inferredInsertSize)\\n    public int getMappingQuality()\\n    public void setMappingQuality(final int value)\\n    public String getCigarString()\\n    public void setCigarString(final String value)\\n    public Cigar getCigar()\\n    public int getCigarLength()\\n    public void setCigar(final Cigar cigar)\\n    protected void initializeCigar(final Cigar cigar)\\n    public SAMReadGroupRecord getReadGroup()\\n    public int getFlags()\\n    public void setFlags(final int value)\\n    public boolean getReadPairedFlag()\\n    private void requireReadPaired()\\n    public boolean getProperPairFlag()\\n    private boolean getProperPairFlagUnchecked()\\n    public boolean getReadUnmappedFlag()\\n    public boolean getMateUnmappedFlag()\\n    private boolean getMateUnmappedFlagUnchecked()\\n    public boolean getReadNegativeStrandFlag()\\n    public boolean getMateNegativeStrandFlag()\\n    private boolean getMateNegativeStrandFlagUnchecked()\\n    public boolean getFirstOfPairFlag()\\n    private boolean getFirstOfPairFlagUnchecked()\\n    public boolean getSecondOfPairFlag()\\n    private boolean getSecondOfPairFlagUnchecked()\\n    public boolean getNotPrimaryAlignmentFlag()\\n    public boolean isSecondaryAlignment()\\n    public boolean getSupplementaryAlignmentFlag()\\n    public boolean getReadFailsVendorQualityCheckFlag()\\n    public boolean getDuplicateReadFlag()\\n    public void setReadPairedFlag(final boolean flag)\\n    public void setProperPairFlag(final boolean flag)\\n    public void setReadUmappedFlag(final boolean flag)\\n    public void setReadUnmappedFlag(final boolean flag)\\n    public void setMateUnmappedFlag(final boolean flag)\\n    public void setReadNegativeStrandFlag(final boolean flag)\\n    public void setMateNegativeStrandFlag(final boolean flag)\\n    public void setFirstOfPairFlag(final boolean flag)\\n    public void setSecondOfPairFlag(final boolean flag)\\n    public void setNotPrimaryAlignmentFlag(final boolean flag)\\n    public void setSecondaryAlignment(final boolean flag)\\n    public void setSupplementaryAlignmentFlag(final boolean flag)\\n    public void setReadFailsVendorQualityCheckFlag(final boolean flag)\\n    public void setDuplicateReadFlag(final boolean flag)\\n    public boolean isSecondaryOrSupplementary()\\n    private void setFlag(final boolean flag, final int bit)\\n    public ValidationStringency getValidationStringency()\\n    public void setValidationStringency(final ValidationStringency validationStringency)\\n    public boolean hasAttribute(final String tag)\\n    public boolean hasAttribute(final SAMTag tag)\\n    public Object getAttribute(final String tag)\\n    public Object getAttribute(final SAMTag tag)\\n    public Integer getIntegerAttribute(final SAMTag tag)\\n    public Integer getIntegerAttribute(final String tag)\\n    public Long getUnsignedIntegerAttribute(final String tag) throws SAMException\\n    public Long getUnsignedIntegerAttribute(final SAMTag tag) throws SAMException\\n    public Long getUnsignedIntegerAttribute(final short tag) throws SAMException\\n    public Short getShortAttribute(final SAMTag tag)\\n    public Short getShortAttribute(final String tag)\\n    public Byte getByteAttribute(final SAMTag tag)\\n    public Byte getByteAttribute(final String tag)\\n    public String getStringAttribute(final SAMTag tag)\\n    public String getStringAttribute(final String tag)\\n    public Character getCharacterAttribute(final SAMTag tag)\\n    public Character getCharacterAttribute(final String tag)\\n    public Float getFloatAttribute(final SAMTag tag)\\n    public Float getFloatAttribute(final String tag)\\n    public byte[] getByteArrayAttribute(final SAMTag tag)\\n    public byte[] getByteArrayAttribute(final String tag)\\n    public byte[] getUnsignedByteArrayAttribute(final SAMTag tag)\\n    public byte[] getUnsignedByteArrayAttribute(final String tag)\\n    public byte[] getSignedByteArrayAttribute(final SAMTag tag)\\n    public byte[] getSignedByteArrayAttribute(final String tag)\\n    public short[] getUnsignedShortArrayAttribute(final SAMTag tag)\\n    public short[] getUnsignedShortArrayAttribute(final String tag)\\n    public short[] getSignedShortArrayAttribute(final SAMTag tag)\\n    public short[] getSignedShortArrayAttribute(final String tag)\\n    public int[] getUnsignedIntArrayAttribute(final SAMTag tag)\\n    public int[] getUnsignedIntArrayAttribute(final String tag)\\n    public int[] getSignedIntArrayAttribute(final SAMTag tag)\\n    public int[] getSignedIntArrayAttribute(final String tag)\\n    public float[] getFloatArrayAttribute(final SAMTag tag)\\n    public float[] getFloatArrayAttribute(final String tag)\\n    public boolean isUnsignedArrayAttribute(final String tag)\\n    private void requireSigned(final String tag)\\n    private void requireUnsigned(final String tag)\\n    public Object getAttribute(final short tag)\\n    public void setAttribute(final String tag, final Object value)\\n    public void setUnsignedArrayAttribute(final String tag, final Object value)\\n    protected void setAttribute(final short tag, final Object value)\\n    public void setAttribute(final SAMTag tag, final Object value)\\n    protected static boolean isAllowedAttributeValue(final Object value)\\n    protected void setAttribute(final SAMTag tag, final Object value, final boolean isUnsignedArray)\\n    protected void setAttribute(final short tag, final Object value, final boolean isUnsignedArray)\\n    public void clearAttributes()\\n    protected void setAttributes(final SAMBinaryTagAndValue attributes)\\n    protected SAMBinaryTagAndValue getBinaryAttributes()\\n    public String getContig()\\n    public int getStart()\\n    public int getEnd()\\n    public List<SAMTagAndValue> getAttributes()\\n    public int computeIndexingBinIfAbsent(final SAMRecord alignment)\\n     int computeIndexingBin()\\n    public SAMFileHeader getHeader()\\n    public void setHeader(final SAMFileHeader header)\\n    public void setHeaderStrict(final SAMFileHeader header)\\n    public byte[] getVariableBinaryRepresentation()\\n    public int getAttributesBinarySize()\\n    public String format()\\n    private void addField(final StringBuilder buffer, final Object value, final Object defaultValue, final String defaultString)\\n    private void addField(final StringBuilder buffer, final String field)\\n    private static String formatTagValue(final short tag, final Object value)\\n    private boolean safeEquals(final Object o1, final Object o2)\\n    protected void eagerDecode()\\n    public List<AlignmentBlock> getAlignmentBlocks()\\n    public List<SAMValidationError> validateCigar(final long recordNumber)\\n    public boolean equals(final Object o)\\n    public int hashCode()\\n    public List<SAMValidationError> isValid()\\n    public List<SAMValidationError> isValid(final boolean firstOnly)\\n    public SAMFileSource getFileSource()\\n    public void setFileSource(final SAMFileSource fileSource)\\n    private List<SAMValidationError> isValidReferenceIndexAndPosition(final Integer referenceIndex, final String referenceName, final int alignmentStart, final boolean isMate)\\n    private List<SAMValidationError> isValidReferenceIndexAndPosition(final Integer referenceIndex, final String referenceName, final int alignmentStart, final boolean isMate, final boolean firstOnly)\\n    private String buildMessage(final String baseMessage, final boolean isMate)\\n    public Object clone() throws CloneNotSupportedException\\n    public SAMRecord deepCopy()\\n    public String toString()\\n    public String getSAMString()\\n    public String getPairedReadName()\\n    public final Set<SAMFlag> getSAMFlags()\\n    public final Object getTransientAttribute(final Object key)\\n    public final Object setTransientAttribute(final Object key, final Object value)\\n    public final Object removeTransientAttribute(final Object key)\\n    public void reverseComplement()\\n    public void reverseComplement(boolean inplace)\\n    public void reverseComplement(final Collection<String> tagsToRevcomp, final Collection<String> tagsToReverse, boolean inplace)\\n    private static void reverseArray(final byte[] array)\\n    private static void reverseArray(final short[] array)\\n    private static void reverseArray(final int[] array)\\n    private static void reverseArray(final float[] array)\\n}\\n'}","49":"{}"},"intraClassFieldsUsed":{"0":"protected final VariantAnnotations annotations;\nprivate final int alleleID;\nprivate final int altCount;\npublic int getAlleleID();\npublic int getAltCount();\npublic String buildEffectText();\npublic String buildMessages();\nprotected abstract ImmutableList<Annotation> getAnnotations();\n","1":"private int lane = -1;\nprivate int tile = -1;\nprivate int x = -1;\nprivate int y = -1;\nprivate final ReadData[] reads;\nprivate Boolean pf;\nprivate String matchedBarcode;\npublic String toString();\npublic int getTile();\npublic void setTile(final int tile);\npublic boolean tileIsSet();\npublic ReadData getRead(final int index);\npublic int getNumReads();\npublic void setOrCheckTile(final int tile);\npublic int getLane();\npublic void setLane(final int lane);\npublic boolean laneIsSet();\npublic int getX();\npublic void setX(final int x);\npublic boolean xIsSet();\npublic void setOrCheckX(final int x);\npublic int getY();\npublic void setY(final int y);\npublic boolean yIsSet();\npublic void setOrCheckY(final int y);\npublic Boolean isPf();\npublic void setPf(final boolean pf);\npublic void setOrCheckPf(final boolean pf);\npublic String getMatchedBarcode();\npublic void setMatchedBarcode(final String matchedBarcode);\n","2":"final private CommandLineProgram targetCommandLineProgram;\nprotected Object doWork();\n","3":"private Double binSize;\nprivate String precisionFormat;\nprivate String printDelim;\nfinal private Double BIN_EPSILON = 0.01;\nprivate CompressedDataList<Integer> dataList = new CompressedDataList<>();\npublic void add(final Double d, final int count);\npublic void add(final Histogram h);\npublic Integer get(final Double d);\npublic Double median();\nprivate long getBinnedValue(double d);\nprivate boolean isValidBinKey(long binnedValue);\npublic String toString();\npublic boolean isEmpty();\n","4":"private int lane = -1;\nprivate int tile = -1;\nprivate int x = -1;\nprivate int y = -1;\nprivate final ReadData[] reads;\nprivate Boolean pf;\nprivate String matchedBarcode;\npublic String toString();\npublic int getTile();\npublic void setTile(final int tile);\npublic boolean tileIsSet();\npublic ReadData getRead(final int index);\npublic int getNumReads();\npublic void setOrCheckTile(final int tile);\npublic int getLane();\npublic void setLane(final int lane);\npublic boolean laneIsSet();\npublic void setOrCheckLane(final int lane);\npublic int getX();\npublic void setX(final int x);\npublic boolean xIsSet();\npublic void setOrCheckX(final int x);\npublic int getY();\npublic void setY(final int y);\npublic boolean yIsSet();\npublic Boolean isPf();\npublic void setPf(final boolean pf);\npublic void setOrCheckPf(final boolean pf);\npublic String getMatchedBarcode();\npublic void setMatchedBarcode(final String matchedBarcode);\n","5":"private int lane = -1;\nprivate int tile = -1;\nprivate int x = -1;\nprivate int y = -1;\nprivate final ReadData[] reads;\nprivate Boolean pf;\nprivate String matchedBarcode;\npublic String toString();\npublic int getTile();\npublic void setTile(final int tile);\npublic boolean tileIsSet();\npublic ReadData getRead(final int index);\npublic int getNumReads();\npublic void setOrCheckTile(final int tile);\npublic int getLane();\npublic void setLane(final int lane);\npublic boolean laneIsSet();\npublic void setOrCheckLane(final int lane);\npublic int getX();\npublic void setX(final int x);\npublic boolean xIsSet();\npublic int getY();\npublic void setY(final int y);\npublic boolean yIsSet();\npublic void setOrCheckY(final int y);\npublic Boolean isPf();\npublic void setPf(final boolean pf);\npublic void setOrCheckPf(final boolean pf);\npublic String getMatchedBarcode();\npublic void setMatchedBarcode(final String matchedBarcode);\n","6":"private int lane = -1;\nprivate int tile = -1;\nprivate int x = -1;\nprivate int y = -1;\nprivate final ReadData[] reads;\nprivate Boolean pf;\nprivate String matchedBarcode;\npublic String toString();\npublic int getTile();\npublic void setTile(final int tile);\npublic boolean tileIsSet();\npublic ReadData getRead(final int index);\npublic int getNumReads();\npublic int getLane();\npublic void setLane(final int lane);\npublic boolean laneIsSet();\npublic void setOrCheckLane(final int lane);\npublic int getX();\npublic void setX(final int x);\npublic boolean xIsSet();\npublic void setOrCheckX(final int x);\npublic int getY();\npublic void setY(final int y);\npublic boolean yIsSet();\npublic void setOrCheckY(final int y);\npublic Boolean isPf();\npublic void setPf(final boolean pf);\npublic void setOrCheckPf(final boolean pf);\npublic String getMatchedBarcode();\npublic void setMatchedBarcode(final String matchedBarcode);\n","7":"private Double binSize;\nprivate String precisionFormat;\nprivate String printDelim;\nfinal private Double BIN_EPSILON = 0.01;\nprivate CompressedDataList<Integer> dataList = new CompressedDataList<>();\npublic void add(final Double d);\npublic void add(final Histogram h);\npublic Integer get(final Double d);\npublic Double median();\nprivate long getBinnedValue(double d);\nprivate boolean isValidBinKey(long binnedValue);\npublic String toString();\npublic boolean isEmpty();\n","8":"private final Log log = Log.getInstance(SamAlignmentMerger.class);\nprivate final List<File> alignedSamFile;\nprivate final List<File> read1AlignedSamFile;\nprivate final List<File> read2AlignedSamFile;\nprivate final int maxGaps;\nprivate final int minUnclippedBases;\nprivate boolean forceSort = false;\nprivate final OverclippedReadFilter contaminationFilter;\nprivate final List<String> requiredMatchingDictionaryTags;\nprivate SAMSequenceDictionary alignedSamDictionary;\npublic void mergeAlignment(final File referenceFasta);\nprotected SAMSequenceDictionary getDictionaryForMergedBam();\nprotected CloseableIterator<SAMRecord> getQuerynameSortedAlignedRecords();\nprotected boolean isContaminant(final HitsForInsert hits);\npublic boolean getForceSort();\n","9":"public static final String HET_GENOTYPE_FOR_PHASING = \"HetGenotypeForPhasing\";\npublic static final String SYNTHETIC_PHASESET_PREFIX = \"Synthetic\";\npublic static final String PHASESET_PREFIX = \"PhaseSet\";\nprivate final List<HaplotypeBlock> haplotypeBlocks = new ArrayList<>();\nprivate final Map<Snp, HaplotypeBlock> haplotypesBySnp = new HashMap<>();\nprivate final Map<String, HaplotypeBlock> haplotypesBySnpName = new HashMap<>();\nprivate final Map<String, HaplotypeBlock> haplotypesBySnpLocus = new HashMap<>();\nprivate final Map<String, Snp> snpsByPosition = new HashMap<>();\nprivate IntervalList intervals;\nprivate SAMFileHeader header;\nprivate void fromVcf(final File file);\nprivate void fromHaplotypes(final Collection<HaplotypeBlock> haplotypes);\nprivate static String anchorFromVc(final VariantContext vc);\nprivate void fromHaplotypeDatabase(final File file);\nprivate HaplotypeMapFileEntry makeHaplotypeMapFileEntry(final String chrom, final int pos, final String name, final byte major, final byte minor, final double maf, final String anchorSnp, final List<String> fingerprintPanels);\nprivate void initialize(final SAMFileHeader header);\npublic void addHaplotype(final HaplotypeBlock haplotypeBlock);\npublic HaplotypeBlock getHaplotype(final Snp snp);\npublic HaplotypeBlock getHaplotype(final String snpName);\npublic HaplotypeBlock getHaplotype(final String chrom, final int pos);\npublic List<HaplotypeBlock> getHaplotypes();\npublic Snp getSnp(final String chrom, final int pos);\npublic Set<Snp> getAllSnps();\npublic IntervalList getIntervalList();\nprivate String toKey(final String chrom, final int pos);\npublic void writeAsVcf(final File output, final File refFile) throws FileNotFoundException;\npublic Collection<VariantContext> asVcf(final ReferenceSequenceFile ref);\npublic void writeToFile(final File file);\npublic SAMFileHeader getHeader();\n","10":"protected final VariantAnnotations annotations;\nprivate final int alleleID;\nprivate final int altCount;\npublic int getAlleleID();\npublic int getAltCount();\npublic String buildHGVSText(AminoAcidCode code);\npublic String buildMessages();\nprotected abstract ImmutableList<Annotation> getAnnotations();\n","11":"private static final int NUM_SNPS = 1;\nprivate static final int PLOIDY = 2;\nprivate static final int PLOIDY_TYPE = 3;\nprivate static final int SAMPLE_NAME = 10;\nprivate static final int SAMPLE_PLATE = 11;\nprivate static final int SAMPLE_WELL = 12;\nprivate static final int CLUSTER_FILE = 100;\nprivate static final int SNP_MANIFEST = 101;\nprivate static final int IMAGING_DATE = 200;\nprivate static final int AUTOCALL_DATE = 201;\nprivate static final int AUTOCALL_VERSION = 300;\nprivate static final int TRANSFORMATIONS = 400;\nprivate static final int RAW_CONTROL_X_INTENSITIES = 500;\nprivate static final int RAW_CONTROL_Y_INTENSITIES = 501;\nprivate static final int RAW_X_INTENSITIES = 1000;\nprivate static final int RAW_Y_INTESITIES = 1001;\nprivate static final int GENOTYPES = 1002;\nprivate static final int BASE_CALLS = 1003;\nprivate static final int GENOTYPE_SCORES = 1004;\nprivate static final int SCANNER_INFO = 1005;\nprivate static final int CALL_RATE = 1006;\nprivate static final int GENDER = 1007;\nprivate static final int LOG_R_DEV = 1008;\nprivate static final int P_10_GC = 1009;\nprivate static final int DX = 1010;\nprivate static final int EXTENDED_SAMPLE_DATA = 1011;\nprivate static final int B_ALLELE_FREQS = 1012;\nprivate static final int LOG_R_RATIOS = 1013;\nprivate static final int INTENSITY_X_PERCENTILES = 1014;\nprivate static final int INTENSITY_Y_PERCENTILES = 1015;\nprivate static final int SENTRIX_ID = 1016;\nprivate static final int NO_CALL_CHAR = '-';\nprivate static final int IDENTIFIER_LENGTH = 3;\nprivate static final String GTC_IDENTIFIER = \"gtc\";\npublic static final byte NO_CALL = 0;\npublic static final byte AA_CALL = 1;\npublic static final byte AB_CALL = 2;\npublic static final byte BB_CALL = 3;\nprivate int[] allNormalizationIds;\nprivate Integer[] uniqueNormalizationIds;\nprivate int numberOfSnps;\nprivate int ploidy;\nprivate int ploidyType;\nprivate String sampleName;\nprivate String samplePlate;\nprivate String sampleWell;\nprivate String clusterFile;\nprivate String snpManifest;\nprivate String imagingDate;\nprivate String autoCallDate;\nprivate String autoCallVersion;\nprivate InfiniumTransformation[] normalizationTransformations;\nprivate int[] rawControlXIntensities;\nprivate int[] rawControlYIntensities;\nprivate int[] rawXIntensities;\nprivate int[] rawYIntensities;\nprivate byte[] genotypeBytes;\nprivate float[] genotypeScores;\nprivate float[] bAlleleFreqs;\nprivate float[] logRRatios;\nprivate byte[][] baseCalls;\nprivate String scannerName;\nprivate int pmtGreen;\nprivate int pmtRed;\nprivate String scannerVersion;\nprivate String imagingUser;\nprivate double callRate;\nprivate String gender;\nprivate float logRDev;\nprivate float p10GC;\nprivate int dx;\nprivate float p50GC;\nprivate int numCalls;\nprivate int numNoCalls;\nprivate int numIntensityOnly;\nprivate IntensityPercentiles redIntensityPercentiles;\nprivate IntensityPercentiles greenIntensityPercentiles;\nprivate String sentrixBarcode;\nprivate float[] normalizedXIntensities;\nprivate float[] normalizedYIntensities;\nprivate float[] RIlmn;\nprivate float[] thetaIlmn;\nprivate int aaCalls;\nprivate int abCalls;\nprivate int bbCalls;\npublic void close() throws IOException;\nprivate void loadNormalizationIds(final File bpmFile);\nprivate void calculateStatistics();\nprivate void calculateRandTheta();\nprivate void parse() throws IOException;\nprivate void normalizeIntensities();\nprivate int getAllNormIndex(final int normId);\nprivate void readData(final DataInputStream stream, final InfiniumFileTOC toc) throws IOException;\nprivate void parseExtendedSampleData(final InfiniumFileTOC toc) throws IOException;\nprivate void parseScannerInfo(final InfiniumFileTOC toc) throws IOException;\nprivate byte[] parseGenotypes(final InfiniumFileTOC toc) throws IOException;\nprivate void parseTransformations(final InfiniumFileTOC toc) throws IOException;\nprivate void normalizeAndCalculateStatistics();\npublic InfiniumGTCRecord getRecord(int index);\npublic double getHetPercent();\npublic String getSampleName();\npublic String getSamplePlate();\npublic String getSampleWell();\npublic String getClusterFile();\npublic String getSnpManifest();\npublic String getImagingDate();\npublic String getAutoCallDate();\npublic String getAutoCallVersion();\npublic int[] getRawControlXIntensities();\npublic int[] getRawControlYIntensities();\npublic String getScannerName();\npublic int getPmtGreen();\npublic int getPmtRed();\npublic String getScannerVersion();\npublic String getImagingUser();\npublic double getCallRate();\npublic String getGender();\npublic int getNumberOfSnps();\npublic int getNumCalls();\npublic int getNumNoCalls();\npublic int getRawControlXIntensity(int index);\npublic int getRawControlYIntensity(int index);\npublic int getPloidy();\npublic int getPloidyType();\npublic int getP05Red();\npublic int getP50Red();\npublic int getP95Red();\npublic int getP05Green();\npublic int getP50Green();\npublic int getP95Green();\npublic float getLogRDev();\npublic float getP10GC();\npublic float getP50GC();\npublic int getNumIntensityOnly();\npublic long getAaCalls();\npublic long getBbCalls();\npublic String getSentrixBarcode();\npublic int getDx();\npublic byte[][] getBaseCalls();\npublic int getAbCalls();\npublic int[] getRawXIntensities();\npublic int[] getRawYIntensities();\npublic float[] getNormalizedXIntensities();\npublic float[] getNormalizedYIntensities();\npublic float[] getbAlleleFreqs();\npublic float[] getLogRRatios();\npublic float[] getRIlmn();\npublic float[] getThetaIlmn();\npublic byte[] getGenotypeBytes();\npublic float[] getGenotypeScores();\n","12":"private final static Logger logger = LoggerFactory.getLogger(MutationMention.class);\nprotected Type type;\nprotected Tool tool;\nprotected EntityOffset location;\nprotected String text;\nprotected String ref;\nprotected String wtResidue;\nprotected String mutResidue;\nprotected String position;\nprotected boolean nsm;\nprotected boolean psm;\nprotected boolean ambiguous;\nprotected int patternId;\nprivate static final Pattern pattern = Pattern.compile(\"^([A-Z])([\\\\-\\\\+\\\\*]?[1-9][0-9]*[\\\\-\\\\+]?[0-9]*)([A-Z])$\");\nprivate static final ArrayList<String> atgc = new ArrayList<String>(Arrays.asList(\"A\", \"T\", \"G\", \"C\"));\nprotected List<dbSNPNormalized> normalized;\nprotected Set<TranscriptNormalized> transcripts;\npublic void normalizeSequences(Set<Transcript> candidateTranscripts, List<UniprotFeature> features, boolean append);\npublic void normalizeSNP(int id);\npublic void normalizeSNP(List<dbSNP> candidates, List<UniprotFeature> features, boolean append);\nprivate boolean checkPSM_WildType(dbSNP candidate, boolean forward);\nprivate boolean checkPSM_Mutated(dbSNP candidate, boolean forward);\nprivate boolean normalizePSMSimple(dbSNP candidate);\nprivate boolean normalizePSMMethionine(dbSNP candidate);\nprivate UniprotFeature normalizePSMVariableOffset(dbSNP candidate, List<UniprotFeature> features);\nprivate boolean normalizePSMSimpleHGVS(dbSNP candidate);\nprivate boolean normalizePSMSimpleHGVSSwap(dbSNP candidate);\nprivate boolean normalizePSMMethionineHGVS(dbSNP candidate);\nprivate boolean normalizePSMMethionineSwapHGVS(dbSNP candidate);\nprivate boolean forwardNSMSimple(dbSNP candidate);\nprivate boolean reverseNSMSimple(dbSNP candidate);\npublic static Map<Integer, List<MutationMention>> readMutations(String file) throws IOException;\npublic EntityOffset getLocation();\npublic int getStart();\npublic int getEnd();\nprivate void setLocation(EntityOffset location);\npublic String getWtResidue();\npublic void setWtResidue(String wtResidue);\npublic String getMutResidue();\npublic void setMutResidue(String mutResidue);\npublic String getPosition();\npublic void setPosition(String position);\npublic boolean isNsm();\npublic void setNsm(boolean nsm);\npublic boolean isPsm();\npublic void setPsm(boolean psm);\npublic boolean isAmbiguous();\npublic void setAmbiguous(boolean ambiguous);\npublic Type getType();\npublic Tool getTool();\npublic String getText();\npublic String getRef();\npublic List<dbSNPNormalized> getNormalized();\npublic List<dbSNPNormalized> getBestNormalized();\npublic Set<TranscriptNormalized> getTranscripts();\npublic int getPatternId();\npublic void setPatternId(int patternId);\npublic boolean equals(Object o);\npublic int hashCode();\npublic String toHGVS();\nprivate static String cleanSETHString(String mutation);\nprivate boolean isAminoAcid();\nprivate boolean isNucleotide();\nprivate boolean isAmgib();\nprivate void setMutationLocation();\npublic String toString();\npublic String toNormalized();\n","13":"private final Map<SearchEngineCvTermReference, Map<SearchEngineScoreCvTermReference, Number>> scores;\npublic Map<SearchEngineScoreCvTermReference, Number> getScores(SearchEngineCvTermReference se);\npublic List<Number> getScores(SearchEngineScoreCvTermReference scoreCvTerm);\npublic Number getScore(SearchEngineCvTermReference se, SearchEngineScoreCvTermReference ref);\npublic List<Number> getAllScoreValues();\npublic List<SearchEngineCvTermReference> getSearchEngineCvTermReferences();\npublic void addScore(SearchEngineCvTermReference se, SearchEngineScoreCvTermReference ref, Number num);\npublic void removeScore(SearchEngineCvTermReference se);\npublic void removeScore(SearchEngineCvTermReference se, SearchEngineScoreCvTermReference ref);\npublic SearchEngineCvTermReference getDefaultSearchEngine();\npublic List<SearchEngineScoreCvTermReference> getSearchEngineScoreCvTermReferenceWithValues();\npublic Number getValueBySearchEngineScoreTerm(String accession);\npublic boolean equals(Object o);\npublic int hashCode();\n","14":"private final SamReader leftReader;\nprivate final SamReader rightReader;\nprivate boolean sequenceDictionariesDiffer;\nprivate final SamComparisonMetric comparisonMetric = new SamComparisonMetric();\nprivate final SAMComparisonArgumentCollection samComparisonArgumentCollection;\nprivate final Histogram<String> mappingQualityHistogram = new Histogram<>();\nprivate SortingCollection<SAMRecord> markDuplicatesCheckLeft;\nprivate SortingCollection<SAMRecord> markDuplicatesCheckRight;\npublic void writeReport(final File output);\npublic void writeReport(final File output, final List<Header> headers);\nprivate void setupLenientDuplicateChecking();\nprivate void countLenientDuplicateMarkingDifferences();\nprivate boolean compareAlignmentsAndCatalogDuplicateMarkingDifferences();\nprivate boolean compareCoordinateSortedAlignments();\nprivate int compareAlignmentCoordinates(final SAMRecord left, final SAMRecord right);\nprivate boolean compareQueryNameSortedAlignments();\nprivate boolean compareUnsortedAlignments();\nprivate void consumeUnmatchedRights(final SecondaryOrSupplementarySkippingIterator rightIt, final Map<PrimaryAlignmentKey, SAMRecord> leftUnmatched);\nprivate void consumeAll(final SecondaryOrSupplementarySkippingIterator it, final BiConsumer<SAMRecord, PrimaryAlignmentKey> recordKeyHandler);\nprivate int countRemaining(final SecondaryOrSupplementarySkippingIterator it);\nprivate AlignmentComparison compareAlignmentRecords(final SAMRecord s1, final SAMRecord s2);\nprivate boolean alignmentsMatch(final SAMRecord s1, final SAMRecord s2);\nprivate void compareAndUpdateMappingQualityConcordance(final SAMRecord s1, final SAMRecord s2);\nprivate void catalogDuplicateDifferences(final SAMRecord s1, final SAMRecord s2);\nprivate boolean compareHeaders();\nprivate boolean compareProgramRecords(final SAMFileHeader h1, final SAMFileHeader h2);\nprivate static boolean compareProgramRecord(final SAMProgramRecord programRecord1, final SAMProgramRecord programRecord2);\nprivate static boolean compareReadGroups(final SAMFileHeader h1, final SAMFileHeader h2);\nprivate static boolean compareReadGroup(final SAMReadGroupRecord samReadGroupRecord1, final SAMReadGroupRecord samReadGroupRecord2);\nprivate boolean compareSequenceDictionaries(final SAMFileHeader h1, final SAMFileHeader h2);\nprivate boolean compareSequenceRecord(final SAMSequenceRecord sequenceRecord1, final SAMSequenceRecord sequenceRecord2, final int which);\nprivate static boolean compareValues(final T v1, final T v2, final String label);\nprivate static void reportDifference(final String s1, final String s2, final String label);\nprivate static void reportDifference(Object o1, Object o2, final String label);\npublic int getMappingsMatch();\npublic int getUnmappedBoth();\npublic int getUnmappedLeft();\npublic int getUnmappedRight();\npublic int getMappingsDiffer();\npublic int getMissingLeft();\npublic int getMissingRight();\npublic int getDuplicateMarkingsDiffer();\npublic boolean areEqual();\n","15":"public static final byte F = 0, R = 1, FF = 2, FR = 3, RR = 4, RF = 5;\npublic short libraryId;\npublic byte orientation;\npublic int read1ReferenceIndex = -1;\npublic int read1Coordinate = -1;\npublic int read2ReferenceIndex = -1;\npublic int read2Coordinate = -1;\npublic short readGroup = -1;\npublic byte orientationForOpticalDuplicates = -1;\npublic transient boolean isOpticalDuplicate = false;\npublic boolean isPaired();\npublic short getReadGroup();\npublic void setReadGroup(final short readGroup);\npublic short getLibraryId();\npublic void setLibraryId(final short libraryId);\n","16":"public static void replaceHardClips(SAMRecord read);\nprivate static String padBases(int length);\npublic static void removeSoftClips(SAMRecord read);\npublic static Cigar subset(Cigar cigar, int startIdx, int endIdx);\npublic static int getEditDistance(SAMRecord read, CompareToReference2 c2r);\npublic static int getOrigEditDistance(SAMRecord read);\npublic static int getIntAttribute(SAMRecord read, String attribute);\npublic static int getNumIndels(SAMRecord read);\npublic static boolean isSoftClipEquivalent(SAMRecord origRead, SAMRecord updatedRead);\npublic static SAMRecord cloneRead(SAMRecord read);\npublic static boolean isFiltered(boolean isPairedEnd, SAMRecord read);\npublic static boolean isPrimary(SAMRecord read);\n","17":"protected static Logger logger = LogManager.getLogger(MannWhitneyU.class);\nprivate static final double NORMAL_MEAN = 0;\nprivate static final double NORMAL_SD = 1;\nprivate static final NormalDistribution NORMAL = new NormalDistribution(NORMAL_MEAN, NORMAL_SD);\nprivate static Map<Key, Set<List<Integer>>> PERMUTATIONS = new ConcurrentHashMap<Key, Set<List<Integer>>>();\nprivate int minimumNormalN = 10;\npublic void setMinimumSeriesLengthForNormalApproximation(final int n);\npublic RankedData calculateRank(final double[] series1, final double[] series2);\npublic TestStatistic calculateU1andU2(final double[] series1, final double[] series2);\npublic double transformTies(int numOfRanks, ArrayList<Integer> numOfTies);\npublic TestStatistic calculateOneSidedU(final double[] series1, final double[] series2, final TestType whichSeriesDominates);\npublic TestStatistic calculateTwoSidedU(final double[] series1, final double[] series2);\npublic double calculateZ(final double u, final int n1, final int n2, final double nties, final TestType whichSide);\npublic Result test(final double[] series1, final double[] series2, final TestType whichSide);\nprivate void swap(Integer[] arr, int i, int j);\nprivate void calculatePermutations(Integer[] temp, Set<List<Integer>> allPermutations);\n Set<List<Integer>> getPermutations(final Integer[] listToPermute, int numOfPermutations);\npublic double permutationTest(final double[] series1, final double[] series2, final double testStatU);\n","18":"private final File file;\npublic PedFileContents read() throws IOException, PedParseException;\npublic static PedFileContents read(InputStream stream) throws IOException, PedParseException;\nprivate static PedPerson readIndividual(String line) throws PedParseException;\n","19":"static final long serialVersionUID = 1020;\nprivate double[][] U, V;\nprivate double[] s;\nprivate int m, n;\nstatic private int maxIterationsDefault = 100000;\nprivate static final String ERROR_STRING = \"SVD is not converged.\";\npublic double cond();\npublic double[] getSingularValues();\npublic DoubleMatrix2D getU();\npublic DoubleMatrix2D getV();\npublic double norm2();\npublic int rank();\npublic String toString();\n","20":"private final static ILoggingTool LOGGER = createLoggingTool(FingerprintGenerator.class);\npublic static int getFingerprinterSize();\nfinal CircularFingerprinter fingerprinter;\n","21":"private static PrideObjectsFactory instance = null;\npublic static PrideObjectsFactory getInstance() throws FileNotFoundException, IOException, ClassNotFoundException;\nprivate static String prideFolder = System.getProperty(\"user.home\") + \"\/.compomics\/pride\/\";\npublic static final String extension = \".cus\";\nprivate static final HashMap<String, ContactGroup> contactGroups = new HashMap<String, ContactGroup>();\nprivate static final HashMap<String, Instrument> instruments = new HashMap<String, Instrument>();\nprivate static final HashMap<String, Protocol> protocols = new HashMap<String, Protocol>();\nprivate static final HashMap<String, ReferenceGroup> references = new HashMap<String, ReferenceGroup>();\nprivate static final HashMap<String, Sample> samples = new HashMap<String, Sample>();\nprivate static PtmToPrideMap ptmToPrideMap;\nprivate void loadObjects() throws FileNotFoundException, IOException, ClassNotFoundException;\nprivate void createDefaultObjects() throws FileNotFoundException, IOException, ClassNotFoundException;\npublic void addContactGroup(ContactGroup contactGroup) throws IOException;\npublic void deleteContactGroup(ContactGroup contactGroup);\npublic void addProtocol(Protocol protocol) throws IOException;\npublic void deleteProtocol(Protocol protocol);\npublic void addInstrument(Instrument instrument) throws IOException;\npublic void deleteInstrument(Instrument instrument);\npublic void addReferenceGroup(ReferenceGroup referenceGroup) throws IOException;\npublic void deleteReferenceGroup(ReferenceGroup referenceGroup);\npublic void addSample(Sample sample) throws IOException;\npublic void deleteSample(Sample sample);\npublic void setPtmToPrideMap(PtmToPrideMap ptmToPrideMap) throws FileNotFoundException, IOException;\nprivate Object loadObject(File aFile) throws FileNotFoundException, IOException, ClassNotFoundException;\nprivate void saveObject(File destinationFolder, PrideObject object) throws IOException;\npublic HashMap<String, ContactGroup> getContactGroups();\npublic HashMap<String, Instrument> getInstruments();\npublic HashMap<String, Protocol> getProtocols();\npublic PtmToPrideMap getPtmToPrideMap();\npublic HashMap<String, ReferenceGroup> getReferenceGroups();\npublic HashMap<String, Sample> getSamples();\npublic static String getPrideFolder();\npublic static void setPrideFolder(String prideFolder);\n","22":"String NO_CALL_STRING = \".\";\nString SPAN_DEL_STRING = \"*\";\nchar SINGLE_BREAKEND_INDICATOR = '.';\nchar BREAKEND_EXTENDING_RIGHT = '[';\nchar BREAKEND_EXTENDING_LEFT = ']';\nchar SYMBOLIC_ALLELE_START = '<';\nchar SYMBOLIC_ALLELE_END = '>';\nString NON_REF_STRING = \"<NON_REF>\";\nString UNSPECIFIED_ALTERNATE_ALLELE_STRING = \"<*>\";\nAllele REF_A = new SimpleAllele(\"A\", true);\nAllele ALT_A = new SimpleAllele(\"A\", false);\nAllele REF_C = new SimpleAllele(\"C\", true);\nAllele ALT_C = new SimpleAllele(\"C\", false);\nAllele REF_G = new SimpleAllele(\"G\", true);\nAllele ALT_G = new SimpleAllele(\"G\", false);\nAllele REF_T = new SimpleAllele(\"T\", true);\nAllele ALT_T = new SimpleAllele(\"T\", false);\nAllele REF_N = new SimpleAllele(\"N\", true);\nAllele ALT_N = new SimpleAllele(\"N\", false);\nAllele SPAN_DEL = new SimpleAllele(SPAN_DEL_STRING, false);\nAllele NO_CALL = new SimpleAllele(NO_CALL_STRING, false);\nAllele NON_REF_ALLELE = new SimpleAllele(NON_REF_STRING, false);\nAllele UNSPECIFIED_ALTERNATE_ALLELE = new SimpleAllele(UNSPECIFIED_ALTERNATE_ALLELE_STRING, false);\n@SuppressWarnings(\"unused\")\nAllele SV_SIMPLE_DEL = StructuralVariantType.DEL.toSymbolicAltAllele();\n@SuppressWarnings(\"unused\")\nAllele SV_SIMPLE_INS = StructuralVariantType.INS.toSymbolicAltAllele();\n@SuppressWarnings(\"unused\")\nAllele SV_SIMPLE_INV = StructuralVariantType.INV.toSymbolicAltAllele();\n@SuppressWarnings(\"unused\")\nAllele SV_SIMPLE_CNV = StructuralVariantType.CNV.toSymbolicAltAllele();\n@SuppressWarnings(\"unused\")\nAllele SV_SIMPLE_DUP = StructuralVariantType.DUP.toSymbolicAltAllele();\n static Allele create(byte[] bases, boolean isRef);\n static Allele create(byte base, boolean isRef);\n static Allele create(byte base);\n static Allele extend(Allele left, byte[] right);\n static boolean wouldBeNullAllele(byte[] bases);\n static boolean wouldBeStarAllele(byte[] bases);\n static boolean wouldBeNoCallAllele(byte[] bases);\n static boolean wouldBeBreakpoint(byte[] bases);\n static boolean wouldBeSingleBreakend(byte[] bases);\n static boolean acceptableAlleleBases(String bases);\n static boolean acceptableAlleleBases(String bases, boolean isReferenceAllele);\n static boolean acceptableAlleleBases(byte[] bases);\n static boolean acceptableAlleleBases(byte[] bases, boolean isReferenceAllele);\n static Allele create(String bases, boolean isRef);\n static Allele create(String bases);\n static Allele create(byte[] bases);\n static Allele create(Allele allele, boolean ignoreRefState);\n static boolean oneIsPrefixOfOther(final Allele a1, final Allele a2);\n boolean isPrefixOf(final Allele other);\n boolean isNoCall();\n boolean isCalled();\n boolean isReference();\n boolean isNonReference();\n boolean isSymbolic();\n boolean isBreakpoint();\n boolean isSingleBreakend();\n String toString();\n byte[] getBases();\n String getBaseString();\n String getDisplayString();\n byte[] getDisplayBases();\n boolean equals(Object other);\n int hashCode();\n boolean equals(Allele other, boolean ignoreRefState);\n boolean basesMatch(byte[] test);\n boolean basesMatch(String test);\n boolean basesMatch(Allele test);\n int length();\n boolean isNonRefAllele();\n","23":"private static final long serialVersionUID = 1L;\nprivate final SAMFileHeader header;\npublic int compare(final SAMRecord samRecord1, final SAMRecord samRecord2);\n","24":"private static final int PHRED33_TO_PHRED64_DIFF = 31;\npublic String phred33ToPhred64(String phred33);\n","25":"static final long serialVersionUID = 1020;\nprivate double[][] U, V;\nprivate double[] s;\nprivate int m, n;\nstatic private int maxIterationsDefault = 100000;\nprivate static final String ERROR_STRING = \"SVD is not converged.\";\npublic double cond();\npublic DoubleMatrix2D getS();\npublic double[] getSingularValues();\npublic DoubleMatrix2D getU();\npublic DoubleMatrix2D getV();\npublic double norm2();\npublic String toString();\n","26":"public static final int MIN_MATCH_BASES = 12;\npublic static final int MIN_MATCH_PE_BASES = 6;\npublic static final double MAX_ERROR_RATE = 0.10;\npublic static final double MAX_PE_ERROR_RATE = 0.10;\npublic static final int NO_MATCH = -1;\nprivate static final Log log = Log.getInstance(ClippingUtility.class);\npublic static void adapterTrimIlluminaSingleRead(final SAMRecord read, final AdapterPair adapter);\npublic static void adapterTrimIlluminaSingleRead(final SAMRecord read, final AdapterPair adapter, final int minMatchBases, final double maxErrorRate);\npublic static AdapterPair adapterTrimIlluminaSingleRead(final SAMRecord read, final AdapterPair... adapters);\npublic static AdapterPair adapterTrimIlluminaSingleRead(final SAMRecord read, final int minMatchBases, final double maxErrorRate, final AdapterPair... adapters);\npublic static Tuple<AdapterPair, Integer> findAdapterPairAndIndexForSingleRead(final byte[] read, final int minMatchBases, final double maxErrorRate, final int templateIndex, final AdapterPair... adapters);\npublic static String adapterTrimIlluminaPairedReads(final SAMRecord read1, final SAMRecord read2, final AdapterPair adapters);\npublic static String adapterTrimIlluminaPairedReads(final SAMRecord read1, final SAMRecord read2, final AdapterPair adapters, final int minMatchBases, final double maxErrorRate);\npublic static AdapterPair adapterTrimIlluminaPairedReads(final SAMRecord read1, final SAMRecord read2, final AdapterPair... adapters);\npublic static AdapterPair adapterTrimIlluminaPairedReads(final SAMRecord read1, final SAMRecord read2, final int minMatchBases, final double maxErrorRate, final AdapterPair... adapters);\nprivate static boolean attemptOneSidedMatch(final SAMRecord read1, final SAMRecord read2, final int index1, final int index2, final int stricterMinMatchBases);\npublic static int findIndexOfClipSequence(final byte[] read, final byte[] adapterSequence, final int minMatch, final double maxErrorRate);\n","27":"private final Map<Object, IntervalTree<Set<T>>> cache = new HashMap<>();\nprivate final int lhsBuffer;\nprivate final int rhsBuffer;\npublic static OverlapDetector<T> create(final List<T> intervals);\npublic void addLhs(final T object, final Locatable interval);\nprivate static BiFunction<Set<T>, Set<T>, Set<T>> mergeSetsAccountingForSingletons();\npublic Set<T> getAll();\npublic boolean overlapsAny(final Locatable locatable);\npublic Set<T> getOverlaps(final Locatable locatable);\n","28":"public static String toString(Collection<E> collection);\npublic static String join(String delim, Object... args);\npublic static String joinNotNull(String delim, Object... args);\npublic static V getOrElse(Map<K, V> map, K key, V or);\npublic static int toInt(String intStr);\npublic static double roundHalfEven(String pattern, double value);\npublic static String getRoundedValueToPrint(String pattern, double value);\npublic static String substr(String string, int idx);\npublic static String substr(String string, int begin, int len);\npublic static char charAt(String str, int index);\npublic static char charAt(StringBuilder str, int index);\npublic static int sum(Collection<?> list);\npublic static List<String> globalFind(jregex.Pattern alignedLength, String string);\npublic static String getReverseComplementedSequence(SAMRecord record, int startIndex, int length);\npublic static String reverse(String string);\npublic static String complement(String string);\npublic static void complement(byte[] bases);\npublic static char complement(char character);\n","29":"private static final long serialVersionUID = 6185086957226269797L;\nprivate static final int N = 624;\nprivate static final int M = 397;\nprivate static final int MATRIX_A = 0x9908b0df;\nprivate static final int UPPER_MASK = 0x80000000;\nprivate static final int LOWER_MASK = 0x7fffffff;\nprivate static final int TEMPERING_MASK_B = 0x9d2c5680;\nprivate static final int TEMPERING_MASK_C = 0xefc60000;\nprivate int[] mt;\nprivate int mti;\nprivate int[] mag01;\nprivate static final long GOOD_SEED = 4357;\nprivate double nextNextGaussian;\nprivate boolean haveNextNextGaussian;\npublic static final MersenneTwisterFast DEFAULT_INSTANCE = new MersenneTwisterFast();\nprivate static long seedAdditive_ = 0;\nprivate long initializationSeed;\npublic final void setSeed(long seed);\npublic final long getSeed();\nprivate synchronized int next();\npublic final int nextInt();\npublic final short nextShort();\npublic final char nextChar();\npublic final boolean nextBoolean();\npublic final byte nextByte();\npublic final void nextBytes(byte[] bytes);\npublic final long nextLong();\npublic final double nextDouble();\npublic final double nextGaussian();\npublic final float nextFloat();\npublic int nextInt(int n);\npublic final void permute(int[] array);\npublic final void shuffle(int[] array);\npublic int[] shuffled(int l);\npublic int[] permuted(int l);\npublic double nextGamma(double alpha, double lambda);\nprivate long poissonian_reject(double lambda);\nprivate long poissonian_icdf(double lambda);\npublic long nextPoisson(double lambda);\npublic static void main(String[] args) throws FileNotFoundException;\n","30":"private double[][] rows;\nprivate int[] permutation = null;\nprivate int parity = 1;\nprivate double[] backwardSubstitution(double[] xTilde);\nprivate void decompose();\nprivate boolean decomposed();\npublic double determinant();\npublic boolean isPD();\nprivate double[] forwardSubstitution(double[] c);\nprivate void initialize();\npublic double[][] inverseMatrixComponents();\nprivate int largestPivot(int k);\nprivate void pivot(int k);\npublic double[] solve(double[] c);\npublic Vector solve(Vector c);\nprivate void swapRows(int i, int k);\npublic static void symmetrizeComponents(double[][] components);\npublic String toString();\n","31":"private final TranscriptModel transcript;\npublic TranscriptModel getTranscript();\npublic GenomeInterval getStartCodonInterval();\npublic GenomeInterval getStopCodonInterval();\npublic GenomeInterval getFivePrimeUTRInterval();\npublic ImmutableList<GenomeInterval> getFivePrimeUTRExonIntervals();\nprivate ImmutableList<GenomeInterval> getIntersectedExons(GenomeInterval other);\npublic boolean overlapsWithFivePrimeUTRExon(GenomeInterval itv);\npublic GenomeInterval getThreePrimeUTRInterval();\npublic ImmutableList<GenomeInterval> getThreePrimeUTRExonIntervals();\npublic boolean overlapsWithThreePrimeUTRExon(GenomeInterval itv);\npublic boolean containsExon(GenomeInterval interval);\npublic boolean overlapsWithCDSExon(GenomeInterval interval);\npublic boolean liesInCDSExon(GenomeInterval interval);\npublic boolean liesInCDSExon(GenomePosition pos);\npublic boolean overlapsWithCDS(GenomeInterval interval);\npublic boolean liesInCDS(GenomePosition pos);\npublic boolean overlapsWithIntron(GenomeInterval changeInterval);\npublic boolean overlapsWithCDSIntron(GenomeInterval changeInterval);\npublic boolean liesInCDSIntron(GenomePosition pos);\npublic boolean overlapsWithTranslationalStartSite(GenomeInterval interval);\npublic boolean liesInTranslationalStartSite(GenomePosition pos);\npublic boolean overlapsWithTranslationalStopSite(GenomeInterval interval);\npublic boolean liesInTranslationalStopSite(GenomePosition pos);\npublic boolean overlapsWithSpliceRegion(GenomeInterval interval);\npublic boolean liesInSpliceRegion(GenomePosition pos);\npublic boolean overlapsWithSpliceDonorSite(GenomeInterval interval);\npublic boolean liesInSpliceDonorSite(GenomePosition pos);\npublic boolean overlapsWithSpliceAcceptorSite(GenomeInterval interval);\npublic boolean liesInSpliceAcceptorSite(GenomePosition pos);\npublic static int UPSTREAM_LENGTH = 5_000;\npublic GenomeInterval getUpstreamInterval();\npublic boolean overlapsWithUpstreamRegion(GenomeInterval interval);\npublic boolean liesInUpstreamRegion(GenomePosition pos);\npublic static int DOWNSTREAM_LENGTH = 5_000;\npublic GenomeInterval getDownstreamInterval();\npublic boolean overlapsWithDownstreamRegion(GenomeInterval interval);\npublic boolean liesInDownstreamRegion(GenomePosition pos);\npublic boolean overlapsWithFivePrimeUTR(GenomeInterval interval);\npublic boolean liesInFivePrimeUTR(GenomePosition pos);\npublic boolean overlapsWithThreePrimeUTR(GenomeInterval interval);\npublic boolean liesInThreePrimeUTR(GenomePosition pos);\npublic boolean liesInIntron(GenomeInterval interval);\npublic boolean liesInExon(GenomeInterval interval);\npublic boolean liesInExon(GenomePosition pos);\npublic boolean overlapsWithExon(GenomeInterval interval);\n","32":"private final Pedigree pedigree;\npublic Pedigree getPedigree();\npublic boolean isParentOfAffected(Person person);\npublic ImmutableSet<String> getUnaffectedNames();\npublic ImmutableSet<String> getAffectedFemaleParentNames();\npublic ImmutableSet<String> getAffectedMaleParentNames();\npublic ImmutableList<Person> getParents();\npublic int getNumberOfParents();\npublic int getNumberOfAffecteds();\npublic int getNumberOfUnaffecteds();\npublic ImmutableMap<Person, ImmutableList<Person>> buildSiblings();\n","33":"private static final long serialVersionUID = 6185086957226269797L;\nprivate static final int N = 624;\nprivate static final int M = 397;\nprivate static final int MATRIX_A = 0x9908b0df;\nprivate static final int UPPER_MASK = 0x80000000;\nprivate static final int LOWER_MASK = 0x7fffffff;\nprivate static final int TEMPERING_MASK_B = 0x9d2c5680;\nprivate static final int TEMPERING_MASK_C = 0xefc60000;\nprivate int[] mt;\nprivate int mti;\nprivate int[] mag01;\nprivate static final long GOOD_SEED = 4357;\nprivate double nextNextGaussian;\nprivate boolean haveNextNextGaussian;\npublic static final MersenneTwisterFast DEFAULT_INSTANCE = new MersenneTwisterFast();\nprivate static long seedAdditive_ = 0;\nprivate long initializationSeed;\npublic final void setSeed(long seed);\npublic final long getSeed();\nprivate synchronized int next();\npublic final int nextInt();\npublic final short nextShort();\npublic final char nextChar();\npublic final boolean nextBoolean();\npublic final byte nextByte();\npublic final void nextBytes(byte[] bytes);\npublic final long nextLong();\npublic final double nextDouble();\npublic final double nextGaussian();\npublic final float nextFloat();\npublic int nextInt(int n);\npublic final void shuffle(int[] array);\npublic final void shuffle(int[] array, int numberOfShuffles);\npublic int[] shuffled(int l);\npublic int[] permuted(int l);\npublic double nextGamma(double alpha, double lambda);\nprivate long poissonian_reject(double lambda);\nprivate long poissonian_icdf(double lambda);\npublic long nextPoisson(double lambda);\npublic static void main(String[] args) throws FileNotFoundException;\n","34":"private final File basecallDirectory;\nprivate final IlluminaParser[] parsers;\nprivate final IlluminaDataType[][] dataTypes;\npublic ClusterData next();\npublic void remove();\npublic void seekToTile(final Integer oneBasedTileNumber);\npublic void close();\n","35":"private final SortOrder sortOrder;\n","36":"private final SortOrder sortOrder;\n","37":"public static final String PARAMETER_DOC = \"A description of the logical structure of clusters in an Illumina Run, i.e. a description of the structure IlluminaBasecallsToSam \" + \"assumes the  data to be in. It should consist of integer\/character pairs describing the number of cycles and the type of those \" + \"cycles (B for Sample Barcode, M for molecular barcode, T for Template, and S for skip).  E.g. If the input data consists of 80 \" + \"base clusters and we provide a read structure of \\\"28T8M8B8S28T\\\" then the sequence may be split up into four reads:\\n\" + \"* read one with 28 cycles (bases) of template\\n\" + \"* read two with 8 cycles (bases) of molecular barcode (ex. unique molecular barcode)\\n\" + \"* read three with 8 cycles (bases) of sample barcode\\n\" + \"* 8 cycles (bases) skipped.\\n\" + \"* read four with 28 cycles (bases) of template\\n\" + \"The skipped cycles would NOT be included in an output SAM\/BAM file or in read groups therein.\";\npublic final List<ReadDescriptor> descriptors;\npublic final int totalCycles;\npublic final int[] readLengths;\npublic final Substructure sampleBarcodes;\npublic final Substructure templates;\npublic final Substructure molecularBarcode;\npublic final Substructure skips;\npublic final Substructure nonSkips;\nprivate static final String ValidTypeChars;\nprivate static final String ValidTypeCharsWSep;\nprivate static final String ReadStructureMsg = \"Read structure must be formatted as follows: \" + \"<number of bases><type><number of bases><type>...<number of bases> where number of bases is a \" + \"positive (NON-ZERO) integer and type is one of the following characters \" + ValidTypeCharsWSep + \" (e.g. 76T8B68T would denote a paired-end run with a 76 base first end an 8 base barcode followed by a 68 base second end).\";\nprivate static final Pattern SubPattern = Pattern.compile(\"(\\\\d+)([\" + ValidTypeChars + \"]{1})\");\nprivate static final Pattern FullPattern = Pattern.compile(\"^(\" + SubPattern.pattern() + \")+$\");\npublic int getNumDescriptors();\npublic String toString();\npublic boolean equals(final Object thatObj);\npublic int hashCode();\npublic boolean hasSampleBarcode();\n","38":"protected double[][] components;\nprotected LUPDecomposition lupDecomposition = null;\npublic void accumulate(Matrix a) throws IllegalDimension;\npublic Matrix add(Matrix a) throws IllegalDimension;\nprotected double[][] addComponents(Matrix a);\npublic void clear();\npublic int columns();\npublic double component(int n, int m);\npublic double determinant() throws IllegalDimension;\npublic boolean isPD() throws IllegalDimension;\npublic boolean equals(Matrix a);\npublic Matrix inverse() throws ArithmeticException;\npublic boolean isSquare();\nprotected LUPDecomposition lupDecomposition() throws IllegalDimension;\npublic Matrix product(double a);\npublic Vector product(Vector v) throws IllegalDimension;\npublic Matrix product(Matrix a) throws IllegalDimension;\nprotected double[][] productComponents(Matrix a);\npublic Matrix productWithTransposed(Matrix a) throws IllegalDimension;\nprotected double[][] productWithTransposedComponents(Matrix a);\npublic int rows();\nprotected Vector secureProduct(Vector v);\nprotected Matrix secureProduct(Matrix a);\nprotected Matrix secureSubtract(Matrix a);\npublic Matrix subtract(Matrix a) throws IllegalDimension;\nprotected double[][] subtractComponents(Matrix a);\npublic double[][] toComponents();\npublic String toString();\npublic String toStringOctave();\npublic Matrix transpose();\npublic SymmetricMatrix transposedProduct();\npublic Matrix transposedProduct(Matrix a) throws IllegalDimension;\nprotected double[][] transposedProductComponents(Matrix a);\n","39":"private final Pedigree pedigree;\npublic Pedigree getPedigree();\npublic boolean isParentOfAffected(Person person);\npublic ImmutableSet<String> getUnaffectedNames();\npublic ImmutableSet<String> getParentNames();\npublic ImmutableSet<String> getAffectedFemaleParentNames();\npublic ImmutableList<Person> getParents();\npublic int getNumberOfParents();\npublic int getNumberOfAffecteds();\npublic int getNumberOfUnaffecteds();\npublic ImmutableMap<Person, ImmutableList<Person>> buildSiblings();\n","40":"private final Pedigree pedigree;\npublic Pedigree getPedigree();\npublic boolean isParentOfAffected(Person person);\npublic ImmutableSet<String> getUnaffectedNames();\npublic ImmutableSet<String> getParentNames();\npublic ImmutableSet<String> getAffectedMaleParentNames();\npublic ImmutableList<Person> getParents();\npublic int getNumberOfParents();\npublic int getNumberOfAffecteds();\npublic int getNumberOfUnaffecteds();\npublic ImmutableMap<Person, ImmutableList<Person>> buildSiblings();\n","41":"public static IStereoAndConformation getChirality2D(WedgeStereoLifter lifter, IAtom atom, IAtomContainer atomContainer);\npublic static IStereoAndConformation getChirality2D(IStereoElement stereoElement, IAtomContainer atomContainer);\npublic Map<IAtom, IStereoAndConformation> getTetrahedralChiralities(IAtomContainer atomContainer);\n","42":"private static final long serialVersionUID = 6185086957226269797L;\nprivate static final int N = 624;\nprivate static final int M = 397;\nprivate static final int MATRIX_A = 0x9908b0df;\nprivate static final int UPPER_MASK = 0x80000000;\nprivate static final int LOWER_MASK = 0x7fffffff;\nprivate static final int TEMPERING_MASK_B = 0x9d2c5680;\nprivate static final int TEMPERING_MASK_C = 0xefc60000;\nprivate int[] mt;\nprivate int mti;\nprivate int[] mag01;\nprivate static final long GOOD_SEED = 4357;\nprivate double nextNextGaussian;\nprivate boolean haveNextNextGaussian;\npublic static final MersenneTwisterFast DEFAULT_INSTANCE = new MersenneTwisterFast();\nprivate static long seedAdditive_ = 0;\nprivate long initializationSeed;\npublic final void setSeed(long seed);\npublic final long getSeed();\nprivate synchronized int next();\npublic final int nextInt();\npublic final short nextShort();\npublic final char nextChar();\npublic final boolean nextBoolean();\npublic final byte nextByte();\npublic final void nextBytes(byte[] bytes);\npublic final long nextLong();\npublic final double nextDouble();\npublic final double nextGaussian();\npublic final float nextFloat();\npublic int nextInt(int n);\npublic final void permute(int[] array);\npublic final void shuffle(int[] array, int numberOfShuffles);\npublic int[] shuffled(int l);\npublic int[] permuted(int l);\npublic double nextGamma(double alpha, double lambda);\nprivate long poissonian_reject(double lambda);\nprivate long poissonian_icdf(double lambda);\npublic long nextPoisson(double lambda);\npublic static void main(String[] args) throws FileNotFoundException;\n","43":"public static void replaceHardClips(SAMRecord read);\nprivate static String padBases(int length);\npublic static void removeSoftClips(SAMRecord read);\npublic static Cigar subset(Cigar cigar, int startIdx, int endIdx);\npublic static int getEditDistance(SAMRecord read, CompareToReference2 c2r);\npublic static int getNumIndelBases(SAMRecord read);\npublic static int getOrigEditDistance(SAMRecord read);\npublic static int getIntAttribute(SAMRecord read, String attribute);\npublic static boolean isSoftClipEquivalent(SAMRecord origRead, SAMRecord updatedRead);\npublic static SAMRecord cloneRead(SAMRecord read);\npublic static boolean isFiltered(boolean isPairedEnd, SAMRecord read);\npublic static boolean isPrimary(SAMRecord read);\n","44":"private double[][] rows;\nprivate int[] permutation = null;\nprivate int parity = 1;\nprivate double[] backwardSubstitution(double[] xTilde);\nprivate void decompose();\nprivate boolean decomposed();\npublic double determinant();\npublic boolean isPD();\nprivate void initialize();\nprivate void initialize(double[][] components);\npublic double[][] inverseMatrixComponents();\nprivate int largestPivot(int k);\nprivate void pivot(int k);\npublic double[] solve(double[] c);\npublic Vector solve(Vector c);\nprivate void swapRows(int i, int k);\npublic static void symmetrizeComponents(double[][] components);\npublic String toString();\n","45":"","46":"protected double[][] components;\nprotected LUPDecomposition lupDecomposition = null;\npublic void accumulate(Matrix a) throws IllegalDimension;\npublic Matrix add(Matrix a) throws IllegalDimension;\nprotected double[][] addComponents(Matrix a);\npublic void clear();\npublic int columns();\npublic double component(int n, int m);\npublic double determinant() throws IllegalDimension;\npublic boolean isPD() throws IllegalDimension;\npublic boolean equals(Matrix a);\npublic Matrix inverse() throws ArithmeticException;\npublic boolean isSquare();\nprotected LUPDecomposition lupDecomposition() throws IllegalDimension;\npublic Matrix product(double a);\npublic Vector product(Vector v) throws IllegalDimension;\npublic Matrix product(Matrix a) throws IllegalDimension;\nprotected double[][] productComponents(double a);\nprotected double[][] productComponents(Matrix a);\npublic Matrix productWithTransposed(Matrix a) throws IllegalDimension;\nprotected double[][] productWithTransposedComponents(Matrix a);\npublic int rows();\nprotected Vector secureProduct(Vector v);\nprotected Matrix secureProduct(Matrix a);\nprotected Matrix secureSubtract(Matrix a);\npublic Matrix subtract(Matrix a) throws IllegalDimension;\npublic double[][] toComponents();\npublic String toString();\npublic String toStringOctave();\npublic Matrix transpose();\npublic SymmetricMatrix transposedProduct();\npublic Matrix transposedProduct(Matrix a) throws IllegalDimension;\nprotected double[][] transposedProductComponents(Matrix a);\n","47":"private static final int COMPLEMENT_MASK = 3;\nprivate static final int QUALITY_MASK = 0x3f;\npublic static final byte MAX_QUALITY = QUALITY_MASK;\nprivate static final int BASE_INDEX_SHIFT = 6;\npublic static byte sqScaledProbabilityRatio(final double secondBestLikelihood, final double thirdBestLikelihood);\npublic static byte baseAndProbDiffToSqValue(final SQBase base, final byte probRatio);\npublic static byte baseAndProbDiffToSqValue(final int base, final byte probRatio);\npublic static byte sqValueToProbRatio(final byte sqValue);\npublic static SQBase sqValueToBase(final byte sqValue);\npublic static int sqValueToBaseOrdinal(final byte sqValue);\nprivate static byte complementSqValue(final byte sqValue);\n","48":"private final SAMFileHeader.SortOrder sortOrder;\nprivate SAMRecord prev;\nprivate final SAMRecordComparator comparator;\npublic SAMRecord getPreviousRecord();\npublic SAMFileHeader.SortOrder getSortOrder();\npublic String getSortKey(final SAMRecord rec);\n","49":"private final Map<Object, IntervalTree<Set<T>>> cache = new HashMap<>();\nprivate final int lhsBuffer;\nprivate final int rhsBuffer;\npublic static OverlapDetector<T> create(final List<T> intervals);\npublic void addLhs(final T object, final Locatable interval);\npublic void addAll(final List<T> objects, final List<? extends Locatable> intervals);\npublic Set<T> getAll();\npublic boolean overlapsAny(final Locatable locatable);\npublic Set<T> getOverlaps(final Locatable locatable);\n"}}